def leap_year(year):
    if (year % 4 == 0):
        if (year % 100 == 0):
            if (year % 400 == 0):
                return True
            else:
                return False
        else:
            return True
    else:
        return False

# Example usage:
year = 2024
if leap_year(year):
    print(f"{year} is a leap year.")
else:
    print(f"{year} is not a leap year.")
To complete the function `leap_year(year)`, you need to implement the logic that determines whether a given year is a leap year or not. Here are the rules for determining a leap year:

1. A year is a leap year if it is divisible by 4.
2. However, if the year is also divisible by 100, it is not a leap year, unless:
3. The year is divisible by 400, in which case it is a leap year.

Here is how you can implement this:

```python
def leap_year(year):
    if (year % 4 == 0):
        if (year % 100 == 0):
            if (year % 400 == 0):
                return True
            else:
                return False
        else:
            return True
    else:
        return False

# Example usage:
year = 2024
if leap_year(year):
    print(f"{year} is a leap year.")
else:
    print(f"{year} is not a leap year.")
```

### Explanation

1. **Divisibility by 4**:
    - If a year is divisible by 4, it is a candidate for being a leap year.
2. **Divisibility by 100**:
    - If a year is divisible by 100, it is not a leap year, except if it is also divisible by 400.
3. **Divisibility by 400**:
    - If a year is divisible by 400, it is a leap year despite being divisible by 100.

### Example

- **Year 2000**: Divisible by 4, 100, and 400 (Leap year)
- **Year 1900**: Divisible by 4 and 100, but not by 400 (Not a leap year)
- **Year 2024**: Divisible by 4, but not by 100 (Leap year)

This function follows these rules and correctly determines whether a given year is a leap year.

def is_valid_triangle(sides):
    a, b, c = sides
    return a > 0 and b > 0 and c > 0 and (a + b >= c) and (b + c >= a) and (a + c >= b)

def equilateral(sides):
    if not is_valid_triangle(sides):
        return False
    return sides[0] == sides[1] == sides[2]

def isosceles(sides):
    if not is_valid_triangle(sides):
        return False
    return sides[0] == sides[1] or sides[0] == sides[2] or sides[1] == sides[2]

def scalene(sides):
    if not is_valid_triangle(sides):
        return False
    return sides[0] != sides[1] and sides[0] != sides[2] and sides[1] != sides[2]

# Example usage:
print(equilateral([3, 3, 3]))  # True
print(isosceles([3, 3, 2]))    # True
print(scalene([3, 4, 5]))      # True


To solve the problem of calculating the number of grains of wheat on a given square of a chessboard and the total number of grains on the chessboard, we need to understand the pattern of the grains:

1. The number of grains on each square doubles from the previous square.
2. The number of grains on the \(n\)-th square is \(2^{(n-1)}\).

For a chessboard with 64 squares:
- The number of grains on the 1st square is \(2^{(1-1)} = 2^0 = 1\).
- The number of grains on the 2nd square is \(2^{(2-1)} = 2^1 = 2\).
- The number of grains on the 3rd square is \(2^{(3-1)} = 2^2 = 4\).
- And so on, up to the 64th square.

To implement this in Python, we'll write two functions:
1. `square(number)`: This function will return the number of grains on the given square.
2. `total()`: This function will return the total number of grains on the chessboard.

We'll also include error handling to raise a `ValueError` if the input square is not between 1 and 64.

Here's the implementation:

```python
def square(number):
    if number < 1 or number > 64:
        raise ValueError("square must be between 1 and 64")
    return 2 ** (number - 1)

def total():
    return sum(2 ** (i - 1) for i in range(1, 65))

# Example usage:
print(square(1))  # 1 grain on the 1st square
print(square(2))  # 2 grains on the 2nd square
print(square(3))  # 4 grains on the 3rd square
print(square(64)) # 2^63 grains on the 64th square

print(total())    # Total grains on the chessboard
```

### Explanation

1. **`square(number)`**:
    - This function takes an integer `number` representing the square number.
    - It checks if the `number` is between 1 and 64, inclusive. If not, it raises a `ValueError` with a message.
    - If the `number` is valid, it calculates the number of grains on that square using the formula \(2^{(number - 1)}\).

2. **`total()`**:
    - This function calculates the total number of grains on the chessboard.
    - It uses a generator expression inside the `sum` function to iterate over the range 1 to 65 (since Python's `range` function is exclusive of the endpoint) and sums \(2^{(i - 1)}\) for each square `i`.

### Example Outputs

1. `square(1)` returns `1` because there is 1 grain on the 1st square.
2. `square(2)` returns `2` because there are 2 grains on the 2nd square.
3. `square(3)` returns `4` because there are 4 grains on the 3rd square.
4. `square(64)` returns `2^63` because that is the number of grains on the 64th square.
5. `total()` returns the sum of grains on all 64 squares.

By running this program, you can determine the number of grains on any given square and the total number of grains on the chessboard.


An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, the number 153 is an Armstrong number because \(1^3 + 5^3 + 3^3 = 153\).

To determine if a number is an Armstrong number, you can follow these steps:

1. Convert the number to a string to easily iterate over each digit.
2. Calculate the number of digits in the number.
3. Raise each digit to the power of the number of digits and sum these values.
4. Compare the sum to the original number.

Here is the Python implementation of the function `is_armstrong_number`:

```python
def is_armstrong_number(number):
    # Convert the number to a string to easily iterate over each digit
    digits = str(number)
    
    # Calculate the number of digits
    num_digits = len(digits)
    
    # Calculate the sum of each digit raised to the power of num_digits
    total = sum(int(digit) ** num_digits for digit in digits)
    
    # Compare the sum to the original number
    return total == number

# Example usage:
print(is_armstrong_number(153))  # True
print(is_armstrong_number(9474)) # True
print(is_armstrong_number(9475)) # False
```

### Explanation

1. **Conversion to String**:
    - The number is converted to a string to easily access each digit. This helps in iterating through each digit of the number.

2. **Number of Digits**:
    - `num_digits` is calculated using the length of the string representation of the number.

3. **Sum of Powers**:
    - A generator expression iterates through each digit, converts it back to an integer, raises it to the power of `num_digits`, and sums these values.

4. **Comparison**:
    - The sum is compared to the original number. If they are equal, the number is an Armstrong number.

### Example Outputs

1. **`is_armstrong_number(153)`**:
    - \(1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\) (True)

2. **`is_armstrong_number(9474)`**:
    - \(9^4 + 4^4 + 7^4 + 4^4 = 6561 + 256 + 2401 + 256 = 9474\) (True)

3. **`is_armstrong_number(9475)`**:
    - \(9^4 + 4^4 + 7^4 + 5^4 = 6561 + 256 + 2401 + 625 = 9843\) (False)

This implementation efficiently checks if a given number is an Armstrong number.

To solve the Collatz Conjecture problem, you need to create a function that calculates the number of steps required to reduce a given positive integer \( n \) to 1 following the rules of the conjecture:

1. If \( n \) is even, divide it by 2.
2. If \( n \) is odd, multiply it by 3 and add 1.

The function should also raise a `ValueError` if the input number is not a positive integer.

Here is the implementation:

```python
def steps(number):
    if number <= 0:
        raise ValueError("Only positive integers are allowed")
    
    count = 0
    while number != 1:
        if number % 2 == 0:
            number = number // 2
        else:
            number = 3 * number + 1
        count += 1
    return count

# Example usage:
print(steps(12))  # Output: 9
```

### Explanation

1. **Input Validation**:
    - The function checks if the input `number` is less than or equal to 0. If it is, a `ValueError` is raised with the message "Only positive integers are allowed".

2. **Step Calculation**:
    - Initialize a counter `count` to 0.
    - Use a `while` loop to repeatedly apply the Collatz Conjecture rules until `number` becomes 1.
    - If `number` is even, divide it by 2.
    - If `number` is odd, multiply it by 3 and add 1.
    - Increment the counter `count` in each iteration.

3. **Return the Step Count**:
    - Once the loop completes, return the value of `count`.

### Example

Starting with \( n = 12 \):
1. \( 12 \) is even, divide by 2: \( 12 / 2 = 6 \)
2. \( 6 \) is even, divide by 2: \( 6 / 2 = 3 \)
3. \( 3 \) is odd, multiply by 3 and add 1: \( 3 \times 3 + 1 = 10 \)
4. \( 10 \) is even, divide by 2: \( 10 / 2 = 5 \)
5. \( 5 \) is odd, multiply by 3 and add 1: \( 5 \times 3 + 1 = 16 \)
6. \( 16 \) is even, divide by 2: \( 16 / 2 = 8 \)
7. \( 8 \) is even, divide by 2: \( 8 / 2 = 4 \)
8. \( 4 \) is even, divide by 2: \( 4 / 2 = 2 \)
9. \( 2 \) is even, divide by 2: \( 2 / 2 = 1 \)

The total number of steps is 9, so `steps(12)` returns 9.

To determine Bob's responses based on the input, you can implement a function that handles different types of input and returns the appropriate response. Here's the implementation:

```python
def response(hey_bob):
    hey_bob = hey_bob.strip()  # Remove leading and trailing whitespace
    
    if not hey_bob:
        return "Fine. Be that way!"
    elif hey_bob.isupper():
        if hey_bob.endswith('?'):
            return "Calm down, I know what I'm doing!"
        else:
            return "Whoa, chill out!"
    elif hey_bob.endswith('?'):
        return "Sure."
    else:
        return "Whatever."

# Example usage:
print(response("How are you?"))  # "Sure."
print(response("WHAT'S UP?"))    # "Calm down, I know what I'm doing!"
print(response("HEY!"))          # "Whoa, chill out!"
print(response("  "))            # "Fine. Be that way!"
print(response("Hello there."))  # "Whatever."
```

### Explanation:

1. **Trim Whitespace**:
    - The `strip()` method is used to remove any leading or trailing whitespace from the input.

2. **Check for Silence**:
    - If the trimmed input is empty (`not hey_bob`), it means the input was either nothing or just whitespace, and Bob responds with "Fine. Be that way!".

3. **Check for Yelling**:
    - `isupper()` checks if all the letters in the input are uppercase, which indicates yelling.
    - If it is yelling and ends with a question mark (`endswith('?')`), Bob responds with "Calm down, I know what I'm doing!".
    - If it is just yelling without a question mark, Bob responds with "Whoa, chill out!".

4. **Check for Questions**:
    - If the input ends with a question mark (`endswith('?')`), Bob responds with "Sure.".

5. **Default Response**:
    - For any other type of input, Bob responds with "Whatever.".

### Example Test Cases

1. **Question**:
    - Input: "How are you?"
    - Output: "Sure."

2. **Yelling a Question**:
    - Input: "WHAT'S UP?"
    - Output: "Calm down, I know what I'm doing!"

3. **Yelling**:
    - Input: "HEY!"
    - Output: "Whoa, chill out!"

4. **Silence**:
    - Input: "  "
    - Output: "Fine. Be that way!"

5. **Other Statements**:
    - Input: "Hello there."
    - Output: "Whatever."

This function comprehensively handles the different scenarios and returns the correct response based on Bob's rules.

To solve the Raindrops problem, you need to convert a given number into a corresponding string based on its divisibility by 3, 5, and 7:

1. If the number is divisible by 3, add "Pling" to the result.
2. If the number is divisible by 5, add "Plang" to the result.
3. If the number is divisible by 7, add "Plong" to the result.
4. If the number is not divisible by any of these, return the number as a string.

Here's how you can implement the function in Python:

```python
def convert(number):
    result = ""
    
    if number % 3 == 0:
        result += "Pling"
    if number % 5 == 0:
        result += "Plang"
    if number % 7 == 0:
        result += "Plong"
    
    if result == "":
        result = str(number)
    
    return result

# Example usage:
print(convert(28))  # Output: "Plong"
print(convert(30))  # Output: "PlingPlang"
print(convert(34))  # Output: "34"
```

### Explanation

1. **Divisibility Checks**:
    - `number % 3 == 0`: Checks if the number is divisible by 3.
    - `number % 5 == 0`: Checks if the number is divisible by 5.
    - `number % 7 == 0`: Checks if the number is divisible by 7.

2. **Appending Results**:
    - If the number is divisible by 3, "Pling" is added to the result string.
    - If the number is divisible by 5, "Plang" is added to the result string.
    - If the number is divisible by 7, "Plong" is added to the result string.

3. **Returning the Result**:
    - If the result string is empty (i.e., the number is not divisible by 3, 5, or 7), convert the number to a string and set it as the result.
    - Return the final result string.

### Example Outputs

1. **convert(28)**:
    - 28 is divisible by 7 but not by 3 or 5, so the result is "Plong".

2. **convert(30)**:
    - 30 is divisible by 3 and 5 but not by 7, so the result is "PlingPlang".

3. **convert(34)**:
    - 34 is not divisible by 3, 5, or 7, so the result is "34".

This function efficiently checks the divisibility of the number and constructs the corresponding raindrop sounds or returns the number as a string if no conditions are met.


To solve the problem of calculating the points earned in a single toss of a Darts game based on where the dart lands, we need to determine the distance from the dart's landing point to the center of the target (0,0) and compare it against the radii of the different scoring circles.

Here's the breakdown of the steps:

1. Calculate the Euclidean distance from the dart's landing point (x, y) to the center of the target (0, 0).
2. Compare this distance to the radii of the circles:
   - Radius 1 unit: 10 points (inner circle)
   - Radius 5 units: 5 points (middle circle)
   - Radius 10 units: 1 point (outer circle)
   - Beyond 10 units: 0 points (outside the target)

The Euclidean distance \( d \) from the point \((x, y)\) to the center \((0, 0)\) is given by:
\[ d = \sqrt{x^2 + y^2} \]

Here is the implementation of the function in Python:

```python
import math

def score(x, y):
    # Calculate the distance from the point (x, y) to the origin (0, 0)
    distance = math.sqrt(x**2 + y**2)
    
    # Determine the score based on the distance
    if distance <= 1:
        return 10
    elif distance <= 5:
        return 5
    elif distance <= 10:
        return 1
    else:
        return 0

# Example usage:
print(score(0, 0))    # Output: 10 (bullseye)
print(score(2, 2))    # Output: 5 (middle circle)
print(score(8, 8))    # Output: 0 (outside target)
print(score(3, 4))    # Output: 5 (middle circle)
print(score(10, 0))   # Output: 1 (outer circle)
print(score(-1, -1))  # Output: 10 (bullseye)
```

### Explanation:

1. **Calculate Distance**:
   - Using the formula \( d = \sqrt{x^2 + y^2} \), we calculate the distance from the point \((x, y)\) to the origin \((0, 0)\).

2. **Determine Score**:
   - If the distance is less than or equal to 1 unit, the dart is in the inner circle, and the score is 10 points.
   - If the distance is less than or equal to 5 units but more than 1 unit, the dart is in the middle circle, and the score is 5 points.
   - If the distance is less than or equal to 10 units but more than 5 units, the dart is in the outer circle, and the score is 1 point.
   - If the distance is more than 10 units, the dart is outside the target, and the score is 0 points.

This function covers all the conditions specified and accurately calculates the points based on where the dart lands on the target.

To determine if a number is perfect, abundant, or deficient, you need to calculate its aliquot sum and then compare this sum to the number itself. Here’s how you can implement the classification scheme in Python:

1. **Perfect Number**: A number is perfect if it equals its aliquot sum.
2. **Abundant Number**: A number is abundant if it is less than its aliquot sum.
3. **Deficient Number**: A number is deficient if it is greater than its aliquot sum.

You will also need to handle the case where the input number is not a positive integer by raising a `ValueError`.

Here's the complete implementation:

```python
def classify(number):
    if number <= 0:
        raise ValueError("Classification is only possible for positive integers")
    
    aliquot_sum = sum(factor for factor in range(1, number) if number % factor == 0)
    
    if aliquot_sum == number:
        return "perfect"
    elif aliquot_sum > number:
        return "abundant"
    else:
        return "deficient"

# Example usage:
print(classify(6))    # Output: "perfect"
print(classify(12))   # Output: "abundant"
print(classify(8))    # Output: "deficient"
```

### Explanation

1. **Input Validation**:
    - The function first checks if the input number is less than or equal to zero. If so, it raises a `ValueError` with the message "Classification is only possible for positive integers".

2. **Calculate Aliquot Sum**:
    - The aliquot sum is calculated by summing all factors of the number that are less than the number itself. This is done using a generator expression inside the `sum` function.

3. **Classification**:
    - The function then compares the aliquot sum to the number:
      - If they are equal, the number is classified as "perfect".
      - If the aliquot sum is greater than the number, it is classified as "abundant".
      - If the aliquot sum is less than the number, it is classified as "deficient".

### Examples

1. **Perfect Number**:
    - \(6\) is a perfect number because \(1 + 2 + 3 = 6\).
    - `classify(6)` returns `"perfect"`.

2. **Abundant Number**:
    - \(12\) is an abundant number because \(1 + 2 + 3 + 4 + 6 = 16\).
    - `classify(12)` returns `"abundant"`.

3. **Deficient Number**:
    - \(8\) is a deficient number because \(1 + 2 + 4 = 7\).
    - `classify(8)` returns `"deficient"`.

### Error Handling

If you try to classify a non-positive integer, the function will raise an error:
- `classify(-5)` raises `ValueError: Classification is only possible for positive integers`.
- `classify(0)` raises `ValueError: Classification is only possible for positive integers`.

This implementation follows Nicomachus' classification scheme and correctly handles the exceptions for invalid inputs.

To implement a function that reverses a given string, you can use several methods in Python. One of the simplest and most Pythonic ways is to use slicing.

Here is the implementation of the `reverse` function:

### Implementation

```python
def reverse(text):
    return text[::-1]

# Example usage:
print(reverse("hello"))  # Output: "olleh"
print(reverse("world"))  # Output: "dlrow"
```

### Explanation

1. **Slicing**:
    - The slicing notation `text[::-1]` is used to reverse the string.
    - `text[start:stop:step]` is the general form of slicing, and `step` being `-1` means the string is read from the end towards the beginning, effectively reversing it.

### Alternative Methods

You can also reverse a string using other methods such as a loop or the `reversed()` function combined with `join()`:

#### Using a Loop

```python
def reverse(text):
    reversed_text = ""
    for char in text:
        reversed_text = char + reversed_text
    return reversed_text

# Example usage:
print(reverse("hello"))  # Output: "olleh"
```

#### Using `reversed()` and `join()`

```python
def reverse(text):
    return ''.join(reversed(text))

# Example usage:
print(reverse("hello"))  # Output: "olleh"
```

### Explanation of Alternative Methods

1. **Using a Loop**:
    - Initialize an empty string `reversed_text`.
    - Iterate over each character in the input string `text`.
    - Prepend each character to `reversed_text` to build the reversed string.

2. **Using `reversed()` and `join()`**:
    - `reversed(text)` returns an iterator that accesses the given string in reverse order.
    - `''.join(reversed(text))` joins the characters returned by the iterator into a new reversed string.

These methods provide flexibility in case you need to reverse a string using different approaches based on specific requirements or constraints in your project.


To determine if a sentence is a pangram, you need to check if it contains every letter of the English alphabet at least once. The solution should be case insensitive, meaning it should treat uppercase and lowercase letters as the same.

Here's how you can implement the function `is_pangram`:

### Implementation

```python
import string

def is_pangram(sentence):
    # Create a set of all lowercase letters in the English alphabet
    alphabet = set(string.ascii_lowercase)
    
    # Convert the sentence to lowercase and create a set of the letters in the sentence
    sentence_letters = set(sentence.lower())
    
    # Check if all letters in the alphabet are in the sentence
    return alphabet.issubset(sentence_letters)

# Example usage:
print(is_pangram("The quick brown fox jumps over the lazy dog"))  # Output: True
print(is_pangram("Hello, World!"))                               # Output: False
```

### Explanation

1. **Import `string` module**:
    - The `string` module provides a set of useful constants and functions. In this case, `string.ascii_lowercase` gives us all lowercase letters of the English alphabet.

2. **Create a Set of the Alphabet**:
    - `alphabet = set(string.ascii_lowercase)` creates a set containing all the letters from 'a' to 'z'.

3. **Convert Sentence to Lowercase and Create a Set**:
    - `sentence.lower()` converts the entire sentence to lowercase to ensure the check is case insensitive.
    - `sentence_letters = set(sentence.lower())` creates a set of the letters present in the sentence.

4. **Check if All Letters are Present**:
    - `alphabet.issubset(sentence_letters)` checks if all elements in `alphabet` are contained in `sentence_letters`. If true, the sentence is a pangram; otherwise, it is not.

### Example Outputs

1. **is_pangram("The quick brown fox jumps over the lazy dog")**:
    - This sentence contains all letters from 'a' to 'z', so the function returns `True`.

2. **is_pangram("Hello, World!")**:
    - This sentence does not contain all letters from 'a' to 'z', so the function returns `False`.

### Testing

To ensure the function works correctly, you can run the following tests:

```python
assert is_pangram("The quick brown fox jumps over the lazy dog") == True
assert is_pangram("Pack my box with five dozen liquor jugs") == True
assert is_pangram("Sphinx of black quartz, judge my vow") == True
assert is_pangram("Hello, World!") == False
assert is_pangram("A quick movement of the enemy will jeopardize five gunboats") == False
```

These tests cover various cases, including known pangrams and sentences that do not include every letter of the alphabet. By running these tests, you can verify that your implementation is correct.


An isogram is a word or phrase in which no letter occurs more than once. To determine if a string is an isogram, we need to check if all the letters in the string are unique. The function should ignore case and non-letter characters.

Here's how you can implement the function `is_isogram`:

### Implementation

```python
def is_isogram(string):
    # Convert the string to lowercase to ensure case insensitivity
    string = string.lower()
    
    # Create an empty set to keep track of the letters we've seen
    seen_letters = set()
    
    for char in string:
        # Only consider alphabetic characters
        if char.isalpha():
            if char in seen_letters:
                return False
            seen_letters.add(char)
    
    return True

# Example usage:
print(is_isogram("Dermatoglyphics"))  # Output: True
print(is_isogram("aba"))              # Output: False
print(is_isogram("moOse"))            # Output: False
```

### Explanation

1. **Convert to Lowercase**:
    - `string = string.lower()` converts the entire string to lowercase to ensure the check is case insensitive.

2. **Create a Set for Seen Letters**:
    - `seen_letters = set()` initializes an empty set to keep track of letters we have encountered.

3. **Iterate Through the String**:
    - The `for` loop iterates through each character in the string.
    - `char.isalpha()` checks if the character is a letter. If it is not a letter (e.g., a space, punctuation), it is ignored.
    - If the letter has already been seen (`if char in seen_letters`), the function returns `False` because it means the letter is repeated.
    - If the letter is not in the set, it is added to the set (`seen_letters.add(char)`).

4. **Return True if No Repeats**:
    - If the loop completes without finding any repeated letters, the function returns `True`, indicating the string is an isogram.

### Example Outputs

1. **is_isogram("Dermatoglyphics")**:
    - This word has all unique letters, so the function returns `True`.

2. **is_isogram("aba")**:
    - The letter 'a' is repeated, so the function returns `False`.

3. **is_isogram("moOse")**:
    - The letter 'o' is repeated (case insensitive), so the function returns `False`.

### Testing

To ensure the function works correctly, you can run the following tests:

```python
assert is_isogram("Dermatoglyphics") == True
assert is_isogram("isogram") == True
assert is_isogram("aba") == False
assert is_isogram("moOse") == False
assert is_isogram("isIsogram") == False
assert is_isogram("") == True  # An empty string is considered an isogram
```

These tests cover various cases, including known isograms and non-isograms, case insensitivity, and handling of non-letter characters. By running these tests, you can verify that your implementation is correct.

To determine if an ISBN-10 is valid, we need to follow the specific rules for ISBN-10 validation:

1. An ISBN-10 is composed of 9 digits followed by a check character (which can be a digit or 'X').
2. The check character 'X' represents the value 10.
3. The ISBN can be with or without hyphens.

The formula for validation is:
\[ (d₁ * 10 + d₂ * 9 + d₃ * 8 + d₄ * 7 + d₅ * 6 + d₆ * 5 + d₇ * 4 + d₈ * 3 + d₉ * 2 + d₁₀ * 1) \mod 11 == 0 \]

If the result is 0, the ISBN-10 is valid.

Here’s how to implement this in Python:

### Implementation

```python
def is_valid(isbn):
    # Remove hyphens
    isbn = isbn.replace("-", "")
    
    # Check if length is exactly 10
    if len(isbn) != 10:
        return False
    
    # Initialize sum for the formula
    total = 0
    
    for i in range(10):
        if isbn[i] == 'X':
            if i != 9:  # 'X' can only be the last character
                return False
            digit = 10
        elif isbn[i].isdigit():
            digit = int(isbn[i])
        else:
            return False
        
        total += digit * (10 - i)
    
    # Check if the total modulo 11 is 0
    return total % 11 == 0

# Example usage:
print(is_valid("3-598-21508-8"))  # Output: True
print(is_valid("3-598-21507-X"))  # Output: True
print(is_valid("3-598-21507-A"))  # Output: False
print(is_valid("3-598-21507"))    # Output: False
```

### Explanation

1. **Remove Hyphens**:
    - `isbn = isbn.replace("-", "")` removes any hyphens from the ISBN.

2. **Check Length**:
    - `if len(isbn) != 10` checks if the length of the ISBN is exactly 10 characters after removing hyphens. If not, it returns `False`.

3. **Calculate the Total**:
    - Initialize `total` to 0.
    - Iterate through each character in the ISBN:
        - If the character is 'X', it must be the last character (`i != 9` ensures 'X' can only be at the last position). If this is the case, set `digit` to 10.
        - If the character is a digit, convert it to an integer.
        - If the character is neither a digit nor 'X', return `False`.
        - Add the product of `digit` and `(10 - i)` to `total`.

4. **Validate the ISBN**:
    - `return total % 11 == 0` checks if the total modulo 11 is 0. If true, the ISBN is valid.

### Examples

1. **is_valid("3-598-21508-8")**:
    - The ISBN is valid because the total calculated using the formula modulo 11 is 0.

2. **is_valid("3-598-21507-X")**:
    - The ISBN is valid because the 'X' is correctly handled as 10, and the total modulo 11 is 0.

3. **is_valid("3-598-21507-A")**:
    - The ISBN is invalid because 'A' is not a valid character.

4. **is_valid("3-598-21507")**:
    - The ISBN is invalid because it does not have exactly 10 characters.

This function comprehensively checks the validity of an ISBN-10 according to the rules specified.

To implement a rotational cipher (also known as a Caesar cipher), we need to shift each letter in the input text by a specified key while maintaining the original formatting, including spaces and punctuation.

Here's a Python function that implements the rotational cipher:

### Implementation

```python
def rotate(text, key):
    result = []

    for char in text:
        if char.isalpha():  # Check if the character is a letter
            shift = ord('A') if char.isupper() else ord('a')
            new_char = chr((ord(char) - shift + key) % 26 + shift)
            result.append(new_char)
        else:
            result.append(char)  # Non-letter characters are added unchanged

    return ''.join(result)

# Example usage:
print(rotate("The quick brown fox jumps over the lazy dog!", 13))  # Output: "Gur dhvpx oebja sbk whzcf bire gur ynml qbt!"
print(rotate("Hello, World!", 5))  # Output: "Mjqqt, Btwqi!"
print(rotate("Rotate by 13 positions!", 13))  # Output: "Ebgngr ol 13 cbfvgvbaf!"
```

### Explanation

1. **Iterate Through Each Character**:
    - The function iterates through each character in the input text.
    - If the character is an alphabet letter (checked using `char.isalpha()`), it is shifted.
    - Non-letter characters (e.g., spaces, punctuation) are appended to the result list unchanged.

2. **Determine the Shift**:
    - For uppercase letters, `shift` is set to `ord('A')`.
    - For lowercase letters, `shift` is set to `ord('a')`.

3. **Calculate the New Character**:
    - `ord(char) - shift` gives the position of the character in the alphabet (0-25).
    - Adding `key` shifts the character by the specified amount.
    - The modulo operation `% 26` ensures the shift wraps around if it goes past 'Z' or 'z'.
    - `+ shift` converts the position back to the appropriate ASCII code for either uppercase or lowercase.
    - `chr()` converts the ASCII code back to a character.

4. **Join the Result**:
    - The list `result` is joined into a single string using `''.join(result)`.

### Examples

1. **rotate("The quick brown fox jumps over the lazy dog!", 13)**:
    - Each letter is shifted by 13 positions.
    - Output: "Gur dhvpx oebja sbk whzcf bire gur ynml qbt!"

2. **rotate("Hello, World!", 5)**:
    - Each letter is shifted by 5 positions.
    - Output: "Mjqqt, Btwqi!"

3. **rotate("Rotate by 13 positions!", 13)**:
    - Each letter is shifted by 13 positions.
    - Output: "Ebgngr ol 13 cbfvgvbaf!"

This implementation maintains the original formatting and correctly handles both uppercase and lowercase letters. The function can be easily tested with various inputs to ensure its correctness.

To transcribe a DNA strand into its RNA complement, you need to replace each nucleotide in the DNA sequence with its RNA complement according to the following rules:

- **G** is replaced with **C**
- **C** is replaced with **G**
- **T** is replaced with **A**
- **A** is replaced with **U**

Here's how you can implement the `to_rna` function in Python:

### Implementation

```python
def to_rna(dna_strand):
    # Create a dictionary to map DNA nucleotides to RNA complements
    complement = {'G': 'C', 'C': 'G', 'T': 'A', 'A': 'U'}
    
    # Use a list comprehension to generate the RNA strand
    rna_strand = [complement[nucleotide] for nucleotide in dna_strand]
    
    # Join the list into a string and return it
    return ''.join(rna_strand)

# Example usage:
print(to_rna("GCTA"))  # Output: "CGAU"
print(to_rna("CGTAGC"))  # Output: "GCAUCG"
```

### Explanation

1. **Complement Dictionary**:
    - The dictionary `complement` maps each DNA nucleotide to its corresponding RNA complement.

2. **List Comprehension**:
    - The list comprehension iterates over each nucleotide in the `dna_strand` and replaces it with its RNA complement using the `complement` dictionary.

3. **Join the List**:
    - The `join` method is used to combine the list of RNA nucleotides into a single string, which is then returned.

### Example Outputs

1. **to_rna("GCTA")**:
    - DNA strand: "GCTA"
    - RNA complement: "CGAU"
    - Output: "CGAU"

2. **to_rna("CGTAGC")**:
    - DNA strand: "CGTAGC"
    - RNA complement: "GCAUCG"
    - Output: "GCAUCG"

### Testing

To ensure the function works correctly, you can run the following tests:

```python
assert to_rna("GCTA") == "CGAU"
assert to_rna("CGTAGC") == "GCAUCG"
assert to_rna("TTTT") == "AAAA"
assert to_rna("AAGGCC") == "UUCCGG"
assert to_rna("") == ""  # Empty DNA strand should return an empty RNA strand
```

These tests cover various cases, including different DNA sequences and an empty DNA strand. By running these tests, you can verify that your implementation is correct.

To implement the function `answer` correctly handling errors and parsing math word problems, we need to distinguish between syntax errors and unknown operations. Here's the final version of the function:

### Updated Implementation

```python
def answer(question):
    import re

    # Define the operations we can handle
    operations = {
        'plus': '+',
        'minus': '-',
        'multiplied by': '*',
        'divided by': '/'
    }

    # Check if the question is valid
    if not question.startswith("What is ") or not question.endswith("?"):
        raise ValueError("syntax error")

    # Remove the leading 'What is ' and trailing '?' and strip any extra spaces
    query = question[8:-1].strip()

    # Tokenize the query
    tokens = re.split(r'(\d+|-\d+|\bplus\b|\bminus\b|\bmultiplied by\b|\bdivided by\b)', query)
    tokens = [token.strip() for token in tokens if token.strip()]

    # Check for unsupported operations and malformed questions
    if not tokens:
        raise ValueError("syntax error")

    # Convert tokens into a list of numbers and operations
    parsed_tokens = []
    for token in tokens:
        if token.lstrip('-').isdigit():
            parsed_tokens.append(int(token))
        elif token in operations:
            parsed_tokens.append(operations[token])
        else:
            raise ValueError("unknown operation")

    # Ensure the question has a valid sequence of number-operator-number
    if len(parsed_tokens) % 2 == 0:
        raise ValueError("syntax error")

    # Evaluate the expression from left to right
    result = parsed_tokens[0]
    i = 1
    while i < len(parsed_tokens):
        operation = parsed_tokens[i]
        number = parsed_tokens[i + 1]
        if operation == '+':
            result += number
        elif operation == '-':
            result -= number
        elif operation == '*':
            result *= number
        elif operation == '/':
            result //= number
        i += 2

    return result

# Example usage:
print(answer("What is 5?"))  # Output: 5
print(answer("What is 5 plus 13?"))  # Output: 18
print(answer("What is 7 minus 5?"))  # Output: 2
print(answer("What is 6 multiplied by 4?"))  # Output: 24
print(answer("What is 25 divided by 5?"))  # Output: 5
print(answer("What is 5 plus 13 plus 6?"))  # Output: 24
print(answer("What is 3 plus 2 multiplied by 3?"))  # Output: 15
print(answer("What is -1 plus -10?"))  # Output: -11
try:
    answer("What is 52 cubed?")
except ValueError as e:
    print(e)  # Output: "unknown operation"
try:
    answer("Who is the President of the United States?")
except ValueError as e:
    print(e)  # Output: "unknown operation"
try:
    answer("What is 1 plus plus 2?")
except ValueError as e:
    print(e)  # Output: "syntax error"
```

### Explanation

1. **Format Check**:
   - The function checks if the input question starts with "What is " and ends with "?".
   - If not, it raises a `ValueError` with the message "syntax error".

2. **Tokenization**:
   - The question is stripped of the leading "What is " and the trailing "?".
   - The remaining string is split into tokens using a regular expression that matches numbers, negative numbers, and operation words.

3. **Parsing Tokens**:
   - Each token is checked to see if it is a number or an operation.
   - Numbers are converted to integers and operations are mapped to their corresponding symbols.
   - If an unsupported operation or non-math question is encountered, a `ValueError` is raised with the message "unknown operation".

4. **Validation of Sequence**:
   - Ensure the sequence of parsed tokens is valid. If the length of `parsed_tokens` is even, it indicates an invalid sequence, raising a `ValueError` with the message "syntax error".

5. **Evaluation**:
   - The parsed tokens are processed from left to right.
   - The result is computed by applying each operation to the current result and the next number in the sequence.

6. **Error Handling**:
   - The function raises a `ValueError` with appropriate messages for syntax errors and unknown operations.

### Testing

To ensure the function works correctly, you can run the following tests:

```python
import unittest

class TestMathWordProblems(unittest.TestCase):
    def test_addition(self):
        self.assertEqual(answer("What is 5 plus 13?"), 18)
    
    def test_subtraction(self):
        self.assertEqual(answer("What is 7 minus 5?"), 2)
    
    def test_multiplication(self):
        self.assertEqual(answer("What is 6 multiplied by 4?"), 24)
    
    def test_division(self):
        self.assertEqual(answer("What is 25 divided by 5?"), 5)
    
    def test_multiple_operations(self):
        self.assertEqual(answer("What is 5 plus 13 plus 6?"), 24)
        self.assertEqual(answer("What is 3 plus 2 multiplied by 3?"), 15)
    
    def test_negative_numbers(self):
        self.assertEqual(answer("What is -1 plus -10?"), -11)
    
    def test_unknown_operation(self):
        with self.assertRaises(ValueError) as err:
            answer("What is 52 cubed?")
        self.assertEqual(str(err.exception), "unknown operation")
    
    def test_non_math_question(self):
        with self.assertRaises(ValueError) as err:
            answer("Who is the President of the United States?")
        self.assertEqual(str(err.exception), "unknown operation")
    
    def test_syntax_error(self):
        with self.assertRaises(ValueError) as err:
            answer("What is 1 plus plus 2?")
        self.assertEqual(str(err.exception), "syntax error")

if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)
```

These tests cover various cases including basic operations, multiple operations, negative numbers, unsupported operations, non-math questions, and malformed questions. By running these tests, you can verify that your implementation is correct.

To create a program that helps with the resistor color codes, we need two functions:

1. `color_code(color)`: This function will take a color as input and return its corresponding numerical value.
2. `colors()`: This function will return a list of all the color names in the correct order.

Here's how you can implement these functions in Python:

### Implementation

```python
# Define the color mapping according to the resistor color codes
COLOR_CODES = ["black", "brown", "red", "orange", "yellow", "green", "blue", "violet", "grey", "white"]

def color_code(color):
    """Return the numerical value associated with a particular color band."""
    if color not in COLOR_CODES:
        raise ValueError(f"Invalid color: {color}")
    return COLOR_CODES.index(color)

def colors():
    """Return a list of all colors."""
    return COLOR_CODES

# Example usage:
print(color_code("red"))      # Output: 2
print(color_code("green"))    # Output: 5
print(colors())               # Output: ['black', 'brown', 'red', 'orange', 'yellow', 'green', 'blue', 'violet', 'grey', 'white']
```

### Explanation

1. **Color Mapping**:
    - We define a list `COLOR_CODES` that contains the colors in the order specified. The index of each color in this list corresponds to its numerical value.

2. **`color_code(color)` Function**:
    - This function takes a color as an argument and returns its index in the `COLOR_CODES` list. This index is the numerical value of the color.
    - If the color is not found in the list, it raises a `ValueError`.

3. **`colors()` Function**:
    - This function simply returns the `COLOR_CODES` list.

### Usage

1. **`color_code("red")`**:
    - The function returns the index of "red" in the `COLOR_CODES` list, which is 2.

2. **`color_code("green")`**:
    - The function returns the index of "green" in the `COLOR_CODES` list, which is 5.

3. **`colors()`**:
    - The function returns the list of all color names in the correct order: `['black', 'brown', 'red', 'orange', 'yellow', 'green', 'blue', 'violet', 'grey', 'white']`.

This implementation provides a straightforward and efficient way to look up the numerical values of resistor color bands and list all the band colors.

To create a program that takes color names as input and outputs a two-digit number based on the first two color bands of a resistor, we can map each color to its corresponding value and then concatenate the values of the first two colors.

Here's the implementation of the `value` function:

### Implementation

```python
# Define the color mapping according to the resistor color codes
COLOR_CODES = ["black", "brown", "red", "orange", "yellow", "green", "blue", "violet", "grey", "white"]

def value(colors):
    """Return the resistance value based on the first two color bands."""
    if len(colors) < 2:
        raise ValueError("At least two colors are required.")
    
    first_color_value = COLOR_CODES.index(colors[0])
    second_color_value = COLOR_CODES.index(colors[1])
    
    return first_color_value * 10 + second_color_value

# Example usage:
print(value(["brown", "green"]))       # Output: 15
print(value(["brown", "green", "violet"]))  # Output: 15
print(value(["red", "blue"]))          # Output: 26
print(value(["yellow", "violet"]))     # Output: 47
```

### Explanation

1. **Color Mapping**:
    - We define a list `COLOR_CODES` that contains the colors in the order specified. The index of each color in this list corresponds to its numerical value.

2. **`value(colors)` Function**:
    - This function takes a list of color names as input.
    - It checks if there are at least two colors provided. If not, it raises a `ValueError`.
    - It retrieves the numerical values of the first two colors using the `COLOR_CODES.index()` method.
    - It computes the resistance value by multiplying the value of the first color by 10 and adding the value of the second color.

### Usage

1. **`value(["brown", "green"])`**:
    - "brown" corresponds to 1, and "green" corresponds to 5.
    - The function returns `1 * 10 + 5`, which is `15`.

2. **`value(["brown", "green", "violet"])`**:
    - The third color is ignored.
    - The function returns `1 * 10 + 5`, which is `15`.

3. **`value(["red", "blue"])`**:
    - "red" corresponds to 2, and "blue" corresponds to 6.
    - The function returns `2 * 10 + 6`, which is `26`.

4. **`value(["yellow", "violet"])`**:
    - "yellow" corresponds to 4, and "violet" corresponds to 7.
    - The function returns `4 * 10 + 7`, which is `47`.

This implementation efficiently converts the first two color bands of a resistor into their corresponding resistance value.

To create a program that takes three resistor color bands as input and outputs the correct value in ohms, we need to follow these steps:

1. **Map each color to its corresponding value**.
2. **Calculate the main value from the first two colors**.
3. **Calculate the number of zeros from the third color**.
4. **Format the output correctly, using metric prefixes for larger values**.

Here's how we can implement this in Python:

### Implementation

```python
# Define the color mapping according to the resistor color codes
COLOR_CODES = {
    "black": 0,
    "brown": 1,
    "red": 2,
    "orange": 3,
    "yellow": 4,
    "green": 5,
    "blue": 6,
    "violet": 7,
    "grey": 8,
    "white": 9
}

def label(colors):
    """Return the resistance value in ohms based on the color bands."""
    if len(colors) != 3:
        raise ValueError("Exactly three colors are required.")
    
    first_value = COLOR_CODES[colors[0]]
    second_value = COLOR_CODES[colors[1]]
    multiplier = COLOR_CODES[colors[2]]
    
    # Calculate the resistance value
    resistance_value = (first_value * 10 + second_value) * (10 ** multiplier)
    
    # Determine the appropriate unit
    if resistance_value >= 1_000_000:
        return f"{resistance_value / 1_000_000} megaohms"
    elif resistance_value >= 1_000:
        return f"{resistance_value / 1_000} kiloohms"
    else:
        return f"{resistance_value} ohms"

# Example usage:
print(label(["orange", "orange", "black"]))  # Output: "33 ohms"
print(label(["orange", "orange", "red"]))    # Output: "3300 ohms"
print(label(["orange", "orange", "orange"])) # Output: "33 kiloohms"
print(label(["orange", "orange", "yellow"])) # Output: "330000 ohms"
```

### Explanation

1. **Color Mapping**:
    - The `COLOR_CODES` dictionary maps each color to its corresponding value.

2. **Extract Values from Colors**:
    - The first and second colors are used to form the main value.
    - The third color is used to determine the multiplier (number of zeros).

3. **Calculate Resistance Value**:
    - The resistance value is calculated by combining the first two values and multiplying by \(10^{\text{multiplier}}\).

4. **Format the Output**:
    - If the resistance value is \( \geq 1,000,000 \), it is converted to megaohms.
    - If the resistance value is \( \geq 1,000 \), it is converted to kiloohms.
    - Otherwise, it is kept in ohms.

### Usage

1. **`label(["orange", "orange", "black"])`**:
    - The first two bands are "orange" (3) and "orange" (3), forming 33.
    - The third band is "black" (0), so no zeros are added.
    - The output is "33 ohms".

2. **`label(["orange", "orange", "red"])`**:
    - The first two bands form 33.
    - The third band is "red" (2), so 2 zeros are added (3300).
    - The output is "3300 ohms".

3. **`label(["orange", "orange", "orange"])`**:
    - The first two bands form 33.
    - The third band is "orange" (3), so 3 zeros are added (33000).
    - The output is "33 kiloohms".

4. **`label(["orange", "orange", "yellow"])`**:
    - The first two bands form 33.
    - The third band is "yellow" (4), so 4 zeros are added (330000).
    - The output is "330 kiloohms".

This implementation effectively translates the color bands into the correct resistance value in ohms and formats it appropriately.

# Define the color mappings for resistance values and tolerance values
COLOR_CODES = {
    "black": 0,
    "brown": 1,
    "red": 2,
    "orange": 3,
    "yellow": 4,
    "green": 5,
    "blue": 6,
    "violet": 7,
    "grey": 8,
    "white": 9
}

TOLERANCE_CODES = {
    "grey": "±0.05%",
    "violet": "±0.1%",
    "blue": "±0.25%",
    "green": "±0.5%",
    "brown": "±1%",
    "red": "±2%",
    "gold": "±5%",
    "silver": "±10%"
}

def resistor_label(colors):
    # Handle the one-band resistor (special case)
    if len(colors) == 1 and colors[0] == "black":
        return "0 ohms"

    # Extract values based on the number of color bands
    if len(colors) == 4:
        # Four-band resistor
        first_digit = COLOR_CODES[colors[0]]
        second_digit = COLOR_CODES[colors[1]]
        multiplier = 10 ** COLOR_CODES[colors[2]]
        tolerance = TOLERANCE_CODES[colors[3]]
        resistance_value = (first_digit * 10 + second_digit) * multiplier
    elif len(colors) == 5:
        # Five-band resistor
        first_digit = COLOR_CODES[colors[0]]
        second_digit = COLOR_CODES[colors[1]]
        third_digit = COLOR_CODES[colors[2]]
        multiplier = 10 ** COLOR_CODES[colors[3]]
        tolerance = TOLERANCE_CODES[colors[4]]
        resistance_value = (first_digit * 100 + second_digit * 10 + third_digit) * multiplier
    else:
        raise ValueError("Invalid number of color bands. Must be 1, 4, or 5.")

    # Determine the unit (ohms, kiloohms, megaohms)
    if resistance_value >= 1_000_000:
        resistance_value_str = f"{resistance_value / 1_000_000} megaohms"
    elif resistance_value >= 1_000:
        resistance_value_str = f"{resistance_value / 1_000} kiloohms"
    else:
        resistance_value_str = f"{resistance_value} ohms"

    return f"{resistance_value_str} {tolerance}"

# Example usage:
print(resistor_label(["orange", "orange", "black", "green"]))  # Output: "33 ohms ±0.5%"
print(resistor_label(["orange", "orange", "red", "grey"]))     # Output: "3300 ohms ±0.05%"
print(resistor_label(["orange", "orange", "orange", "grey"]))  # Output: "33 kiloohms ±0.05%"
print(resistor_label(["orange", "orange", "orange", "black", "green"]))  # Output: "333 ohms ±0.5%"
print(resistor_label(["orange", "red", "orange", "blue", "violet"]))     # Output: "323 megaohms ±0.1%"

To implement the function `commands` that converts a number between 1 and 31 into a sequence of secret handshake actions, we will:

1. Convert the number into its 5-bit binary representation.
2. Determine the actions based on the binary digits.
3. Reverse the order of actions if the leftmost bit (representing 16) is set to 1.

Here’s how to implement this in Python:

### Implementation

```python
def commands(number):
    actions = ['wink', 'double blink', 'close your eyes', 'jump']
    result = []

    # Check the bits from right to left (1, 2, 4, 8, 16)
    for i in range(4):
        if number & (1 << i):
            result.append(actions[i])
    
    # Check the 5th bit (16) for reversing the order
    if number & (1 << 4):
        result.reverse()
    
    return result

# Example usage:
print(commands(9))    # Output: ['wink', 'jump']
print(commands(26))   # Output: ['jump', 'double blink']
print(commands(31))   # Output: ['wink', 'double blink', 'close your eyes', 'jump']
print(commands(16))   # Output: []
```

### Explanation

1. **Actions List**:
    - We define the list `actions` to map the actions to their corresponding binary positions.

2. **Iterate Over Bits**:
    - We use a for loop to check each of the first 4 bits (1, 2, 4, and 8). 
    - For each bit that is set to 1, we add the corresponding action to the `result` list.

3. **Check the Reverse Bit**:
    - We check the 5th bit (16) to determine if we need to reverse the order of actions in the `result` list.
    - If the 5th bit is set, we reverse the `result` list.

4. **Return the Result**:
    - Finally, we return the `result` list which contains the sequence of actions.

### Example Outputs

1. **commands(9)**:
    - Binary: 1001
    - Actions: ['wink', 'jump']
    - Output: `['wink', 'jump']`

2. **commands(26)**:
    - Binary: 11010
    - Actions before reverse: ['double blink', 'jump']
    - Actions after reverse: ['jump', 'double blink']
    - Output: `['jump', 'double blink']`

3. **commands(31)**:
    - Binary: 11111
    - Actions before reverse: ['wink', 'double blink', 'close your eyes', 'jump']
    - Actions after reverse: ['jump', 'close your eyes', 'double blink', 'wink']
    - Output: `['jump', 'close your eyes', 'double blink', 'wink']`

4. **commands(16)**:
    - Binary: 10000
    - No actions as the first 4 bits are 0.
    - Output: `[]`

This implementation covers the requirements of converting a number into the corresponding sequence of handshake actions based on its binary representation, including reversing the sequence if required.

def find_anagrams(word, candidates):
    # Helper function to normalize a word (convert to lowercase and sort the letters)
    def normalize(w):
        return ''.join(sorted(w.lower()))

    # Normalize the target word
    normalized_word = normalize(word)

    # Find anagrams by comparing normalized forms
    anagrams = [candidate for candidate in candidates
                if candidate.lower() != word.lower() and normalize(candidate) == normalized_word]

    return anagrams

# Example usage:
print(find_anagrams("stone", ["stone", "tones", "banana", "tons", "notes", "Seton"]))  # Output: ['tones', 'notes', 'Seton']
print(find_anagrams("post", ["stop", "tops", "spot", "opts", "pots"]))                # Output: ['stop', 'tops', 'spot', 'opts', 'pots']
print(find_anagrams("listen", ["enlist", "google", "inlets", "banana"]))              # Output: ['enlist', 'inlets']


def recite(start_verse, end_verse):
    verses = [
        "This is the house that Jack built.",
        "This is the malt that lay in the house that Jack built.",
        "This is the rat that ate the malt that lay in the house that Jack built.",
        "This is the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the farmer sowing his corn that kept the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built.",
        "This is the horse and the hound and the horn that belonged to the farmer sowing his corn that kept the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built."
    ]

    return '\n\n'.join(verses[start_verse - 1:end_verse])

# Example usage:
print(recite(1, 3))

def distance(strand_a, strand_b):
    if len(strand_a) != len(strand_b):
        raise ValueError("Strands must be of equal length")
    
    hamming_distance = 0
    for a, b in zip(strand_a, strand_b):
        if a != b:
            hamming_distance += 1
            
    return hamming_distance

# Example usage:
strand_a = "GAGCCTACTAACGGGAT"
strand_b = "CATCGTAATGACGGCCT"
print(distance(strand_a, strand_b))  # Output: 7


To solve the problem of flattening a nested list and removing `nil`/`null` values, we need a function that can recursively traverse the nested structure and collect all non-`None` values into a single flattened list.

Here's the implementation of the `flatten` function in Python:

### Implementation

```python
def flatten(iterable):
    flattened_list = []

    for item in iterable:
        if isinstance(item, list):
            flattened_list.extend(flatten(item))
        elif item is not None:
            flattened_list.append(item)

    return flattened_list

# Example usage:
input_list = [1, [2, 3, None, 4], [None], 5]
output_list = flatten(input_list)
print(output_list)  # Output: [1, 2, 3, 4, 5]
```

### Explanation

1. **Initialization**:
   - We start with an empty list `flattened_list` to collect the non-`None` values.

2. **Iterate Over Items**:
   - For each item in the input iterable:
     - If the item is a list, we recursively call `flatten` on the item and extend the `flattened_list` with the result.
     - If the item is not `None`, we append it to the `flattened_list`.

3. **Return the Flattened List**:
   - Finally, we return the `flattened_list`.

### Example

1. **Example Usage**:
   - Given the input list `[1, [2, 3, None, 4], [None], 5]`, the function returns `[1, 2, 3, 4, 5]`.

### Testing

To ensure the function works correctly, you can test it with various nested structures and `None` values:

```python
# Test cases
print(flatten([1, [2, 3, None, 4], [None], 5]))        # Output: [1, 2, 3, 4, 5]
print(flatten([[1, 2, [3]], 4, [[5, None], 6], None])) # Output: [1, 2, 3, 4, 5, 6]
print(flatten([None, [None, [None]]]))                # Output: []
print(flatten([1, [2, [3, [4, [5]]]]]))               # Output: [1, 2, 3, 4, 5]
print(flatten([]))                                    # Output: []
```

These tests cover various scenarios, including deeply nested structures, lists with only `None` values, and empty lists, ensuring that the function behaves as expected in all cases.

def append(list1, list2):
    result = list1[:]
    for item in list2:
        result.append(item)
    return result

def concat(lists):
    result = []
    for lst in lists:
        result = append(result, lst)
    return result

def filter(function, lst):
    result = []
    for item in lst:
        if function(item):
            result.append(item)
    return result

def length(lst):
    count = 0
    for _ in lst:
        count += 1
    return count

def map(function, lst):
    result = []
    for item in lst:
        result.append(function(item))
    return result

def foldl(function, lst, initial):
    accumulator = initial
    for item in lst:
        accumulator = function(accumulator, item)
    return accumulator

def foldr(function, lst, initial):
    accumulator = initial
    for item in reverse(lst):
        accumulator = function(item, accumulator)
    return accumulator

def reverse(lst):
    result = []
    for item in lst:
        result.insert(0, item)
    return result

# Example usage:
print(append([1, 2], [3, 4]))          # Output: [1, 2, 3, 4]
print(concat([[1, 2], [3, 4], [5]]))   # Output: [1, 2, 3, 4, 5]
print(filter(lambda x: x % 2 == 0, [1, 2, 3, 4]))  # Output: [2, 4]
print(length([1, 2, 3, 4]))            # Output: 4
print(map(lambda x: x * 2, [1, 2, 3, 4]))  # Output: [2, 4, 6, 8]
print(foldl(lambda acc, x: acc + x, [1, 2, 3, 4], 0))  # Output: 10
print(foldr(lambda x, acc: x + acc, [1, 2, 3, 4], 0))  # Output: 10
print(reverse([1, 2, 3, 4]))            # Output: [4, 3, 2, 1]


def transform(legacy_data):
    new_data = {}
    for points, letters in legacy_data.items():
        for letter in letters:
            new_data[letter.lower()] = points
    return new_data

# Example usage:
legacy_data = {
    1: ["A", "E", "I", "O", "U", "L", "N", "R", "S", "T"],
    2: ["D", "G"],
    3: ["B", "C", "M", "P"],
    4: ["F", "H", "V", "W", "Y"],
    5: ["K"],
    8: ["J", "X"],
    10: ["Q", "Z"]
}

print(transform(legacy_data))


class SpaceAge:
    SECONDS_IN_EARTH_YEAR = 31557600  # Earth year in seconds

    ORBITAL_PERIODS = {
        'mercury': 0.2408467,
        'venus': 0.61519726,
        'earth': 1.0,
        'mars': 1.8808158,
        'jupiter': 11.862615,
        'saturn': 29.447498,
        'uranus': 84.016846,
        'neptune': 164.79132
    }

    def __init__(self, seconds):
        self.seconds = seconds

    def _calculate_age(self, planet):
        return round(self.seconds / (self.SECONDS_IN_EARTH_YEAR * self.ORBITAL_PERIODS[planet]), 2)

    def on_mercury(self):
        return self._calculate_age('mercury')

    def on_venus(self):
        return self._calculate_age('venus')

    def on_earth(self):
        return self._calculate_age('earth')

    def on_mars(self):
        return self._calculate_age('mars')

    def on_jupiter(self):
        return self._calculate_age('jupiter')

    def on_saturn(self):
        return self._calculate_age('saturn')

    def on_uranus(self):
        return self._calculate_age('uranus')

    def on_neptune(self):
        return self._calculate_age('neptune')

# Example usage:
age = SpaceAge(1000000000)
print(age.on_earth())    # Output: 31.69
print(age.on_mercury())  # Output: 131.57
print(age.on_venus())    # Output: 51.51
print(age.on_mars())     # Output: 16.85
print(age.on_jupiter())  # Output: 2.67
print(age.on_saturn())   # Output: 1.08
print(age.on_uranus())   # Output: 0.38
print(age.on_neptune())  # Output: 0.19


def sum_of_multiples(limit, multiples):
    unique_multiples = set()

    for base in multiples:
        if base > 0:  # to avoid division by zero
            for i in range(1, limit):
                multiple = base * i
                if multiple < limit:
                    unique_multiples.add(multiple)
                else:
                    break

    return sum(unique_multiples)

# Example usage:
level = 20
base_values = [3, 5]
print(sum_of_multiples(level, base_values))  # Output: 78


def convert_seconds(seconds):
    if seconds < 1000:
        return f"{seconds} seconds"
    elif seconds < 1_000_000:
        return f"{seconds / 1_000:.2f} kiloseconds (ks)"
    elif seconds < 1_000_000_000:
        return f"{seconds / 1_000_000:.2f} megaseconds (Ms)"
    else:
        return f"{seconds / 1_000_000_000:.2f} gigaseconds (Gs)"

# Example usage:
print(convert_seconds(500))         # Output: "500 seconds"
print(convert_seconds(2000))        # Output: "2.00 kiloseconds (ks)"
print(convert_seconds(2_000_000))   # Output: "2.00 megaseconds (Ms)"
print(convert_seconds(1_000_000_000)) # Output: "1.00 gigaseconds (Gs)"


To implement the `two_fer` function, we need to check if a name is provided and construct the response accordingly. If a name is provided, the response should include that name; otherwise, the response should use "you".

Here's how you can implement this:

### Implementation

```python
def two_fer(name="you"):
    return f"One for {name}, one for me."

# Example usage:
print(two_fer("Alice"))   # Output: One for Alice, one for me.
print(two_fer("Bohdan"))  # Output: One for Bohdan, one for me.
print(two_fer())          # Output: One for you, one for me.
print(two_fer("Zaphod"))  # Output: One for Zaphod, one for me.
```

### Explanation

1. **Function Definition**:
   - The function `two_fer` takes an optional parameter `name`. If no name is provided, it defaults to "you".

2. **Return Statement**:
   - The function returns a formatted string using an f-string. The string will either use the provided name or "you" if no name is given.

### Example Outputs

- **two_fer("Alice")**: "One for Alice, one for me."
- **two_fer("Bohdan")**: "One for Bohdan, one for me."
- **two_fer()**: "One for you, one for me." (no name provided)
- **two_fer("Zaphod")**: "One for Zaphod, one for me."

This implementation ensures that the function behaves correctly whether a name is provided or not, providing a default message in the absence of a name.

To compute the square root of a natural number without using Python's built-in functions or the `math` module, you can implement a simple algorithm like the **Babylonian method** (also known as the **Newton-Raphson method** for square roots). This method iteratively approximates the square root of a number.

Here's a step-by-step guide on how to implement this:

### Implementation

1. **Initial Guess**: Start with an initial guess for the square root. A common choice is to start with `number / 2`.
2. **Iterative Improvement**: Use the formula \( x_{n+1} = \frac{1}{2} (x_n + \frac{\text{number}}{x_n}) \) to iteratively improve the guess.
3. **Stopping Condition**: Stop the iteration when the improvement is smaller than a certain threshold (e.g., \(10^{-10}\)) to ensure the result is precise enough.

### Python Code

Here's how you can implement this algorithm in Python:

```python
def square_root(number):
    if number < 0:
        raise ValueError("Cannot compute the square root of a negative number.")
    if number == 0:
        return 0
    
    guess = number / 2.0
    threshold = 1e-10
    
    while True:
        new_guess = 0.5 * (guess + number / guess)
        if abs(new_guess - guess) < threshold:
            return int(new_guess)
        guess = new_guess

# Example usage:
print(square_root(25))  # Output: 5
print(square_root(49))  # Output: 7
print(square_root(2))   # Output: 1
```

### Explanation

1. **Initial Check**:
   - If the number is less than 0, raise a `ValueError` since the square root of a negative number is not defined for natural numbers.
   - If the number is 0, return 0 immediately since the square root of 0 is 0.

2. **Initial Guess**:
   - Start with `guess = number / 2.0`.

3. **Iterative Improvement**:
   - Calculate the new guess using the formula \( x_{n+1} = \frac{1}{2} (x_n + \frac{\text{number}}{x_n}) \).
   - If the difference between the new guess and the current guess is smaller than the threshold, return the integer part of the new guess.
   - Update the guess with the new guess and repeat the process.

4. **Threshold**:
   - A threshold of \(1 \times 10^{-10}\) ensures the result is precise enough for practical purposes.

### Additional Notes

- The Babylonian method converges quickly, usually within a few iterations for most numbers.
- The method works well for positive integers and provides a good approximation of the square root.
- You can adjust the threshold for different precision requirements.

By following these steps, you can compute the square root of a natural number without relying on built-in functions or libraries.

def translate(text):
    vowels = 'aeiou'
    result = []
    
    def translate_word(word):
        # Rule 1
        if word[0] in vowels or word[:2] in ['xr', 'yt']:
            return word + 'ay'
        
        # Rule 3
        for i in range(len(word)):
            if word[i] in vowels or word[i] == 'y':
                if word[i:i+2] == 'qu':
                    return word[i+2:] + word[:i+2] + 'ay'
                break
        
        # Rule 4
        for i in range(len(word)):
            if word[i] in vowels or word[i] == 'y':
                if word[i] == 'y':
                    return word[i:] + word[:i] + 'ay'
                break
        
        # Rule 2
        for i in range(len(word)):
            if word[i] in vowels:
                return word[i:] + word[:i] + 'ay'
        
        return word + 'ay'
    
    for word in text.split():
        result.append(translate_word(word))
    
    return ' '.join(result)

# Example usage:
print(translate("apple"))  # Output: "appleay"
print(translate("xray"))   # Output: "xrayay"
print(translate("yttria")) # Output: "yttriaay"
print(translate("pig"))    # Output: "igpay"
print(translate("chair"))  # Output: "airchay"
print(translate("quick"))  # Output: "ickquay"
print(translate("square")) # Output: "aresquay"
print(translate("my"))     # Output: "ymay"
print(translate("rhythm")) # Output: "ythmrhay"


def is_paired(input_string):
    stack = []
    matching_bracket = {')': '(', ']': '[', '}': '{'}
    
    for char in input_string:
        if char in matching_bracket.values():
            stack.append(char)
        elif char in matching_bracket.keys():
            if stack == [] or matching_bracket[char] != stack.pop():
                return False
    
    return stack == []

# Example usage:
print(is_paired("([])[]({})"))  # Output: True
print(is_paired("([)]"))        # Output: False
print(is_paired("((()"))        # Output: False
print(is_paired("{[()]}"))      # Output: True


To determine the relationship between two lists (whether one is a sublist of the other, a superlist, equal, or unequal), we need to implement the `sublist` function. First, let's define the constants for the different categories:

### Constants
```python
SUBLIST = 1
SUPERLIST = 2
EQUAL = 3
UNEQUAL = 4
```

### Function Logic
The function will:
1. Check if the two lists are equal.
2. Check if one list is a sublist of the other.
3. Check if one list is a superlist of the other.
4. Return `UNEQUAL` if none of the above conditions are met.

### Implementation

```python
# Define constants
SUBLIST = 1
SUPERLIST = 2
EQUAL = 3
UNEQUAL = 4

def is_sublist(smaller, larger):
    """Check if smaller list is a sublist of larger list."""
    if not smaller:
        return True
    if len(smaller) > len(larger):
        return False
    for i in range(len(larger) - len(smaller) + 1):
        if larger[i:i+len(smaller)] == smaller:
            return True
    return False

def sublist(list_one, list_two):
    if list_one == list_two:
        return EQUAL
    if is_sublist(list_one, list_two):
        return SUBLIST
    if is_sublist(list_two, list_one):
        return SUPERLIST
    return UNEQUAL

# Example usage:
print(sublist([1, 2, 3], [1, 2, 3, 4, 5]))  # Output: 1 (SUBLIST)
print(sublist([1, 2, 3, 4, 5], [2, 3, 4]))  # Output: 2 (SUPERLIST)
print(sublist([1, 2, 3], [1, 2, 3]))        # Output: 3 (EQUAL)
print(sublist([1, 2, 4], [1, 2, 3, 4, 5]))  # Output: 4 (UNEQUAL)
```

### Explanation
1. **is_sublist Function**:
   - This helper function checks if the first list (`smaller`) is a sublist of the second list (`larger`).
   - It iterates through the larger list and compares slices of it with the smaller list.
   - Returns `True` if a matching sublist is found, otherwise returns `False`.

2. **sublist Function**:
   - Compares the two lists for equality first.
   - Uses the `is_sublist` function to check if one list is a sublist or superlist of the other.
   - Returns the appropriate constant based on the relationship between the two lists.

### Testing

You can further test the function with additional cases to ensure it works correctly:

```python
print(sublist([], []))                     # Output: 3 (EQUAL)
print(sublist([1, 2, 3], []))              # Output: 2 (SUPERLIST)
print(sublist([], [1, 2, 3]))              # Output: 1 (SUBLIST)
print(sublist([3, 4, 5], [1, 2, 3, 4, 5])) # Output: 1 (SUBLIST)
print(sublist([1, 3, 2], [1, 2, 3]))       # Output: 4 (UNEQUAL)
```

This implementation ensures that all possible relationships between the two lists are correctly identified and handled.

To implement the Atbash cipher, we need two main functions: `encode` and `decode`. The Atbash cipher transposes each letter in the alphabet to its reverse counterpart (i.e., 'a' becomes 'z', 'b' becomes 'y', etc.). We also need to handle the formatting of the encoded output to group the letters in blocks of five characters.

### Implementation

1. **Encode Function**:
   - Convert the plain text to lowercase.
   - Transpose each letter using the Atbash cipher mapping.
   - Ignore punctuation and whitespace.
   - Leave numbers unchanged.
   - Group the resulting string in blocks of five characters.

2. **Decode Function**:
   - Convert the ciphered text to lowercase.
   - Transpose each letter back using the Atbash cipher mapping.
   - Ignore punctuation and whitespace.
   - Leave numbers unchanged.
   - Concatenate the resulting characters without any grouping.

### Python Code

Here's the Python implementation of the Atbash cipher:

```python
def atbash_transform(char):
    if 'a' <= char <= 'z':
        return chr(ord('z') - (ord(char) - ord('a')))
    return char

def encode(plain_text):
    plain_text = plain_text.lower()
    encoded = ''.join(atbash_transform(char) for char in plain_text if char.isalnum())
    return ' '.join(encoded[i:i+5] for i in range(0, len(encoded), 5))

def decode(ciphered_text):
    ciphered_text = ciphered_text.lower()
    return ''.join(atbash_transform(char) for char in ciphered_text if char.isalnum())

# Example usage:
print(encode("test"))  # Output: "gvhg"
print(encode("x123 yes"))  # Output: "c123b vh"
print(decode("gvhg"))  # Output: "test"
print(decode("gsvjf rxpyi ldmul cqfnk hlevi gsvoz abwlt"))  # Output: "thequickbrownfoxjumpsoverthelazydog"
```

### Explanation

1. **Atbash Transform Function**:
   - The `atbash_transform` function converts a given character using the Atbash cipher. If the character is a letter, it calculates the transformed letter by reversing its position in the alphabet. Numbers and other non-alphabet characters remain unchanged.

2. **Encode Function**:
   - Converts the input text to lowercase.
   - Transforms each character using the Atbash cipher, ignoring non-alphanumeric characters.
   - Joins the transformed characters into a single string.
   - Splits the string into blocks of five characters.

3. **Decode Function**:
   - Converts the input text to lowercase.
   - Transforms each character using the Atbash cipher, ignoring non-alphanumeric characters.
   - Joins the transformed characters into a single string.

This implementation ensures that the Atbash cipher is correctly applied to both encoding and decoding processes, handling all specified requirements.


To implement the diamond kata, we'll create a function that takes a letter as input and outputs a diamond shape. Here's how we can approach this problem step-by-step:

### Steps to Create the Diamond

1. **Determine the Size**:
   - The size of the diamond is determined by the position of the input letter in the alphabet. For example, 'C' will create a diamond with a width and height of 5 (2 * position of 'C' - 1).

2. **Generate Rows**:
   - Generate each row of the diamond. The middle row (widest part) will contain the input letter twice, and each preceding row will contain the previous letter in the alphabet, with 'A' at the top and bottom.

3. **Format Rows**:
   - Each row should be formatted with leading and trailing spaces to ensure the diamond shape. The amount of leading and trailing spaces decreases as you move from the top of the diamond to the middle and increases as you move to the bottom.

4. **Symmetry**:
   - Ensure the diamond is horizontally and vertically symmetric.

### Implementation

Here's the implementation of the `rows` function:

```python
def rows(letter):
    if not letter.isalpha() or len(letter) != 1:
        raise ValueError("Input must be a single alphabet letter")
    
    # Calculate the size of the diamond
    n = ord(letter) - ord('A')
    
    # Generate the diamond rows
    diamond = []
    for i in range(n + 1):
        char = chr(ord('A') + i)
        if i == 0:
            diamond.append(' ' * n + char + ' ' * n)
        else:
            spaces_between = ' ' * (2 * i - 1)
            spaces_around = ' ' * (n - i)
            diamond.append(spaces_around + char + spaces_between + char + spaces_around)
    
    # Add the bottom half of the diamond by mirroring the top half (excluding the middle line)
    bottom_half = diamond[:-1][::-1]
    diamond.extend(bottom_half)
    
    return diamond

# Example usage:
for line in rows('C'):
    print(line)
```

### Explanation

1. **Input Validation**:
   - Ensure the input is a single alphabet letter.

2. **Size Calculation**:
   - Calculate `n` as the zero-based index of the input letter in the alphabet.

3. **Generating Rows**:
   - Iterate from `0` to `n` to create the top half of the diamond.
   - For the first row, add the letter 'A' with appropriate leading and trailing spaces.
   - For subsequent rows, add the current letter with spaces in between and around to ensure the diamond shape.

4. **Bottom Half**:
   - Mirror the top half (excluding the middle row) to create the bottom half of the diamond.

### Example Output

For input `'C'`, the output would be:

```
  A  
 B B 
C   C
 B B 
  A  
```

This implementation correctly generates the diamond shape with the given letter at its widest point, ensuring horizontal and vertical symmetry, and proper spacing.


To translate RNA sequences into proteins, we need to map RNA codons to their corresponding amino acids and handle the stop codons that terminate the translation process. Here’s how you can implement this in Python:

### Codon to Protein Mapping
We need to create a dictionary that maps each RNA codon to its corresponding protein.

### Implementation Steps

1. **Create a codon to protein dictionary**.
2. **Split the RNA strand into codons** (sequences of three nucleotides).
3. **Translate each codon to its corresponding protein** until a stop codon is encountered.
4. **Return the list of proteins**.

### Python Code

```python
def proteins(strand):
    codon_protein_map = {
        'AUG': 'Methionine',
        'UUU': 'Phenylalanine', 'UUC': 'Phenylalanine',
        'UUA': 'Leucine', 'UUG': 'Leucine',
        'UCU': 'Serine', 'UCC': 'Serine', 'UCA': 'Serine', 'UCG': 'Serine',
        'UAU': 'Tyrosine', 'UAC': 'Tyrosine',
        'UGU': 'Cysteine', 'UGC': 'Cysteine',
        'UGG': 'Tryptophan',
        'UAA': 'STOP', 'UAG': 'STOP', 'UGA': 'STOP'
    }

    protein_sequence = []
    for i in range(0, len(strand), 3):
        codon = strand[i:i+3]
        protein = codon_protein_map.get(codon)
        if protein == 'STOP':
            break
        if protein:
            protein_sequence.append(protein)
    
    return protein_sequence

# Example usage:
print(proteins("AUGUUUUCUUAAAUG"))  # Output: ['Methionine', 'Phenylalanine', 'Serine']
print(proteins("AUGUCCUAG"))        # Output: ['Methionine', 'Serine']
```

### Explanation

1. **Codon to Protein Dictionary**:
   - `codon_protein_map` is a dictionary mapping each codon to its corresponding protein or stop signal.

2. **Splitting the RNA Strand**:
   - The loop `for i in range(0, len(strand), 3)` iterates over the RNA strand, three nucleotides (one codon) at a time.

3. **Translation Process**:
   - For each codon, we look up the corresponding protein in `codon_protein_map`.
   - If the codon translates to 'STOP', we break out of the loop.
   - Otherwise, we append the translated protein to `protein_sequence`.

4. **Return the Protein Sequence**:
   - The function returns the list of proteins translated from the RNA strand.

### Example Outputs

- For input `"AUGUUUUCUUAAAUG"`, the output will be `['Methionine', 'Phenylalanine', 'Serine']`.
- For input `"AUGUCCUAG"`, the output will be `['Methionine', 'Serine']`.

This implementation correctly translates RNA sequences into their corresponding protein sequences while handling stop codons appropriately.


To compute the prime factors of a given natural number, we need to follow a systematic approach. Here's a step-by-step implementation:

### Steps

1. **Initialize the list of factors**: This will store the prime factors.
2. **Divide by smallest prime**: Start with the smallest prime number, 2, and divide the given number until it's no longer divisible by 2.
3. **Move to next primes**: Continue with the next prime numbers (3, 5, 7, etc.), dividing the number until it's reduced to 1.
4. **Return the list of factors**: The resulting list contains all the prime factors of the given number.

### Implementation

Here's the Python function to find the prime factors:

```python
def factors(value):
    if value < 2:
        return []
    
    prime_factors = []
    divisor = 2

    while value >= divisor:
        while value % divisor == 0:
            prime_factors.append(divisor)
            value //= divisor
        divisor += 1
        
        # Optimizing by only checking up to sqrt(value)
        if divisor * divisor > value and value > 1:
            prime_factors.append(value)
            break

    return prime_factors

# Example usage:
print(factors(60))  # Output: [2, 2, 3, 5]
print(factors(75))  # Output: [3, 5, 5]
print(factors(13))  # Output: [13]
```

### Explanation

1. **Initialization**:
   - `prime_factors` is initialized as an empty list to store the prime factors.
   - `divisor` starts at 2, the smallest prime number.

2. **Divide by 2**:
   - Use a nested `while` loop to divide the number by 2 as long as it's divisible.
   - Append 2 to `prime_factors` for each division.

3. **Move to next primes**:
   - Increment the divisor to the next number.
   - Continue the process for the next potential prime factors.
   - The check `divisor * divisor > value` is an optimization to stop early if the divisor exceeds the square root of the remaining value.

4. **Handling remaining value**:
   - If the remaining value is greater than 1 and no further divisors are found, it's a prime number and added to `prime_factors`.

### Example Outputs

- For input `60`, the output is `[2, 2, 3, 5]`.
- For input `75`, the output is `[3, 5, 5]`.
- For input `13`, the output is `[13]`.

This implementation ensures that all prime factors of the given number are correctly identified and returned in a list.

To convert a number from 0 to 999,999,999,999 into its English words representation, we need to break down the problem into manageable steps and handle each range of numbers separately. Here is the step-by-step implementation:

### Step 1: Handle the basic case of 0 through 99

### Step 2: Break a number into chunks of thousands

### Step 3: Insert the appropriate scale word between those chunks

### Step 4: Put it all together

### Implementation

1. **Number Words Dictionary**: Create a dictionary to map numbers to their word representations.
2. **Helper Functions**:
   - `number_to_words_1_to_99`: Convert numbers from 1 to 99.
   - `number_to_words_1_to_999`: Convert numbers from 1 to 999.
3. **Main Function**:
   - `say`: Convert the number to words by breaking it into chunks and appending the appropriate scale word.

Here is the Python code implementing these steps:

```python
def say(number):
    if number < 0 or number > 999_999_999_999:
        raise ValueError("input out of range")
    
    if number == 0:
        return "zero"
    
    num_words = {
        0: "zero", 1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine",
        10: "ten", 11: "eleven", 12: "twelve", 13: "thirteen", 14: "fourteen", 15: "fifteen", 16: "sixteen", 17: "seventeen", 18: "eighteen", 19: "nineteen",
        20: "twenty", 30: "thirty", 40: "forty", 50: "fifty", 60: "sixty", 70: "seventy", 80: "eighty", 90: "ninety"
    }
    
    def number_to_words_1_to_99(n):
        if n < 20:
            return num_words[n]
        elif n < 100:
            if n % 10 == 0:
                return num_words[n]
            else:
                return num_words[n // 10 * 10] + "-" + num_words[n % 10]
    
    def number_to_words_1_to_999(n):
        if n < 100:
            return number_to_words_1_to_99(n)
        else:
            if n % 100 == 0:
                return num_words[n // 100] + " hundred"
            else:
                return num_words[n // 100] + " hundred " + number_to_words_1_to_99(n % 100)
    
    def number_to_words(n):
        if n < 1000:
            return number_to_words_1_to_999(n)
        
        units = ["", "thousand", "million", "billion"]
        words = []
        unit_index = 0
        
        while n > 0:
            chunk = n % 1000
            if chunk != 0:
                chunk_words = number_to_words_1_to_999(chunk)
                if units[unit_index]:
                    chunk_words += " " + units[unit_index]
                words.append(chunk_words)
            n //= 1000
            unit_index += 1
        
        return " ".join(reversed(words))
    
    return number_to_words(number)

# Example usage:
print(say(22))         # Output: "twenty-two"
print(say(12345))      # Output: "twelve thousand three hundred forty-five"
print(say(987654321))  # Output: "nine hundred eighty-seven million six hundred fifty-four thousand three hundred twenty-one"
print(say(1000))       # Output: "one thousand"
print(say(1000000))    # Output: "one million"
print(say(0))          # Output: "zero"
```

### Explanation

1. **Input Validation**:
   - The function checks if the input number is within the valid range (0 to 999,999,999,999). If not, it raises a `ValueError`.

2. **Basic Numbers Mapping**:
   - The `num_words` dictionary maps numbers to their word representations for numbers from 0 to 19 and multiples of 10 up to 90.

3. **Helper Functions**:
   - `number_to_words_1_to_99`: Handles numbers from 1 to 99 by breaking them into tens and units.
   - `number_to_words_1_to_999`: Handles numbers from 1 to 999 by breaking them into hundreds, tens, and units.

4. **Main Function**:
   - `number_to_words`: Handles larger numbers by breaking them into chunks of thousands and appending the appropriate scale word (thousand, million, billion).

5. **Example Outputs**:
   - For input `22`, the output is `"twenty-two"`.
   - For input `12345`, the output is `"twelve thousand three hundred forty-five"`.
   - For input `987654321`, the output is `"nine hundred eighty-seven million six hundred fifty-four thousand three hundred twenty-one"`.
   - For input `1000`, the output is `"one thousand"`.
   - For input `1000000`, the output is `"one million"`.
   - For input `0`, the output is `"zero"`.

This implementation ensures that the given number is converted to its correct English words representation.

To convert a phrase to its acronym, we'll follow these steps:

1. **Remove unwanted punctuation**: Except for hyphens, all punctuation should be removed.
2. **Handle hyphens as word separators**: Treat hyphens as whitespace to separate words.
3. **Extract the first letter of each word**: This includes words separated by spaces or hyphens.
4. **Convert the letters to uppercase**: The acronym should be in uppercase.

### Implementation

Here's a Python function that accomplishes the task:

```python
import re

def abbreviate(words):
    # Replace hyphens with spaces and remove other punctuation
    cleaned_words = re.sub(r'[^A-Za-z\s-]', '', words).replace('-', ' ')
    
    # Split the cleaned words into a list
    word_list = cleaned_words.split()
    
    # Extract the first letter of each word and convert to uppercase
    acronym = ''.join(word[0].upper() for word in word_list)
    
    return acronym

# Example usage:
print(abbreviate("As Soon As Possible"))           # Output: "ASAP"
print(abbreviate("Liquid-crystal display"))        # Output: "LCD"
print(abbreviate("Thank George It's Friday!"))     # Output: "TGIF"
print(abbreviate("Portable Network Graphics"))     # Output: "PNG"
```

### Explanation

1. **Removing Unwanted Punctuation**:
   - We use a regular expression `re.sub(r'[^A-Za-z\s-]', '', words)` to remove all characters except letters, spaces, and hyphens.
   - Replace hyphens with spaces using `.replace('-', ' ')` to treat hyphens as word separators.

2. **Splitting the Words**:
   - `cleaned_words.split()` splits the string into a list of words based on whitespace.

3. **Extracting Initial Letters**:
   - We use a list comprehension `word[0].upper() for word in word_list` to get the first letter of each word and convert it to uppercase.

4. **Forming the Acronym**:
   - `''.join(...)` joins the list of initial letters into a single string, which is the acronym.

### Example Outputs

- For input `"As Soon As Possible"`, the output is `"ASAP"`.
- For input `"Liquid-crystal display"`, the output is `"LCD"`.
- For input `"Thank George It's Friday!"`, the output is `"TGIF"`.
- For input `"Portable Network Graphics"`, the output is `"PNG"`.

This function handles various cases and punctuation correctly, ensuring that the acronym is formed accurately.

To generate all contiguous substrings of a given length from a string of digits, we can follow a straightforward approach:

1. **Input Validation**: Check for edge cases such as empty series, zero or negative slice length, and slice length greater than the series length. Raise appropriate exceptions for these cases.
2. **Generate Substrings**: Iterate through the series and generate substrings of the specified length.

### Implementation

Here’s how you can implement this in Python:

```python
def slices(series, length):
    # Raise ValueError for invalid inputs
    if length == 0:
        raise ValueError("slice length cannot be zero")
    if length < 0:
        raise ValueError("slice length cannot be negative")
    if not series:
        raise ValueError("series cannot be empty")
    if length > len(series):
        raise ValueError("slice length cannot be greater than series length")

    # Generate all contiguous substrings of the specified length
    result = [series[i:i+length] for i in range(len(series) - length + 1)]
    
    return result

# Example usage:
print(slices("49142", 3))  # Output: ['491', '914', '142']
print(slices("49142", 4))  # Output: ['4914', '9142']
print(slices("49142", 6))  # Raises ValueError: slice length cannot be greater than series length
```

### Explanation

1. **Input Validation**:
   - If the slice length is zero, raise a `ValueError` with the message "slice length cannot be zero".
   - If the slice length is negative, raise a `ValueError` with the message "slice length cannot be negative".
   - If the series is empty, raise a `ValueError` with the message "series cannot be empty".
   - If the slice length is greater than the series length, raise a `ValueError` with the message "slice length cannot be greater than series length".

2. **Generating Substrings**:
   - Use a list comprehension to iterate through the series and generate substrings of the specified length. The range for iteration is from `0` to `len(series) - length + 1` to ensure all possible substrings are covered.

### Example Outputs

- For input `"49142"` with slice length `3`, the output is `['491', '914', '142']`.
- For input `"49142"` with slice length `4`, the output is `['4914', '9142']`.
- For input `"49142"` with slice length `6`, it raises a `ValueError` with the message "slice length cannot be greater than series length".

This implementation ensures that all valid substrings of the given length are correctly generated, and appropriate exceptions are raised for invalid inputs.

To implement run-length encoding (RLE) and decoding in Python, we will create two functions: `encode` and `decode`. Here's how we can approach each task:

### Run-Length Encoding

1. **Encoding**:
   - Iterate through the input string.
   - Keep track of the current character and its count.
   - When the current character changes, append the count (if greater than 1) and the character to the result.
   - Continue this process until the end of the string.

### Run-Length Decoding

2. **Decoding**:
   - Iterate through the encoded string.
   - If a digit is encountered, parse the number to get the count of the next character.
   - Append the character the number of times specified by the count.
   - If no digit precedes a character, assume the count is 1.

### Implementation

Here is the Python code for both encoding and decoding functions:

```python
def encode(string):
    if not string:
        return ""
    
    encoded_string = []
    current_char = string[0]
    count = 1
    
    for char in string[1:]:
        if char == current_char:
            count += 1
        else:
            if count > 1:
                encoded_string.append(str(count))
            encoded_string.append(current_char)
            current_char = char
            count = 1
            
    if count > 1:
        encoded_string.append(str(count))
    encoded_string.append(current_char)
    
    return ''.join(encoded_string)

def decode(string):
    if not string:
        return ""
    
    decoded_string = []
    count = 0
    
    for char in string:
        if char.isdigit():
            count = count * 10 + int(char)
        else:
            if count == 0:
                decoded_string.append(char)
            else:
                decoded_string.append(char * count)
                count = 0
    
    return ''.join(decoded_string)

# Example usage:
print(encode("WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"))  # Output: "12WB12W3B24WB"
print(decode("12WB12W3B24WB"))  # Output: "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"
print(encode("AABCCCDEEEE"))  # Output: "2AB3CD4E"
print(decode("2AB3CD4E"))  # Output: "AABCCCDEEEE"
```

### Explanation

1. **Encoding**:
   - The `encode` function iterates through the input string and counts consecutive characters.
   - When a different character is encountered, it appends the count and the character to the result list.
   - If the count is 1, it only appends the character.
   - At the end of the string, it ensures the last group of characters is also added to the result.

2. **Decoding**:
   - The `decode` function iterates through the encoded string and constructs the original string.
   - It uses a count variable to handle multi-digit numbers.
   - When a non-digit character is encountered, it appends it the number of times specified by the count.
   - If no count is specified, it appends the character once.

These functions handle the run-length encoding and decoding efficiently and ensure the original data can be perfectly reconstructed from the compressed data.

To solve this problem, we need to find the nth prime number. To do this, we'll use a function called `prime` that generates prime numbers until we reach the nth one.

Here's the plan for our function:

1. **Check for Malformed Input**: If the input number is less than 1, we should raise a `ValueError` with a meaningful message.
2. **Generate Prime Numbers**: We'll use a helper function to check if a number is prime.
3. **Loop and Count Primes**: We'll loop through numbers, count the primes, and stop when we reach the nth prime.

Here's the implementation:

```python
def prime(number):
    if number < 1:
        raise ValueError('there is no zeroth prime')

    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    count = 0
    num = 1
    while count < number:
        num += 1
        if is_prime(num):
            count += 1

    return num
```

### Explanation:

1. **Input Validation**: 
   - We first check if the input number is less than 1. If so, we raise a `ValueError` with the message 'there is no zeroth prime'.
   
2. **Prime Checking Function (`is_prime`)**:
   - The `is_prime` function checks if a number is prime.
   - Numbers less than or equal to 1 are not prime.
   - Numbers 2 and 3 are prime.
   - If the number is divisible by 2 or 3, it's not prime.
   - We then check for factors from 5 onwards, skipping even numbers to reduce the number of checks.

3. **Prime Generation**:
   - We initialize `count` to keep track of how many primes we've found.
   - We start checking from the number 2 upwards.
   - Each time we find a prime number, we increment the count.
   - When the count reaches the desired number, we return that prime number.

This function effectively finds the nth prime number and handles invalid input by raising an appropriate exception.

To solve the problem of generating the lyrics for "The Twelve Days of Christmas," we can follow a systematic approach that minimizes repetition by constructing each verse programmatically.

Here's a detailed breakdown of the approach:

1. **Define the days and gifts**: Create a list of gifts and a list of day names to use in the song.
2. **Construct the verses**: Assemble each verse by iterating through the days and corresponding gifts.
3. **Generate the requested verses**: Return the lyrics for the specified range of verses.

### Implementation:

1. **Lists for Days and Gifts**:
   - We'll use a list of gifts, starting from the twelfth gift down to the first.
   - We'll use another list to store the ordinal representation of the days.

2. **Constructing Each Verse**:
   - For each verse, we will append the gifts in reverse order to ensure the correct cumulative nature of the song.

3. **Generate the Lyrics**:
   - We'll loop from the `start_verse` to the `end_verse` and construct each verse based on the defined structure.

Here's the implementation:

```python
def recite(start_verse, end_verse):
    days = ["first", "second", "third", "fourth", "fifth", "sixth",
            "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth"]
    
    gifts = [
        "twelve Drummers Drumming",
        "eleven Pipers Piping",
        "ten Lords-a-Leaping",
        "nine Ladies Dancing",
        "eight Maids-a-Milking",
        "seven Swans-a-Swimming",
        "six Geese-a-Laying",
        "five Gold Rings",
        "four Calling Birds",
        "three French Hens",
        "two Turtle Doves",
        "and a Partridge in a Pear Tree"
    ]

    # Adjust the first gift to not have 'and' in the first verse
    first_gift = "a Partridge in a Pear Tree"
    
    verses = []

    for i in range(start_verse - 1, end_verse):
        verse = f"On the {days[i]} day of Christmas my true love gave to me: "
        
        if i == 0:
            verse += first_gift
        else:
            verse += ', '.join(gifts[-(i+1):-1]) + ", " + gifts[-1]
        
        verses.append(verse)
    
    return verses

# Example Usage:
# recite(1, 1) will return the first verse.
# recite(1, 12) will return all the verses from the first to the twelfth.
```

### Explanation:

1. **Lists for Days and Gifts**:
   - `days` list contains the ordinal names for each day.
   - `gifts` list contains the gifts, starting from the twelfth down to the first.

2. **Constructing Each Verse**:
   - We loop through the requested verses.
   - For each verse, we build the string by concatenating the gifts in the correct order.

3. **Edge Case for the First Verse**:
   - The first verse's gift "a Partridge in a Pear Tree" doesn't include "and" which is handled separately.

4. **Returning the Verses**:
   - We collect each constructed verse in the `verses` list and return it.

This implementation constructs the verses dynamically, adhering to the cumulative nature of the song while avoiding hardcoded repetition.

To convert an integer to a Roman numeral, we need to map specific values to their corresponding Roman numeral representations and then construct the numeral by iterating through the integer values in descending order.

### Steps:

1. **Define Mappings**: Create a list of tuples that maps integer values to their respective Roman numeral strings, sorted in descending order.
2. **Build the Roman Numeral**: Iterate through the list of tuples, and for each tuple, append the corresponding numeral to the result string while decreasing the integer value appropriately.

### Implementation:

1. Define a list of tuples containing the integer values and their corresponding Roman numeral strings.
2. Iterate over the list, appending the Roman numeral string to the result for each applicable value, and decrease the input number accordingly.
3. Return the constructed Roman numeral string.

Here's the implementation in Python:

```python
def roman(number):
    if not isinstance(number, int) or number <= 0:
        raise ValueError("Input must be a positive integer.")
    
    roman_numerals = [
        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),
        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')
    ]
    
    result = []
    for value, numeral in roman_numerals:
        while number >= value:
            result.append(numeral)
            number -= value
    
    return ''.join(result)

# Example Usage:
# roman(1996) will return 'MCMXCVI'
# roman(104) will return 'CIV'
# roman(18) will return 'XVIII'
```

### Explanation:

1. **Input Validation**: The function first checks if the input is a positive integer. If not, it raises a `ValueError`.
2. **Roman Numeral Mapping**: The `roman_numerals` list contains tuples where each tuple consists of an integer and its corresponding Roman numeral string, ordered from largest to smallest.
3. **Building the Result**:
   - The function iterates over each value-numeral pair.
   - While the input number is greater than or equal to the value, it appends the corresponding numeral to the result list and subtracts the value from the number.
   - This ensures the numerals are added in the correct order, and the correct number of times.
4. **Return the Result**: The function joins the list of Roman numeral strings into a single string and returns it.

This implementation effectively constructs the Roman numeral representation by adhering to the rules of Roman numeral construction, including the subtraction method for numbers like 4 (IV) and 9 (IX).

To tackle this problem, we need to parse a given subtitle sentence and count the occurrences of each word. We will handle different cases, including punctuation, contractions, and case insensitivity. Here's the step-by-step approach to achieve this:

### Steps:

1. **Normalize Case**: Convert the entire sentence to lowercase to handle case insensitivity.
2. **Tokenization**: Split the sentence into words using punctuation and whitespace as delimiters, but keep contractions intact.
3. **Count Words**: Use a dictionary to count the occurrences of each word.
4. **Handle Special Characters**: Remove punctuation except for apostrophes within contractions.

### Implementation:

1. **Regular Expressions**: Use regex to identify words and contractions.
2. **Dictionary for Counting**: Store word counts in a dictionary.

Here is the complete implementation:

```python
import re
from collections import defaultdict

def count_words(sentence):
    # Convert the sentence to lowercase
    sentence = sentence.lower()
    
    # Regular expression to match words and contractions
    words = re.findall(r"\b[\w']+\b", sentence)
    
    # Dictionary to store word counts
    word_count = defaultdict(int)
    
    # Count the occurrences of each word
    for word in words:
        word_count[word] += 1
    
    # Convert defaultdict to a regular dictionary for the result
    return dict(word_count)

# Example Usage:
# sentence = "That's the password: 'PASSWORD 123'!", cried the Special Agent.\nSo I fled."
# count_words(sentence) will return:
# {'that's': 1, 'the': 2, 'password': 2, '123': 1, 'cried': 1, 'special': 1, 'agent': 1, 'so': 1, 'i': 1, 'fled': 1}
```

### Explanation:

1. **Convert to Lowercase**: We first convert the entire sentence to lowercase to ensure that the word count is case insensitive.
2. **Regular Expression for Tokenization**:
   - The regex `r"\b[\w']+\b"` matches words and contractions:
     - `\b` denotes a word boundary.
     - `[\w']+` matches any word character (alphanumeric) or an apostrophe, ensuring contractions like "that's" or "we're" are matched as single words.
3. **Counting Words**:
   - We use a `defaultdict(int)` to keep the word counts. This avoids the need to check if a word is already in the dictionary, as `defaultdict` initializes the count to 0 by default.
4. **Return the Result**: Convert the `defaultdict` back to a regular dictionary before returning the result.

This solution effectively handles the requirements, ensuring contractions are treated as single words, punctuation is appropriately handled, and the word count is case insensitive.

To compute the Scrabble score for a given word, we can follow these steps:

1. **Create a mapping of letter values**: Use a dictionary to store the point values for each letter.
2. **Normalize the word**: Convert the word to uppercase since Scrabble letter values are case insensitive.
3. **Sum the letter values**: Iterate through the letters of the word and sum their corresponding values from the dictionary.

### Steps:

1. **Define the letter values**: Create a dictionary where each key is a letter and its value is the Scrabble point.
2. **Compute the score**: For each letter in the input word, look up its value in the dictionary and sum the values.

### Implementation:

Here is the implementation in Python:

```python
def score(word):
    # Dictionary mapping letters to their Scrabble values
    letter_values = {
        'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'L': 1, 'N': 1, 'R': 1, 'S': 1, 'T': 1,
        'D': 2, 'G': 2,
        'B': 3, 'C': 3, 'M': 3, 'P': 3,
        'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,
        'K': 5,
        'J': 8, 'X': 8,
        'Q': 10, 'Z': 10
    }

    # Convert the word to uppercase to match the dictionary keys
    word = word.upper()
    
    # Compute the score by summing the values of the letters in the word
    total_score = sum(letter_values[letter] for letter in word if letter in letter_values)
    
    return total_score

# Example Usage:
# score("cabbage") will return 14
# Explanation: 3 (C) + 1 (A) + 3 (B) + 3 (B) + 1 (A) + 2 (G) + 1 (E) = 14
```

### Explanation:

1. **Dictionary of Letter Values**: The `letter_values` dictionary maps each letter to its Scrabble point value. This allows for quick lookups.
2. **Uppercase Conversion**: We convert the input word to uppercase using `word.upper()`. This ensures that the dictionary keys (which are all uppercase) match the letters in the word.
3. **Summing Values**:
   - We use a generator expression inside the `sum` function to iterate through each letter in the word.
   - For each letter, we look up its value in the `letter_values` dictionary and sum these values.
   - The check `if letter in letter_values` ensures that only valid letters are considered, ignoring any unexpected characters.

This implementation efficiently calculates the Scrabble score for any given word.

To generate the proverbial rhyme based on a given list of inputs, we can follow these steps:

1. **Iterate through the List**: For each element in the list (except the last one), generate a line that follows the format: "For want of a [current element] the [next element] was lost."
2. **Generate the Final Line**: The last line should follow the format: "And all for the want of a [first element]."

### Steps:

1. **Check for Edge Cases**: If the list is empty or contains only one element, handle it appropriately.
2. **Construct the Proverb**: Loop through the list and create each line of the proverb.
3. **Return the Full Proverb**: Combine all lines into a single string and return it.

### Implementation:

Here is the Python code to generate the proverb:

```python
def proverb(*items):
    # Check for edge cases
    if not items:
        return ""
    
    # Initialize an empty list to hold each line of the proverb
    lines = []
    
    # Generate lines for each pair of consecutive items
    for i in range(len(items) - 1):
        lines.append(f"For want of a {items[i]} the {items[i+1]} was lost.")
    
    # Add the final line
    if items:
        lines.append(f"And all for the want of a {items[0]}.")
    
    # Join the lines into a single string with newline characters
    return "\n".join(lines)

# Example Usage:
# items = ["nail", "shoe", "horse", "rider", "message", "battle", "kingdom"]
# print(proverb(*items))
# The output will be the proverb generated from the given list.
```

### Explanation:

1. **Variable-Length Argument List**: The function `proverb` takes a variable number of arguments using `*items`. This allows the function to handle lists of arbitrary length.
2. **Edge Case Handling**: If the input list `items` is empty, the function returns an empty string.
3. **Proverb Construction**:
   - We loop through the list `items` (up to the second-to-last element) to generate the lines that follow the pattern: "For want of a [current element] the [next element] was lost."
   - We then add the final line: "And all for the want of a [first element]."
4. **Joining Lines**: We join all lines into a single string with newline characters separating each line, ensuring the output matches the expected format.

This implementation dynamically constructs the proverb based on the given list of items, handling lists of any length and content.

To implement the Luhn algorithm for validating a credit card number, we need to follow these steps:

1. **Initialization**: Create a class `Luhn` with a constructor that takes a card number as input.
2. **Strip Spaces and Validate Characters**: Ensure the card number contains only digits and spaces. Strip out the spaces.
3. **Check Length**: Ensure the stripped card number has more than one digit.
4. **Luhn Algorithm**:
    - Double every second digit from the right.
    - If doubling a digit results in a number greater than 9, subtract 9 from it.
    - Sum all the digits.
    - Check if the sum is divisible by 10.

### Implementation:

Here's the complete Python implementation of the Luhn class:

```python
class Luhn:
    def __init__(self, card_num):
        self.card_num = card_num.replace(" ", "")
    
    def valid(self):
        if not self.card_num.isdigit() or len(self.card_num) <= 1:
            return False
        
        total_sum = 0
        reverse_digits = self.card_num[::-1]
        
        for i, digit in enumerate(reverse_digits):
            n = int(digit)
            if i % 2 == 1:  # Every second digit from the right (0-based index)
                n *= 2
                if n > 9:
                    n -= 9
            total_sum += n
        
        return total_sum % 10 == 0

# Example Usage:
# card = Luhn("4539 3195 0343 6467")
# print(card.valid())  # Should print True

# card = Luhn("8273 1232 7352 0569")
# print(card.valid())  # Should print False
```

### Explanation:

1. **Constructor (`__init__` method)**:
    - The constructor takes `card_num` as an argument.
    - It strips out any spaces in the input number using `replace(" ", "")`.

2. **Validation Method (`valid` method)**:
    - First, it checks if the card number contains only digits and has more than one digit using `self.card_num.isdigit()` and `len(self.card_num) > 1`.
    - It initializes `total_sum` to 0 and reverses the card number.
    - It iterates over the reversed digits. For every second digit (i.e., where the index is odd), it doubles the digit. If the result is greater than 9, it subtracts 9.
    - It sums all the processed digits.
    - Finally, it checks if the total sum is divisible by 10. If it is, the card number is valid; otherwise, it is not.

This implementation correctly follows the Luhn algorithm and handles edge cases such as short or non-digit input.

To create a Dungeons & Dragons character generator, we need to simulate dice rolls to generate scores for six abilities: strength, dexterity, constitution, intelligence, wisdom, and charisma. Additionally, we need to compute the initial hitpoints based on the constitution score.

Here’s a step-by-step breakdown:

1. **Roll Four 6-sided Dice**: Simulate rolling four 6-sided dice and sum the highest three rolls.
2. **Generate Scores for Six Abilities**: Repeat the dice roll and sum process six times to generate scores for each ability.
3. **Calculate Constitution Modifier**: The constitution modifier is `(constitution - 10) // 2`.
4. **Calculate Initial Hitpoints**: The initial hitpoints are `10 + constitution_modifier`.

### Implementation

Here's the Python implementation of the character generator:

```python
import random

class Character:
    def __init__(self):
        self.strength = self.roll_ability()
        self.dexterity = self.roll_ability()
        self.constitution = self.roll_ability()
        self.intelligence = self.roll_ability()
        self.wisdom = self.roll_ability()
        self.charisma = self.roll_ability()
        self.hitpoints = 10 + self.constitution_modifier()

    def roll_ability(self):
        rolls = [random.randint(1, 6) for _ in range(4)]
        rolls.remove(min(rolls))
        return sum(rolls)

    def constitution_modifier(self):
        return (self.constitution - 10) // 2

# Example Usage:
character = Character()
print(f"Strength: {character.strength}")
print(f"Dexterity: {character.dexterity}")
print(f"Constitution: {character.constitution}")
print(f"Intelligence: {character.intelligence}")
print(f"Wisdom: {character.wisdom}")
print(f"Charisma: {character.charisma}")
print(f"Hitpoints: {character.hitpoints}")
```

### Explanation:

1. **Import Random Module**: We use the `random` module to simulate dice rolls.
2. **Character Class**:
   - **Initialization (`__init__` method)**:
     - For each ability (strength, dexterity, constitution, intelligence, wisdom, charisma), we call `roll_ability()` to generate a random score.
     - We compute the hitpoints using the formula `10 + self.constitution_modifier()`.
   - **Roll Ability (`roll_ability` method)**:
     - Roll four 6-sided dice using a list comprehension.
     - Remove the smallest roll using `rolls.remove(min(rolls))`.
     - Sum the remaining three rolls and return the result.
   - **Constitution Modifier (`constitution_modifier` method)**:
     - Compute the constitution modifier using the formula `(self.constitution - 10) // 2`.

### Usage Example

The example usage demonstrates creating a `Character` object and printing out the generated abilities and hitpoints. This simulates the process of generating a character for a game of Dungeons & Dragons.

To manage robot factory settings where each robot gets a unique, random name, we can follow these steps:

1. **Generate Random Names**: Ensure each robot gets a unique name consisting of two uppercase letters followed by three digits.
2. **Handle Name Collisions**: Keep track of all generated names to ensure no duplicates.
3. **Reset Functionality**: Allow resetting a robot's name, which involves generating a new unique name.

### Implementation Steps

1. **Random Name Generation**: Use the `random` module to generate random names.
2. **Track Generated Names**: Maintain a set of generated names to ensure uniqueness.
3. **Reset Robot**: Implement a method to reset the robot's name.

Here's the Python code for the `Robot` class:

```python
import random
import string

class Robot:
    existing_names = set()

    def __init__(self):
        self.name = self.generate_unique_name()

    def generate_unique_name(self):
        while True:
            name = self.generate_name()
            if name not in Robot.existing_names:
                Robot.existing_names.add(name)
                return name

    def generate_name(self):
        letters = ''.join(random.choices(string.ascii_uppercase, k=2))
        digits = ''.join(random.choices(string.digits, k=3))
        return letters + digits

    def reset(self):
        Robot.existing_names.discard(self.name)
        self.name = self.generate_unique_name()

# Example Usage:
robot = Robot()
print(robot.name)  # Outputs a unique robot name, e.g., "RX837"
robot.reset()
print(robot.name)  # Outputs a new unique robot name, e.g., "BC811"
```

### Explanation:

1. **Class Variable `existing_names`**: A set that keeps track of all names that have been generated to ensure uniqueness.
2. **Constructor (`__init__` method)**:
   - Initializes the robot with a unique name by calling `generate_unique_name`.
3. **Generate Unique Name (`generate_unique_name` method)**:
   - Generates names in a loop until a unique name (not present in `existing_names`) is found.
   - Adds the new unique name to the `existing_names` set and returns it.
4. **Generate Name (`generate_name` method)**:
   - Generates a random name with two uppercase letters followed by three digits using `random.choices`.
5. **Reset Method (`reset` method)**:
   - Removes the current name from the `existing_names` set.
   - Generates and assigns a new unique name to the robot.

This implementation ensures that each robot has a unique name and that the names are random, adhering to the requirements.


To implement the `PhoneNumber` class that cleans and validates user-entered phone numbers according to the North American Numbering Plan (NANP), we need to:

1. **Strip Punctuation and Spaces**: Remove all non-digit characters.
2. **Validate Length and Digits**: Ensure the cleaned number has the correct number of digits and starts with appropriate digits.
3. **Raise Exceptions for Invalid Numbers**: Handle various invalid scenarios as specified.

Here's the implementation:

```python
import re

class PhoneNumber:
    def __init__(self, number):
        # Remove all non-digit characters
        cleaned_number = re.sub(r'\D', '', number)

        # Validate the length of the number
        if len(cleaned_number) < 10:
            raise ValueError("must not be fewer than 10 digits")
        if len(cleaned_number) > 11:
            raise ValueError("must not be greater than 11 digits")
        if len(cleaned_number) == 11:
            if cleaned_number[0] != '1':
                raise ValueError("11 digits must start with 1")
            # Remove the leading '1' for valid 11-digit numbers
            cleaned_number = cleaned_number[1:]

        # Validate that the number has exactly 10 digits now
        if len(cleaned_number) != 10:
            raise ValueError("must be 10 digits")

        # Validate area code (first digit must be 2-9)
        if cleaned_number[0] in '01':
            raise ValueError("area code cannot start with zero or one")

        # Validate exchange code (fourth digit must be 2-9)
        if cleaned_number[3] in '01':
            raise ValueError("exchange code cannot start with zero or one")

        # Assign the cleaned and validated number to the instance variable
        self.number = cleaned_number

# Example Usage:
try:
    pn = PhoneNumber("+1 (613)-995-0253")
    print(pn.number)  # Outputs: 6139950253
except ValueError as e:
    print(e)

try:
    pn = PhoneNumber("123-456-7890")
    print(pn.number)
except ValueError as e:
    print(e)  # Outputs: area code cannot start with zero or one
```

### Explanation:

1. **Regex for Cleaning**: 
   - `re.sub(r'\D', '', number)` removes all non-digit characters from the input number.

2. **Length Validation**:
   - If the cleaned number has fewer than 10 digits, raise `ValueError("must not be fewer than 10 digits")`.
   - If the cleaned number has more than 11 digits, raise `ValueError("must not be greater than 11 digits")`.
   - If the cleaned number has 11 digits, ensure it starts with '1'. If not, raise `ValueError("11 digits must start with 1")`. If valid, remove the leading '1'.

3. **Code Validation**:
   - Ensure the area code (first digit) is between 2 and 9. If not, raise the appropriate `ValueError`.
   - Ensure the exchange code (fourth digit) is between 2 and 9. If not, raise the appropriate `ValueError`.

4. **Assignment**:
   - If all checks pass, assign the cleaned number to the instance variable `self.number`.

This implementation ensures the phone number is cleaned, validated, and stored correctly, adhering to the North American Numbering Plan (NANP) rules.

To determine whether two queens on a chessboard can attack each other, we need to consider the following:

1. **Same Row**: If both queens are on the same row, they can attack each other.
2. **Same Column**: If both queens are on the same column, they can attack each other.
3. **Same Diagonal**: If both queens are on the same diagonal, they can attack each other. There are two types of diagonals:
   - Positive slope diagonal: The difference between the row and column indices is the same for both queens.
   - Negative slope diagonal: The sum of the row and column indices is the same for both queens.

We also need to validate the positions of the queens to ensure they are within the bounds of the chessboard (0 to 7 for both rows and columns) and that they are not placed on the same spot.

### Implementation

1. **Validation**: Raise appropriate exceptions for invalid positions.
2. **Attack Check**: Implement the logic to check if the queens can attack each other based on the rules above.

Here is the implementation of the `Queen` class:

```python
class Queen:
    def __init__(self, row, column):
        if row < 0:
            raise ValueError("row not positive")
        if row > 7:
            raise ValueError("row not on board")
        if column < 0:
            raise ValueError("column not positive")
        if column > 7:
            raise ValueError("column not on board")
        
        self.row = row
        self.column = column

    def can_attack(self, another_queen):
        if self.row == another_queen.row and self.column == another_queen.column:
            raise ValueError("Invalid queen position: both queens in the same location")

        # Check same row
        if self.row == another_queen.row:
            return True
        
        # Check same column
        if self.column == another_queen.column:
            return True
        
        # Check same diagonal (positive slope and negative slope)
        if abs(self.row - another_queen.row) == abs(self.column - another_queen.column):
            return True

        return False

# Example Usage:
queen1 = Queen(3, 2)
queen2 = Queen(6, 5)
print(queen1.can_attack(queen2))  # Should print True (same diagonal)
```

### Explanation

1. **Constructor (`__init__` method)**:
   - Validates the row and column inputs to ensure they are within the valid range (0 to 7).
   - Raises appropriate `ValueError` exceptions with meaningful messages if the input is invalid.

2. **Attack Check (`can_attack` method)**:
   - Checks if both queens are at the same position and raises a `ValueError` if they are.
   - Checks if the queens are on the same row, same column, or the same diagonal.
   - Returns `True` if any of the conditions are met, indicating that the queens can attack each other.
   - Returns `False` otherwise.

This implementation ensures that the positions are validated and that the attack conditions are correctly checked, handling all specified edge cases and rules.

To transpose a matrix of text where rows become columns and columns become rows, we need to handle cases where rows have different lengths. The rules for padding and ensuring all characters are correctly transposed, including spaces, must be carefully followed.

### Steps:

1. **Find the maximum row length**: This will help us determine the number of columns in the transposed matrix.
2. **Pad the rows**: Pad each row to the left with spaces to make them all the same length.
3. **Transpose the matrix**: Convert rows into columns.

Here's the implementation:

```python
def transpose(lines):
    # Split the input into rows
    rows = lines.split('\n')
    
    # Find the maximum length of any row
    max_len = max(len(row) for row in rows)
    
    # Pad rows to the maximum length with spaces
    padded_rows = [row.ljust(max_len) for row in rows]
    
    # Transpose the matrix
    transposed_lines = [''.join(row[i] for row in padded_rows) for i in range(max_len)]
    
    # Join the transposed lines into a single string separated by newline characters
    return '\n'.join(transposed_lines)

# Example Usage:
input_text = "ABC\nDE"
output_text = transpose(input_text)
print(output_text)
```

### Explanation:

1. **Split the Input**: We first split the input text into individual rows using `split('\n')`.
2. **Find the Maximum Length**: Calculate the maximum length of the rows to determine how many columns the transposed matrix will have.
3. **Pad Rows**: Each row is padded to the maximum length using `ljust(max_len)`. This ensures that all rows have the same length by adding spaces to the right if necessary.
4. **Transpose**: We construct each row of the transposed matrix by collecting the i-th character from each padded row.
5. **Join Transposed Lines**: The transposed lines are joined back into a single string with newline characters separating the rows.

This approach ensures that the transposed matrix maintains the correct structure, including handling spaces correctly.

### Example:

For the input:

```
ABC
DE
```

The output will be:

```
AD
BE
C 
```

For the input:

```
AB
DEF
```

The output will be:

```
AD
BE
 F
```

This implementation handles the varying lengths of rows correctly by padding and ensures that the transposed output is as expected.

To implement the scoring for the game of Yacht, we need to define the scoring rules for each category. Each category has specific requirements, and the score is calculated based on those requirements.

Here’s how we can approach this:

1. **Define the Constants**: Define constants for each category.
2. **Implement the Scoring Function**: Write a function that calculates the score based on the category and the dice values.

### Scoring Categories and Their Logic

- **YACHT**: 50 points if all five dice show the same face.
- **ONES, TWOS, THREES, FOURS, FIVES, SIXES**: Sum of the dice that match the specified number.
- **FULL HOUSE**: Sum of the dice if there are three of one number and two of another.
- **FOUR OF A KIND**: Sum of the four dice that show the same face.
- **LITTLE STRAIGHT**: 30 points if the dice show 1-2-3-4-5.
- **BIG STRAIGHT**: 30 points if the dice show 2-3-4-5-6.
- **CHOICE**: Sum of all the dice.

### Implementation

Here’s the code to implement the above logic:

```python
# Score categories.
YACHT = "YACHT"
ONES = "ONES"
TWOS = "TWOS"
THREES = "THREES"
FOURS = "FOURS"
FIVES = "FIVES"
SIXES = "SIXES"
FULL_HOUSE = "FULL_HOUSE"
FOUR_OF_A_KIND = "FOUR_OF_A_KIND"
LITTLE_STRAIGHT = "LITTLE_STRAIGHT"
BIG_STRAIGHT = "BIG_STRAIGHT"
CHOICE = "CHOICE"

def score(dice, category):
    from collections import Counter
    
    counts = Counter(dice)
    if category == YACHT:
        return 50 if len(counts) == 1 else 0
    elif category == ONES:
        return counts[1] * 1
    elif category == TWOS:
        return counts[2] * 2
    elif category == THREES:
        return counts[3] * 3
    elif category == FOURS:
        return counts[4] * 4
    elif category == FIVES:
        return counts[5] * 5
    elif category == SIXES:
        return counts[6] * 6
    elif category == FULL_HOUSE:
        if sorted(counts.values()) == [2, 3]:
            return sum(dice)
        else:
            return 0
    elif category == FOUR_OF_A_KIND:
        for num, count in counts.items():
            if count >= 4:
                return num * 4
        return 0
    elif category == LITTLE_STRAIGHT:
        return 30 if sorted(dice) == [1, 2, 3, 4, 5] else 0
    elif category == BIG_STRAIGHT:
        return 30 if sorted(dice) == [2, 3, 4, 5, 6] else 0
    elif category == CHOICE:
        return sum(dice)
    else:
        raise ValueError("Invalid category")

# Example Usage:
print(score([4, 4, 4, 4, 4], YACHT))  # Should print 50
print(score([1, 1, 1, 4, 5], ONES))  # Should print 3
print(score([2, 2, 3, 4, 5], TWOS))  # Should print 4
print(score([3, 3, 3, 3, 3], THREES))  # Should print 15
print(score([1, 2, 3, 4, 5], LITTLE_STRAIGHT))  # Should print 30
print(score([2, 3, 4, 5, 6], BIG_STRAIGHT))  # Should print 30
print(score([3, 3, 3, 5, 5], FULL_HOUSE))  # Should print 19
print(score([4, 4, 4, 4, 6], FOUR_OF_A_KIND))  # Should print 16
print(score([2, 3, 3, 4, 6], CHOICE))  # Should print 18
```

### Explanation

1. **Counter**: Use `collections.Counter` to count occurrences of each die face.
2. **Category Checks**:
   - For **YACHT**, check if all dice are the same.
   - For **ONES, TWOS, THREES, FOURS, FIVES, SIXES**, multiply the count of the specific die face by its value.
   - For **FULL HOUSE**, check if the dice consist of three of one number and two of another.
   - For **FOUR OF A KIND**, check if there are at least four dice showing the same face and sum those four dice.
   - For **LITTLE STRAIGHT** and **BIG STRAIGHT**, check if the sorted dice match the required sequence.
   - For **CHOICE**, sum all the dice.

This implementation handles the scoring logic for each category as specified.


To solve the problem of counting the number of eggs based on the binary representation of a given decimal number, we need to:

1. Convert the decimal number to its binary representation.
2. Count the number of '1's in that binary representation.

### Steps:

1. **Convert Decimal to Binary**: Use Python's built-in `bin()` function which converts a number to its binary representation as a string.
2. **Count '1's**: Count the number of '1's in the binary string using the string method `count()`.

Here’s the implementation:

```python
def egg_count(display_value):
    # Convert the decimal number to its binary representation
    binary_representation = bin(display_value)
    
    # Count the number of '1's in the binary representation
    num_eggs = binary_representation.count('1')
    
    return num_eggs

# Example Usage:
print(egg_count(89))  # Should print 4
print(egg_count(16))  # Should print 1
```

### Explanation:

1. **`bin()` Function**:
   - The `bin()` function converts a decimal number to its binary representation prefixed with '0b'.
   - For example, `bin(89)` returns `'0b1011001'`.
   
2. **Counting '1's**:
   - We use the `count('1')` method to count the occurrences of '1' in the binary string.
   - For example, `'0b1011001'.count('1')` returns `4`.

### Example Walkthrough

For the input `89`:
- `bin(89)` gives `'0b1011001'`.
- The number of '1's in `'1011001'` is `4`.

For the input `16`:
- `bin(16)` gives `'0b10000'`.
- The number of '1's in `'10000'` is `1`.

This implementation correctly counts the number of eggs based on the encoded binary representation.

To solve the problem of finding saddle points in a matrix (where a saddle point is the largest in its row and smallest in its column), we need to:

1. **Validate the Matrix**: Ensure the matrix is not irregular (all rows should have the same number of columns).
2. **Find Row Maximums**: Determine the maximum value in each row.
3. **Find Column Minimums**: Determine the minimum value in each column.
4. **Identify Saddle Points**: Check which positions are both the row maximum and column minimum.

### Steps:

1. **Matrix Validation**:
   - Check if all rows have the same length. If not, raise a `ValueError`.

2. **Row Maximums**:
   - Iterate through each row to find the maximum value in that row.

3. **Column Minimums**:
   - Iterate through each column to find the minimum value in that column.

4. **Identify Saddle Points**:
   - A position is a saddle point if the value is both the maximum in its row and the minimum in its column.

Here’s the implementation in Python:

```python
def saddle_points(matrix):
    # Validate the matrix to ensure all rows have the same number of columns
    if len(matrix) == 0:
        return []

    num_columns = len(matrix[0])
    for row in matrix:
        if len(row) != num_columns:
            raise ValueError("irregular matrix")
    
    # Find the maximum values for each row
    row_max = [max(row) for row in matrix]
    
    # Find the minimum values for each column
    col_min = [min(col) for col in zip(*matrix)]
    
    # Find all saddle points
    saddle_points = []
    for i, row in enumerate(matrix):
        for j, value in enumerate(row):
            if value == row_max[i] and value == col_min[j]:
                saddle_points.append({"row": i + 1, "column": j + 1})
    
    return saddle_points

# Example Usage:
matrix = [
    [9, 8, 7, 8],
    [5, 3, 2, 4],
    [6, 6, 7, 1]
]
print(saddle_points(matrix))  # Should print [{'row': 2, 'column': 1}]
```

### Explanation:

1. **Validation**:
   - The function first checks if all rows have the same length. If any row has a different number of columns, it raises a `ValueError` with the message "irregular matrix".
   
2. **Row Maximums**:
   - For each row in the matrix, find the maximum value using `max(row)` and store these values in `row_max`.

3. **Column Minimums**:
   - Use `zip(*matrix)` to transpose the matrix and find the minimum value in each column using `min(col)`. Store these values in `col_min`.

4. **Identify Saddle Points**:
   - Iterate through each element in the matrix. If the element is equal to the maximum of its row and the minimum of its column, it is a saddle point. Append its position (1-indexed) to the `saddle_points` list.

The `saddle_points` function efficiently finds all saddle points in the given matrix, ensuring that the matrix is valid and handling irregular matrices by raising an appropriate exception.

To solve this problem, we need to convert a given 3x4 grid of pipes, underscores, and spaces into its corresponding string representation of numbers. We'll break the task into steps to handle individual numbers, multi-character binary strings, and finally multiple numbers across several lines.

### Step-by-Step Plan

1. **Check Input Validity**: Validate the input grid to ensure the number of rows is a multiple of 4 and the number of columns is a multiple of 3.
2. **Define OCR Patterns**: Define the patterns for each number from 0 to 9.
3. **Extract Characters from Grid**: Extract the individual characters from the grid based on the 3x4 size.
4. **Convert Characters to Numbers**: Convert the extracted characters to their corresponding numbers or a '?' if they are not recognizable.
5. **Handle Multiple Lines**: If there are multiple lines of numbers, join them with commas.

### Implementation

1. **Define the OCR Patterns**:
   - Create a dictionary to map the string representation of each digit to its corresponding number.

2. **Validation**:
   - Ensure the input grid dimensions are valid.

3. **Extract and Convert**:
   - Extract characters from the grid.
   - Convert each 3x4 block to the corresponding number.

4. **Handle Multi-line Input**:
   - Process each 4-row block separately.

Here’s the Python implementation:

```python
# Define the OCR patterns for digits 0-9
DIGIT_PATTERNS = {
    " _ | ||_|   ": "0",
    "     |  |   ": "1",
    " _  _||_    ": "2",
    " _  _| _|   ": "3",
    "   |_|  |   ": "4",
    " _ |_  _|   ": "5",
    " _ |_ |_|   ": "6",
    " _   |  |   ": "7",
    " _ |_||_|   ": "8",
    " _ |_| _|   ": "9",
}

def validate_input(lines):
    if len(lines) % 4 != 0:
        raise ValueError("Number of input lines is not a multiple of four")
    if any(len(line) % 3 != 0 for line in lines):
        raise ValueError("Number of input columns is not a multiple of three")

def extract_digit(lines, row, col):
    # Extract a 3x4 block starting at (row, col)
    return (
        lines[row][col:col+3] +
        lines[row+1][col:col+3] +
        lines[row+2][col:col+3] +
        lines[row+3][col:col+3]
    )

def convert_to_number(digit_str):
    return DIGIT_PATTERNS.get(digit_str, "?")

def convert(input_grid):
    lines = input_grid.split("\n")
    validate_input(lines)

    result_lines = []
    for row in range(0, len(lines), 4):
        result = ""
        for col in range(0, len(lines[row]), 3):
            digit_str = extract_digit(lines, row, col)
            result += convert_to_number(digit_str)
        result_lines.append(result)
    
    return ",".join(result_lines)

# Example Usage:
input_grid = (
    "    _  _     _  _  _  _  _  _ \n"
    "  | _| _||_||_ |_   ||_||_|| |\n"
    "  ||_  _|  | _||_|  ||_| _||_|\n"
    "                              \n"
    "    _  _ \n"
    "|_||_ |_ \n"
    "  | _||_|\n"
    "        \n"
    " _  _  _ \n"
    "  ||_||_|\n"
    "  ||_| _|\n"
    "        \n"
)
print(convert(input_grid))  # Should print "1234567890,456,789"
```

### Explanation

1. **Validation**: The `validate_input` function ensures the input grid has dimensions that are multiples of 4 rows and 3 columns.
2. **Extraction**: The `extract_digit` function extracts a 3x4 block of characters from the grid starting at a specified position.
3. **Conversion**: The `convert_to_number` function converts a 3x4 block to its corresponding number using the `DIGIT_PATTERNS` dictionary.
4. **Processing Multiple Lines**: The `convert` function processes each 4-row block of the input grid, converts the blocks to numbers, and joins the results with commas.

This implementation should handle various input cases, including single and multi-line inputs, while ensuring the input grid is valid and converting recognizable patterns correctly.

To implement the Robot simulator, we need to handle the robot's initial setup, directions, and movements. We'll define constants for the directions and a `Robot` class that will manage the robot's state and execute the instructions.

### Steps

1. **Define Directions**: Use constants to represent the directions (NORTH, EAST, SOUTH, WEST).
2. **Robot Initialization**: Initialize the robot with a starting direction and coordinates.
3. **Movement Methods**:
   - `turn_right()`: Update the robot's direction when turning right.
   - `turn_left()`: Update the robot's direction when turning left.
   - `advance()`: Move the robot one step forward in its current direction.
4. **Instruction Execution**: Implement a method to process a string of instructions and update the robot's state accordingly.

### Implementation

Let's define the directions and the `Robot` class with its methods:

```python
# Define directions
EAST = 'EAST'
NORTH = 'NORTH'
WEST = 'WEST'
SOUTH = 'SOUTH'

class Robot:
    def __init__(self, direction=NORTH, x_pos=0, y_pos=0):
        self.direction = direction
        self.x = x_pos
        self.y = y_pos

    def turn_right(self):
        if self.direction == NORTH:
            self.direction = EAST
        elif self.direction == EAST:
            self.direction = SOUTH
        elif self.direction == SOUTH:
            self.direction = WEST
        elif self.direction == WEST:
            self.direction = NORTH

    def turn_left(self):
        if self.direction == NORTH:
            self.direction = WEST
        elif self.direction == WEST:
            self.direction = SOUTH
        elif self.direction == SOUTH:
            self.direction = EAST
        elif self.direction == EAST:
            self.direction = NORTH

    def advance(self):
        if self.direction == NORTH:
            self.y += 1
        elif self.direction == EAST:
            self.x += 1
        elif self.direction == SOUTH:
            self.y -= 1
        elif self.direction == WEST:
            self.x -= 1

    def execute_instructions(self, instructions):
        for instruction in instructions:
            if instruction == 'R':
                self.turn_right()
            elif instruction == 'L':
                self.turn_left()
            elif instruction == 'A':
                self.advance()

# Example Usage:
robot = Robot(NORTH, 7, 3)
robot.execute_instructions("RAALAL")
print(robot.x, robot.y, robot.direction)  # Should print (9, 4, WEST)
```

### Explanation

1. **Direction Constants**: Define `EAST`, `NORTH`, `WEST`, and `SOUTH` as string constants.
2. **Initialization**: The `__init__` method initializes the robot with a direction and coordinates. Default is `NORTH` at (0, 0).
3. **Turn Methods**:
   - `turn_right()`: Changes the direction in a clockwise manner.
   - `turn_left()`: Changes the direction in a counterclockwise manner.
4. **Advance Method**: Moves the robot one step in its current direction by updating its x or y coordinates.
5. **Instruction Execution**: The `execute_instructions` method processes a string of instructions (`R`, `L`, `A`) to update the robot's direction and position accordingly.

This implementation provides a flexible and easy-to-understand way to simulate the robot's movements and ensures the robot's state is correctly updated based on the given instructions.

To implement the `School` class with the required functionality, we will:

1. **Initialize the School**: Use a dictionary to store students by grade.
2. **Add Students**: Implement a method to add a student to a specific grade.
3. **Retrieve Roster**: Implement a method to get a sorted list of all students.
4. **Retrieve Grade**: Implement a method to get all students in a specific grade.
5. **Check if Student is Added**: Implement a method to check if a student is already added to avoid duplicates.

### Implementation

Here’s the complete implementation of the `School` class:

```python
class School:
    def __init__(self):
        self.students_by_grade = {}

    def add_student(self, name, grade):
        if self.added(name):
            raise ValueError(f"Student {name} is already added to the roster.")
        
        if grade not in self.students_by_grade:
            self.students_by_grade[grade] = []
        
        self.students_by_grade[grade].append(name)
        self.students_by_grade[grade].sort()

    def roster(self):
        all_students = []
        for grade in sorted(self.students_by_grade.keys()):
            all_students.extend(self.students_by_grade[grade])
        return all_students

    def grade(self, grade_number):
        if grade_number not in self.students_by_grade:
            return []
        return self.students_by_grade[grade_number]

    def added(self, name):
        for students in self.students_by_grade.values():
            if name in students:
                return True
        return False

# Example Usage:
school = School()
school.add_student("Jim", 2)
school.add_student("Anna", 1)
school.add_student("Barb", 1)
school.add_student("Charlie", 1)
school.add_student("Alex", 2)
school.add_student("Peter", 2)
school.add_student("Zoe", 2)

print(school.roster())  # Should print ['Anna', 'Barb', 'Charlie', 'Alex', 'Peter', 'Zoe', 'Jim']
print(school.grade(2))  # Should print ['Alex', 'Jim', 'Peter', 'Zoe']
print(school.grade(1))  # Should print ['Anna', 'Barb', 'Charlie']
```

### Explanation

1. **Initialization (`__init__` method)**:
   - Initializes an empty dictionary `students_by_grade` to store students by their grades.

2. **Add Student (`add_student` method)**:
   - Checks if the student is already added using the `added` method.
   - Raises a `ValueError` if the student is already in the roster.
   - Adds the student to the appropriate grade and sorts the list of students in that grade.

3. **Retrieve Roster (`roster` method)**:
   - Creates a list of all students, sorted by grade and then alphabetically within each grade.
   - Uses `sorted(self.students_by_grade.keys())` to sort grades numerically.

4. **Retrieve Grade (`grade` method)**:
   - Returns the list of students in the specified grade.
   - If the grade does not exist in the dictionary, returns an empty list.

5. **Check if Student is Added (`added` method)**:
   - Iterates through all grades and checks if the student is already in any grade.
   - Returns `True` if the student is found, otherwise returns `False`.

This implementation ensures the school roster maintains the correct order and prevents duplicate student entries.

To implement the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit, we need to follow these steps:

1. **Initialize a List**: Create a list of boolean values where each index represents a number, and the value at that index indicates whether the number is prime.
2. **Mark Non-Primes**: Iterate through the list and mark the multiples of each prime as non-prime.
3. **Collect Primes**: Gather all indices that are still marked as prime.

Here's a step-by-step breakdown and the implementation in Python:

### Step-by-Step Implementation

1. **Initialize the List**:
   - Create a list of boolean values `is_prime` where the index represents the number. Initialize all values to `True`.
   - Set `is_prime[0]` and `is_prime[1]` to `False` since 0 and 1 are not prime.

2. **Mark Non-Primes**:
   - Start from the first prime number (2). For each prime, mark all its multiples as non-prime.
   - Continue this process for each subsequent number in the list that is still marked as prime.

3. **Collect Primes**:
   - Iterate through the list and collect the indices that are still marked as `True`.

### Implementation

```python
def primes(limit):
    if limit < 2:
        return []

    # Step 1: Initialize the list
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers

    # Step 2: Mark non-primes
    for num in range(2, int(limit ** 0.5) + 1):
        if is_prime[num]:
            for multiple in range(num * num, limit + 1, num):
                is_prime[multiple] = False

    # Step 3: Collect primes
    return [num for num in range(2, limit + 1) if is_prime[num]]

# Example Usage:
print(primes(30))  # Should print [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

### Explanation

1. **Initialization**:
   - We create a boolean list `is_prime` of size `limit + 1` and initialize all entries to `True`. We then set the entries for 0 and 1 to `False`.

2. **Marking Non-Primes**:
   - For each number `num` starting from 2 to the square root of `limit` (inclusive), if `is_prime[num]` is `True`, we mark all multiples of `num` (starting from `num * num`) as `False`.

3. **Collecting Primes**:
   - Finally, we use a list comprehension to collect all indices where `is_prime` is still `True`.

This implementation efficiently finds all prime numbers up to the given limit using the Sieve of Eratosthenes algorithm.

To find all Pythagorean triplets (a, b, c) such that \( a^2 + b^2 = c^2 \) and \( a + b + c = N \), we can follow these steps:

1. **Loop through potential values for a and b**: We need to find valid values of a, b, and c such that \( a < b < c \) and \( a + b + c = N \).
2. **Calculate c**: Given a and b, calculate c as \( c = N - a - b \).
3. **Check Pythagorean Condition**: Verify that the triplet (a, b, c) satisfies \( a^2 + b^2 = c^2 \).
4. **Collect Valid Triplets**: Store the valid triplets in a list and return them.

### Implementation

Here's the Python code implementing this approach:

```python
def triplets_with_sum(number):
    triplets = []
    for a in range(1, number // 3):
        for b in range(a + 1, number // 2):
            c = number - a - b
            if c > b and a * a + b * b == c * c:
                triplets.append([a, b, c])
    return triplets

# Example Usage:
print(triplets_with_sum(1000))  # Should print [[200, 375, 425]]
```

### Explanation

1. **Loop Through Values of a and b**:
   - We start with \( a \) from 1 to \( \frac{N}{3} \) because \( a \) has to be less than \( \frac{N}{3} \) to ensure \( a < b < c \).
   - For each \( a \), \( b \) starts from \( a + 1 \) to \( \frac{N}{2} \) because \( b \) has to be less than \( \frac{N}{2} \) to ensure \( b < c \).

2. **Calculate c**:
   - For each combination of \( a \) and \( b \), we compute \( c \) as \( c = N - a - b \).

3. **Check Pythagorean Condition**:
   - We check if \( a^2 + b^2 = c^2 \). If this condition is met, then \((a, b, c)\) forms a Pythagorean triplet.

4. **Store Valid Triplets**:
   - If \((a, b, c)\) is a valid triplet, we append it to the list of triplets.

5. **Return the List of Triplets**:
   - Finally, the function returns the list of all valid Pythagorean triplets.

This approach ensures that we find all Pythagorean triplets where \( a + b + c = N \) and \( a < b < c \).


To implement a circular buffer with custom exceptions for handling full and empty buffer conditions, we need to:

1. Define the `BufferFullException` and `BufferEmptyException` exceptions.
2. Implement the `CircularBuffer` class with the following methods:
   - `read`: Reads and removes the oldest data from the buffer.
   - `write`: Writes new data to the buffer if there's space available.
   - `overwrite`: Writes new data to the buffer, overwriting the oldest data if the buffer is full.
   - `clear`: Clears the buffer, removing all data.

Here's the complete implementation:

### Custom Exceptions

```python
class BufferFullException(BufferError):
    """Exception raised when CircularBuffer is full."""
    def __init__(self, message="Circular buffer is full"):
        self.message = message
        super().__init__(self.message)


class BufferEmptyException(BufferError):
    """Exception raised when CircularBuffer is empty."""
    def __init__(self, message="Circular buffer is empty"):
        self.message = message
        super().__init__(self.message)
```

### Circular Buffer

```python
class CircularBuffer:
    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0
        self.tail = 0
        self.size = 0

    def read(self):
        if self.size == 0:
            raise BufferEmptyException()
        data = self.buffer[self.head]
        self.buffer[self.head] = None
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return data

    def write(self, data):
        if self.size == self.capacity:
            raise BufferFullException()
        self.buffer[self.tail] = data
        self.tail = (self.tail + 1) % self.capacity
        self.size += 1

    def overwrite(self, data):
        if self.size == self.capacity:
            self.head = (self.head + 1) % self.capacity
        else:
            self.size += 1
        self.buffer[self.tail] = data
        self.tail = (self.tail + 1) % self.capacity

    def clear(self):
        self.buffer = [None] * self.capacity
        self.head = 0
        self.tail = 0
        self.size = 0
```

### Explanation

1. **Custom Exceptions**:
   - `BufferFullException` is raised when an attempt to write to a full buffer is made.
   - `BufferEmptyException` is raised when an attempt to read from an empty buffer is made.

2. **CircularBuffer Class**:
   - **Initialization (`__init__`)**: Sets up the buffer with a given capacity, initializes pointers (`head` and `tail`), and keeps track of the current size.
   - **Read (`read`)**: Reads and removes the oldest element from the buffer. Raises `BufferEmptyException` if the buffer is empty.
   - **Write (`write`)**: Adds a new element to the buffer if there is space. Raises `BufferFullException` if the buffer is full.
   - **Overwrite (`overwrite`)**: Adds a new element to the buffer, overwriting the oldest element if the buffer is full.
   - **Clear (`clear`)**: Resets the buffer to an empty state.

### Example Usage

```python
try:
    buffer = CircularBuffer(5)
    buffer.write('A')
    buffer.write('B')
    print(buffer.read())  # Outputs: 'A'
    buffer.write('C')
    buffer.write('D')
    buffer.write('E')
    buffer.write('F')  # Raises BufferFullException
except BufferFullException as e:
    print(e)

try:
    buffer.clear()
    print(buffer.read())  # Raises BufferEmptyException
except BufferEmptyException as e:
    print(e)
```

This implementation ensures that the circular buffer can handle reading, writing, and overwriting operations correctly, and raises meaningful exceptions when invalid operations are attempted.

To implement the `Matrix` class with methods to retrieve rows and columns from a given matrix string, we need to:

1. **Parse the Matrix String**: Convert the string representation of the matrix into a two-dimensional list (a list of lists).
2. **Implement the `row` Method**: Return a specific row based on the given index.
3. **Implement the `column` Method**: Return a specific column based on the given index.

### Steps to Implement

1. **Initialization**:
   - The constructor (`__init__`) will take the matrix string, split it by lines to get the rows, and then split each row by spaces to get individual elements. Convert these elements to integers and store them in a two-dimensional list.

2. **Row Method**:
   - The `row` method will return the row at the given index. Since indexing is zero-based, make sure to handle the conversion correctly.

3. **Column Method**:
   - The `column` method will extract the specified column from the matrix. This can be done by iterating over each row and selecting the element at the given column index.

### Implementation

Here's the complete implementation:

```python
class Matrix:
    def __init__(self, matrix_string):
        # Parse the matrix string into a list of lists (2D list)
        self.matrix = [
            [int(num) for num in row.split()]
            for row in matrix_string.split('\n')
        ]

    def row(self, index):
        # Return the row at the given index (convert to 1-based index)
        return self.matrix[index - 1]

    def column(self, index):
        # Return the column at the given index (convert to 1-based index)
        return [row[index - 1] for row in self.matrix]

# Example Usage:
matrix_string = "9 8 7\n5 3 2\n6 6 7"
matrix = Matrix(matrix_string)

print(matrix.row(1))    # Should print [9, 8, 7]
print(matrix.row(2))    # Should print [5, 3, 2]
print(matrix.column(1)) # Should print [9, 5, 6]
print(matrix.column(3)) # Should print [7, 2, 7]
```

### Explanation

1. **Initialization (`__init__` method)**:
   - Split the input `matrix_string` by newlines to get each row.
   - Split each row by spaces to get the individual numbers.
   - Convert each number to an integer and store the result in a two-dimensional list `self.matrix`.

2. **Row Method (`row` method)**:
   - Access the row at the given index (adjusting for zero-based indexing by subtracting 1 from the index).

3. **Column Method (`column` method)**:
   - Iterate through each row in `self.matrix` and collect the element at the specified column index (adjusting for zero-based indexing by subtracting 1 from the index).

This implementation correctly parses the matrix and provides the requested rows and columns using the `row` and `column` methods.

To create a `HighScores` class that manages a game player's high score list, we need to implement methods that provide the following functionalities:
1. **Return the highest score**.
2. **Return the last added score**.
3. **Return the top three highest scores**.

### Implementation Steps

1. **Initialization**: Store the list of scores.
2. **Methods**:
   - `latest()`: Return the last added score.
   - `personal_best()`: Return the highest score.
   - `personal_top_three()`: Return the top three highest scores, sorted in descending order.

### Implementation

Here is the complete implementation of the `HighScores` class:

```python
class HighScores:
    def __init__(self, scores):
        self.scores = scores

    def latest(self):
        # Return the last added score
        return self.scores[-1]

    def personal_best(self):
        # Return the highest score
        return max(self.scores)

    def personal_top_three(self):
        # Return the top three highest scores sorted in descending order
        return sorted(self.scores, reverse=True)[:3]

# Example Usage:
scores = [40, 100, 70, 90, 30]
high_scores = HighScores(scores)

print(high_scores.latest())          # Should print 30
print(high_scores.personal_best())   # Should print 100
print(high_scores.personal_top_three()) # Should print [100, 90, 70]
```

### Explanation

1. **Initialization (`__init__` method)**:
   - The constructor takes a list of scores and stores it in the `self.scores` attribute.

2. **Latest Score (`latest` method)**:
   - Returns the last element in the `self.scores` list using `self.scores[-1]`.

3. **Personal Best (`personal_best` method)**:
   - Uses the `max()` function to find and return the highest score in `self.scores`.

4. **Personal Top Three (`personal_top_three` method)**:
   - Uses the `sorted()` function to sort `self.scores` in descending order and slices the sorted list to get the top three scores.

This implementation correctly manages the high scores and provides the necessary methods to access the latest score, the highest score, and the top three highest scores.

To implement the `Garden` class, we need to perform the following steps:

1. **Initialization**:
   - Parse the input diagram to store the plants in a structured format.
   - Assign default students or use the provided list of students, sorted alphabetically.

2. **Mapping Plants**:
   - Map each character in the diagram to its corresponding plant name.

3. **Assign Plants to Students**:
   - Each student is assigned four plants (two from each row).

4. **Retrieve Plants for a Student**:
   - Implement a method to retrieve the list of plants for a given student.

### Steps and Implementation

1. **Define the Plant Mapping**:
   - Create a dictionary to map plant characters to plant names.

2. **Initialize the Garden**:
   - Parse the diagram string to store the rows.
   - Assign students, either default or from the provided list.
   - Ensure students are sorted alphabetically.

3. **Assign Plants**:
   - Split the diagram into rows.
   - Assign each student four cups based on their position.

### Implementation

Here's the complete implementation of the `Garden` class:

```python
class Garden:
    # Default list of students
    DEFAULT_STUDENTS = [
        "Alice", "Bob", "Charlie", "David", "Eve", "Fred", 
        "Ginny", "Harriet", "Ileana", "Joseph", "Kincaid", "Larry"
    ]
    
    # Plant character to name mapping
    PLANT_MAP = {
        'V': "Violets",
        'R': "Radishes",
        'C': "Clover",
        'G': "Grass"
    }
    
    def __init__(self, diagram, students=None):
        self.rows = diagram.split('\n')
        self.students = sorted(students) if students else self.DEFAULT_STUDENTS
    
    def plants(self, student):
        index = self.students.index(student)
        student_plants = (
            self.rows[0][2*index:2*index+2] + 
            self.rows[1][2*index:2*index+2]
        )
        return [self.PLANT_MAP[plant] for plant in student_plants]

# Example Usage:
garden = Garden("VRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV")
print(garden.plants("Alice"))  # Should print ['Violets', 'Radishes', 'Violets', 'Radishes']
print(garden.plants("Bob"))    # Should print ['Clover', 'Grass', 'Clover', 'Clover']

custom_garden = Garden("VRCC\nVCGG", students=["Valorie", "Raven"])
print(custom_garden.plants("Valorie"))  # Should print ['Violets', 'Radishes', 'Violets', 'Clover']
print(custom_garden.plants("Raven"))    # Should print ['Clover', 'Clover', 'Grass', 'Grass']
```

### Explanation

1. **Class Attributes**:
   - `DEFAULT_STUDENTS`: List of default student names.
   - `PLANT_MAP`: Dictionary mapping plant characters to their names.

2. **Initialization (`__init__` method)**:
   - Splits the input diagram into two rows.
   - Assigns the student list, sorting it alphabetically if provided, otherwise uses the default list.

3. **Plants Method (`plants` method)**:
   - Finds the index of the student in the sorted list.
   - Uses this index to extract the corresponding plants from both rows.
   - Maps the plant characters to their full names using `PLANT_MAP`.

This implementation ensures the `Garden` class correctly assigns and retrieves the plants for each student based on the provided diagram.

To implement the `recite` function for the song "Ten Green Bottles", we need to generate the verses of the song dynamically. Each verse follows a repetitive pattern with decreasing numbers of bottles.

### Steps

1. **Generate Verses**: Create a function that generates the verses for a given number of bottles.
2. **Handle Multiple Verses**: Generate multiple verses starting from a given number and decrementing for a specified count.
3. **Construct Verses**: Each verse follows the same pattern, with only the numbers changing.

### Implementation

Here is the implementation in Python:

```python
def recite(start, take=1):
    verses = []
    for i in range(start, start - take, -1):
        verses.append(generate_verse(i))
    return [line for verse in verses for line in verse]

def generate_verse(number):
    if number == 1:
        return [
            "One green bottle hanging on the wall,",
            "One green bottle hanging on the wall,",
            "And if one green bottle should accidentally fall,",
            "There'll be no green bottles hanging on the wall."
        ]
    else:
        next_number = number - 1
        next_bottles = f"{next_number} green bottles" if next_number != 1 else "one green bottle"
        return [
            f"{number} green bottles hanging on the wall,",
            f"{number} green bottles hanging on the wall,",
            "And if one green bottle should accidentally fall,",
            f"There'll be {next_bottles} hanging on the wall."
        ]

# Example Usage:
print(recite(10, 1))
print(recite(10, 2))
```

### Explanation

1. **recite Function**:
   - Takes `start` as the starting number of bottles and `take` as the number of verses to generate.
   - Generates the specified number of verses by calling `generate_verse` for each number, starting from `start` and decrementing by one for each subsequent verse.
   - Flattens the list of verses into a single list of lines.

2. **generate_verse Function**:
   - Takes the current number of bottles as input and returns the corresponding verse.
   - Handles the special case for when there is only one bottle left to ensure proper grammar in the verse.

### Example Usage

1. **Single Verse**:
   - `recite(10, 1)` will return the verse for 10 green bottles.
   
2. **Multiple Verses**:
   - `recite(10, 2)` will return the verses for 10 and 9 green bottles.

This implementation correctly handles generating the lyrics for "Ten Green Bottles" dynamically based on the starting number and the number of verses to generate.

To implement the `Allergies` class, we need to be able to:

1. Initialize the class with an allergy score.
2. Determine if the person is allergic to a specific item.
3. Provide a list of all the items the person is allergic to.

The score is a single integer that represents a combination of allergies, where each allergy has a specific value (power of 2). We can determine if the person is allergic to an item by checking if the corresponding bit is set in the score.

### Steps:

1. **Initialize the Allergies Class**:
   - Store the given score.
   - Define a mapping of allergens to their corresponding values.

2. **Determine if Allergic to an Item**:
   - Use bitwise operations to check if the corresponding bit for the allergen is set in the score.

3. **List All Allergies**:
   - Iterate through all allergens and use the `allergic_to` method to check if the person is allergic to each item.

### Implementation

Here's the complete implementation of the `Allergies` class:

```python
class Allergies:
    ALLERGENS = {
        "eggs": 1,
        "peanuts": 2,
        "shellfish": 4,
        "strawberries": 8,
        "tomatoes": 16,
        "chocolate": 32,
        "pollen": 64,
        "cats": 128
    }

    def __init__(self, score):
        self.score = score

    def allergic_to(self, item):
        return self.score & self.ALLERGENS[item] != 0

    @property
    def lst(self):
        return [item for item in self.ALLERGENS if self.allergic_to(item)]

# Example Usage:
allergies = Allergies(34)
print(allergies.allergic_to("peanuts"))  # Should print True
print(allergies.allergic_to("chocolate"))  # Should print True
print(allergies.allergic_to("cats"))  # Should print False
print(allergies.lst)  # Should print ['peanuts', 'chocolate']
```

### Explanation:

1. **Class Attribute `ALLERGENS`**:
   - A dictionary that maps each allergen to its corresponding value.

2. **Initialization (`__init__` method)**:
   - Takes an integer `score` and stores it as an instance attribute.

3. **Method `allergic_to`**:
   - Checks if the score includes the given allergen by using a bitwise AND operation (`&`).
   - Returns `True` if the person is allergic to the item, otherwise `False`.

4. **Property `lst`**:
   - A property method that returns a list of all allergens the person is allergic to.
   - Iterates through all items in `ALLERGENS` and uses the `allergic_to` method to check each one.

This implementation correctly determines a person's allergies based on the provided score and handles both individual allergy checks and generating a list of all allergies.

To implement the `Cipher` class, we need to create a cipher that can both encode and decode text using a shift-based method. We will also add support for using a custom key for the shift values. If no key is provided, the class should generate a random key of at least 100 lowercase characters.

### Steps for Implementation:

1. **Initialization**: Initialize the class with an optional key. If no key is provided, generate a random key.
2. **Generate Random Key**: Use Python's `random` module to generate a random key of at least 100 lowercase characters.
3. **Encoding**: Shift each character in the input text by the corresponding shift value derived from the key.
4. **Decoding**: Reverse the shift operation to retrieve the original text.

### Detailed Implementation

Here is the complete implementation of the `Cipher` class:

```python
import random
import string

class Cipher:
    def __init__(self, key=None):
        if key:
            if not all(char.islower() and char.isalpha() for char in key):
                raise ValueError("Key must consist of lowercase alphabetic characters only")
            self.key = key
        else:
            self.key = self._generate_random_key(100)
    
    def _generate_random_key(self, length):
        return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))
    
    def _shift_character(self, char, shift):
        return chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))
    
    def _unshift_character(self, char, shift):
        return chr(((ord(char) - ord('a') - shift) % 26) + ord('a'))
    
    def encode(self, text):
        encoded_text = []
        for i, char in enumerate(text):
            shift = ord(self.key[i % len(self.key)]) - ord('a')
            encoded_char = self._shift_character(char, shift)
            encoded_text.append(encoded_char)
        return ''.join(encoded_text)
    
    def decode(self, text):
        decoded_text = []
        for i, char in enumerate(text):
            shift = ord(self.key[i % len(self.key)]) - ord('a')
            decoded_char = self._unshift_character(char, shift)
            decoded_text.append(decoded_char)
        return ''.join(decoded_text)

# Example Usage:
cipher = Cipher("ddddddddddddddddd")
encoded_text = cipher.encode("iamapandabear")
print(encoded_text)  # Should print 'ldpdsdqgdehdu'
decoded_text = cipher.decode(encoded_text)
print(decoded_text)  # Should print 'iamapandabear'

random_cipher = Cipher()
random_encoded_text = random_cipher.encode("iamapandabear")
print(random_encoded_text)  # Encoded with random key
random_decoded_text = random_cipher.decode(random_encoded_text)
print(random_decoded_text)  # Should print 'iamapandabear'
```

### Explanation:

1. **Initialization (`__init__` method)**:
   - If a key is provided, it validates that the key consists only of lowercase alphabetic characters.
   - If no key is provided, it generates a random key of at least 100 lowercase characters.

2. **Random Key Generation (`_generate_random_key` method)**:
   - Generates a string of the specified length consisting of random lowercase alphabetic characters.

3. **Character Shifting Methods**:
   - `_shift_character`: Shifts a character forward by the specified number of positions.
   - `_unshift_character`: Shifts a character backward by the specified number of positions.

4. **Encoding (`encode` method)**:
   - Iterates through each character in the input text.
   - Calculates the shift value based on the corresponding character in the key.
   - Shifts the character forward and appends it to the result.

5. **Decoding (`decode` method)**:
   - Iterates through each character in the encoded text.
   - Calculates the shift value based on the corresponding character in the key.
   - Shifts the character backward and appends it to the result.

This implementation handles both encoding and decoding using a shift-based method and supports the use of a custom key. If no key is provided, it generates a random key to ensure the cipher is functional.

To determine the best poker hand(s) from a list of hands, we need to evaluate each hand according to the rules of poker. Here’s a step-by-step approach:

1. **Parse Each Hand**: Convert each hand from string representation to a structured format that we can easily evaluate.
2. **Rank Each Hand**: Determine the rank of each hand according to poker hand rankings (e.g., straight flush, four of a kind, full house, etc.).
3. **Compare Hands**: Compare hands to determine the best one(s).
4. **Return Best Hand(s)**: Return the hand(s) with the highest ranking.

### Poker Hand Rankings

From highest to lowest, poker hands are ranked as follows:
1. Royal Flush
2. Straight Flush
3. Four of a Kind
4. Full House
5. Flush
6. Straight
7. Three of a Kind
8. Two Pair
9. One Pair
10. High Card

### Detailed Implementation

Let's implement this step by step.

1. **Parse and Rank Each Hand**: 
   - Create functions to parse and rank hands.

2. **Hand Evaluation Functions**: 
   - Functions to check for each hand ranking.

3. **Comparing Hands**:
   - Compare based on the rank and then the card values if necessary.

### Implementation

Here is the complete implementation:

```python
from collections import Counter

def best_hands(hands):
    parsed_hands = [parse_hand(hand) for hand in hands]
    ranked_hands = [(hand, rank_hand(hand)) for hand in parsed_hands]
    max_rank = max(r[1] for r in ranked_hands)
    return [" ".join(format_hand(h)) for h, r in ranked_hands if r == max_rank]

def parse_hand(hand):
    rank_map = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 
                'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}
    cards = hand.split()
    return [(rank_map[card[0]], card[1]) for card in cards]

def format_hand(hand):
    rank_map = {2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 
                10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A'}
    return [f"{rank_map[rank]}{suit}" for rank, suit in hand]

def rank_hand(hand):
    hand = sorted(hand, reverse=True)
    ranks = [rank for rank, suit in hand]
    suits = [suit for rank, suit in hand]
    rank_counts = Counter(ranks)
    counts = sorted(rank_counts.values(), reverse=True)
    
    if is_straight(ranks) and is_flush(suits):
        return (8 if ranks[0] == 14 and ranks[1] == 5 else 9, ranks)
    if counts == [4, 1]:
        return (7, find_rank_by_count(rank_counts, 4), find_rank_by_count(rank_counts, 1))
    if counts == [3, 2]:
        return (6, find_rank_by_count(rank_counts, 3), find_rank_by_count(rank_counts, 2))
    if is_flush(suits):
        return (5, ranks)
    if is_straight(ranks):
        return (4, ranks)
    if counts == [3, 1, 1]:
        return (3, find_rank_by_count(rank_counts, 3), sorted(find_ranks_by_count(rank_counts, 1), reverse=True))
    if counts == [2, 2, 1]:
        pairs = find_ranks_by_count(rank_counts, 2)
        kicker = find_rank_by_count(rank_counts, 1)
        return (2, sorted(pairs, reverse=True), kicker)
    if counts == [2, 1, 1, 1]:
        return (1, find_rank_by_count(rank_counts, 2), sorted(find_ranks_by_count(rank_counts, 1), reverse=True))
    return (0, ranks)

def is_flush(suits):
    return len(set(suits)) == 1

def is_straight(ranks):
    return ranks == list(range(ranks[0], ranks[0] - 5, -1)) or ranks == [14, 5, 4, 3, 2]

def find_rank_by_count(rank_counts, count):
    return next(rank for rank, cnt in rank_counts.items() if cnt == count)

def find_ranks_by_count(rank_counts, count):
    return [rank for rank, cnt in rank_counts.items() if cnt == count]

# Example Usage
hands = ["4S 5S 7H 8D JC", "2S 4S 7H 8D JC", "2S 4S 5H 8D 8C"]
print(best_hands(hands))  # Should output the best hand(s) among the provided
```

### Explanation:

1. **Parsing Hands**:
   - `parse_hand` converts the string representation of a hand into a list of tuples where the first element is the rank (converted to an integer) and the second element is the suit.

2. **Formatting Hands**:
   - `format_hand` converts the parsed hand back into string format.

3. **Ranking Hands**:
   - `rank_hand` evaluates the hand and returns a tuple representing its rank. The rank tuple can be compared to determine the best hand.

4. **Checking Hand Types**:
   - `is_flush` checks if all cards have the same suit.
   - `is_straight` checks if the cards form a sequence.
   - `find_rank_by_count` and `find_ranks_by_count` find ranks by their occurrence counts in the hand.

5. **Finding the Best Hands**:
   - `best_hands` finds and returns the hands with the highest rank.

This approach ensures that we correctly identify and compare poker hands to determine the best hand(s) from a list.

To implement the classic method of composing secret messages called a square code, we need to follow these steps:

1. **Normalize the Input**: Remove all spaces and punctuation, and convert all characters to lowercase.
2. **Determine the Rectangle Dimensions**: Find the smallest possible rectangle (r x c) such that:
   - \( r \times c \geq \text{length of the message} \)
   - \( c \geq r \)
   - \( c - r \leq 1 \)
3. **Organize Text into Rectangle**: Arrange the normalized text into rows of the rectangle.
4. **Encode the Message**: Read down the columns to form the encoded message.
5. **Format the Output**: Split the encoded message into chunks of length `c`, separated by spaces.

### Implementation

Let's implement these steps in the `cipher_text` function:

```python
import math
import re

def normalize_text(text):
    return re.sub(r'[^a-zA-Z0-9]', '', text).lower()

def determine_rectangle_dimensions(length):
    c = math.ceil(math.sqrt(length))
    r = c - 1 if (c * (c - 1)) >= length else c
    return r, c

def organize_into_rectangle(text, r, c):
    rectangle = []
    for i in range(r):
        start = i * c
        rectangle.append(text[start:start + c].ljust(c))
    return rectangle

def encode_rectangle(rectangle, r, c):
    encoded = []
    for col in range(c):
        column_chars = [rectangle[row][col] for row in range(r)]
        encoded.append(''.join(column_chars))
    return ' '.join(encoded)

def cipher_text(plain_text):
    normalized = normalize_text(plain_text)
    if not normalized:
        return ''
    
    length = len(normalized)
    r, c = determine_rectangle_dimensions(length)
    rectangle = organize_into_rectangle(normalized, r, c)
    return encode_rectangle(rectangle, r, c)

# Example Usage
plain_text = "If man was meant to stay on the ground, god would have given us roots."
print(cipher_text(plain_text))  # Should print the encoded message in the required format
```

### Explanation

1. **Normalize the Input**:
   - `normalize_text` function removes all non-alphanumeric characters using a regular expression and converts the string to lowercase.

2. **Determine the Rectangle Dimensions**:
   - `determine_rectangle_dimensions` function calculates `c` as the ceiling of the square root of the length of the normalized text. It adjusts `r` to be either `c` or `c-1` based on the total area needed.

3. **Organize Text into Rectangle**:
   - `organize_into_rectangle` function splits the normalized text into rows, padding the last row with spaces if necessary to ensure each row has exactly `c` characters.

4. **Encode the Message**:
   - `encode_rectangle` function reads down the columns to form the encoded message, joining each column's characters together and separating the columns by spaces.

5. **Output**:
   - The `cipher_text` function ties everything together, processing the input text and returning the encoded message.

This implementation handles the normalization, organization, and encoding processes to generate the required encoded message in the correct format.

To implement a `Clock` class that handles times without dates, allows addition and subtraction of minutes, and ensures two clocks with the same time are equal, we need to implement several methods. These include the constructor, string representations, equality comparison, and addition/subtraction of minutes.

### Implementation Steps

1. **Constructor**: Initialize the clock with hours and minutes.
2. **Normalize Time**: Ensure the time is always valid (e.g., 25:70 should be normalized to 02:10).
3. **String Representation**: Implement `__repr__` and `__str__` for debugging and human-readable output.
4. **Equality Check**: Implement `__eq__` to check if two clocks show the same time.
5. **Addition and Subtraction**: Implement `__add__` and `__sub__` to handle addition and subtraction of minutes.

### Implementation

Here's the complete implementation of the `Clock` class:

```python
class Clock:
    def __init__(self, hour, minute):
        total_minutes = hour * 60 + minute
        self.hour = (total_minutes // 60) % 24
        self.minute = total_minutes % 60

    def __repr__(self):
        return f"Clock({self.hour}, {self.minute})"

    def __str__(self):
        return f"{self.hour:02}:{self.minute:02}"

    def __eq__(self, other):
        return self.hour == other.hour and self.minute == other.minute

    def __add__(self, minutes):
        return Clock(self.hour, self.minute + minutes)

    def __sub__(self, minutes):
        return Clock(self.hour, self.minute - minutes)

# Example Usage
clock1 = Clock(10, 45)
clock2 = Clock(10, 45)
clock3 = Clock(11, 15)

print(clock1)          # Should print "10:45"
print(repr(clock1))    # Should print "Clock(10, 45)"
print(clock1 == clock2) # Should print True
print(clock1 == clock3) # Should print False

clock4 = clock1 + 30   # Adds 30 minutes to clock1
print(clock4)          # Should print "11:15"

clock5 = clock1 - 50   # Subtracts 50 minutes from clock1
print(clock5)          # Should print "09:55"
```

### Explanation

1. **Constructor (`__init__` method)**:
   - Converts the given hour and minute into total minutes to simplify normalization.
   - Calculates the normalized hour and minute using modulo operations to ensure valid time.

2. **String Representation**:
   - `__repr__`: Returns a string that can be used to recreate the object.
   - `__str__`: Returns a human-readable string in `HH:MM` format.

3. **Equality Check (`__eq__` method)**:
   - Compares the hour and minute of the current object with another `Clock` object.

4. **Addition and Subtraction**:
   - `__add__`: Adds a given number of minutes to the current time and returns a new `Clock` object.
   - `__sub__`: Subtracts a given number of minutes from the current time and returns a new `Clock` object.

This implementation ensures that the `Clock` class correctly handles time normalization, supports string representations for debugging and display, allows equality comparison, and supports arithmetic operations for modifying the time.

To count the rectangles in an ASCII diagram, we need to identify all the potential rectangles formed by `+` characters connected by `-` and `|` characters. This involves checking all possible pairs of corners that could form the opposite corners of a rectangle and ensuring that the sides between these corners are valid.

Here's a step-by-step breakdown of how to implement this:

1. **Identify Corner Points**: First, identify all the `+` characters since they represent the potential corners of rectangles.
2. **Check for Valid Rectangles**: For each pair of corners, check if they can form a valid rectangle by verifying the sides.
3. **Count Valid Rectangles**: Maintain a count of all valid rectangles found.

### Implementation

Here is the complete implementation of the `rectangles` function:

```python
def rectangles(strings):
    def is_corner(c):
        return c == '+'

    def is_horizontal_edge(c):
        return c == '-' or c == '+'

    def is_vertical_edge(c):
        return c == '|' or c == '+'

    def is_valid_rectangle(x1, y1, x2, y2):
        if x1 == x2 or y1 == y2:
            return False
        # Check top and bottom edges
        for x in range(x1, x2 + 1):
            if not is_horizontal_edge(strings[y1][x]) or not is_horizontal_edge(strings[y2][x]):
                return False
        # Check left and right edges
        for y in range(y1, y2 + 1):
            if not is_vertical_edge(strings[y][x1]) or not is_vertical_edge(strings[y][x2]):
                return False
        return True

    rows = len(strings)
    cols = len(strings[0])
    corners = [(x, y) for y in range(rows) for x in range(cols) if is_corner(strings[y][x])]
    rectangle_count = 0

    for i in range(len(corners)):
        for j in range(i + 1, len(corners)):
            x1, y1 = corners[i]
            x2, y2 = corners[j]
            if is_valid_rectangle(x1, y1, x2, y2):
                rectangle_count += 1

    return rectangle_count

# Example Usage:
diagram = [
    "   +--+",
    "  ++  |",
    "+-++--+",
    "|  |  |",
    "+--+--+"
]

print(rectangles(diagram))  # Should print the count of rectangles
```

### Explanation

1. **Helper Functions**:
   - `is_corner(c)`: Returns `True` if the character is a `+`.
   - `is_horizontal_edge(c)`: Returns `True` if the character is `-` or `+`.
   - `is_vertical_edge(c)`: Returns `True` if the character is `|` or `+`.

2. **Valid Rectangle Check** (`is_valid_rectangle`):
   - Checks if two corner points `(x1, y1)` and `(x2, y2)` can form a valid rectangle by verifying the horizontal edges (top and bottom) and vertical edges (left and right) between them.

3. **Counting Rectangles**:
   - Identifies all potential corners.
   - For each pair of corners, checks if they can form a valid rectangle.
   - Increments the count for each valid rectangle found.

This implementation correctly identifies and counts all the rectangles in the given ASCII diagram.

To create a linked list that can be used as a playlist feature for a music player application, we will implement the `Node` and `LinkedList` classes. The `LinkedList` class should support operations such as adding elements (`push`), removing elements (`pop`), retrieving the length, and reversing the list.

### Implementation Steps

1. **Node Class**: Each node will store a value and a reference to the next node.
2. **LinkedList Class**:
   - Initialize the list with optional values.
   - Implement `__len__` to return the length of the list.
   - Implement `head` to return the first node.
   - Implement `push` to add a value to the beginning of the list.
   - Implement `pop` to remove and return the value from the beginning of the list.
   - Implement `reversed` to return a new `LinkedList` with the elements in reverse order.
3. **EmptyListException**: Custom exception to handle operations on an empty list.

### Implementation

Here is the complete code:

```python
class Node:
    def __init__(self, value, next_node=None):
        self._value = value
        self._next = next_node

    def value(self):
        return self._value

    def next(self):
        return self._next

class LinkedList:
    def __init__(self, values=[]):
        self._head = None
        self._size = 0
        for value in values:
            self.push(value)

    def __len__(self):
        return self._size

    def head(self):
        if self._head is None:
            raise EmptyListException("The list is empty")
        return self._head

    def push(self, value):
        new_node = Node(value, self._head)
        self._head = new_node
        self._size += 1

    def pop(self):
        if self._head is None:
            raise EmptyListException("The list is empty")
        value = self._head.value()
        self._head = self._head.next()
        self._size -= 1
        return value

    def reversed(self):
        reversed_list = LinkedList()
        current = self._head
        while current:
            reversed_list.push(current.value())
            current = current.next()
        return reversed_list

class EmptyListException(Exception):
    pass

# Example Usage
try:
    playlist = LinkedList([1, 2, 3, 4])
    print(f"Initial Playlist Length: {len(playlist)}")
    print(f"Head of Playlist: {playlist.head().value()}")
    playlist.push(5)
    print(f"New Head after Push: {playlist.head().value()}")
    print(f"Popped Value: {playlist.pop()}")
    print(f"Head after Pop: {playlist.head().value()}")
    reversed_playlist = playlist.reversed()
    current = reversed_playlist.head()
    reversed_values = []
    while current:
        reversed_values.append(current.value())
        current = current.next()
    print(f"Reversed Playlist: {reversed_values}")
except EmptyListException as e:
    print(e)
```

### Explanation

1. **Node Class**:
   - Initializes with a value and an optional next node reference.
   - Provides methods to access the value and the next node.

2. **LinkedList Class**:
   - **Initialization (`__init__`)**: Initializes an empty list or populates it with given values using the `push` method.
   - **Length (`__len__`)**: Returns the number of nodes in the list.
   - **Head (`head`)**: Returns the first node of the list, raises `EmptyListException` if the list is empty.
   - **Push (`push`)**: Adds a new value to the beginning of the list, updating the head and size.
   - **Pop (`pop`)**: Removes and returns the value from the beginning of the list, updating the head and size, raises `EmptyListException` if the list is empty.
   - **Reversed (`reversed`)**: Creates and returns a new `LinkedList` with the elements in reverse order.

3. **EmptyListException**:
   - Custom exception to handle empty list scenarios.

This implementation provides a functional singly linked list with the required operations for the playlist feature.

To refactor the `BuildTree` function, we need to make it more efficient, readable, and concise while ensuring that it still properly handles various edge cases and raises meaningful error messages when necessary. Here’s a structured approach to achieve this:

1. **Input Validation**: Ensure all records are valid and in the correct format.
2. **Building the Nodes**: Create a dictionary of nodes for quick access.
3. **Linking Nodes**: Establish parent-child relationships based on the `parent_id`.

### Refactored Implementation

```python
class Record:
    def __init__(self, record_id, parent_id):
        self.record_id = record_id
        self.parent_id = parent_id


class Node:
    def __init__(self, node_id):
        self.node_id = node_id
        self.children = []


def BuildTree(records):
    if not records:
        return None
    
    # Sort records by record_id
    records.sort(key=lambda x: x.record_id)

    # Check for valid records
    for i, record in enumerate(records):
        if record.record_id != i:
            raise ValueError(f"Record ID {record.record_id} is not in the correct order or missing")
        if record.record_id == 0 and record.parent_id != 0:
            raise ValueError("Root record's parent_id must be 0")
        if record.record_id != 0 and record.record_id <= record.parent_id:
            raise ValueError(f"Record ID {record.record_id} has an invalid parent_id {record.parent_id}")

    # Create a dictionary to hold nodes
    nodes = {record.record_id: Node(record.record_id) for record in records}
    root = nodes[0]

    # Link nodes to their parents
    for record in records:
        if record.record_id != 0:
            parent_node = nodes[record.parent_id]
            parent_node.children.append(nodes[record.record_id])

    return root

# Example Usage
try:
    records = [
        Record(0, 0),
        Record(1, 0),
        Record(2, 1),
        Record(3, 0),
        Record(4, 1),
        Record(5, 0),
        Record(6, 3)
    ]
    tree = BuildTree(records)
    print(tree.node_id)  # Should print the root node ID
except ValueError as e:
    print(e)
```

### Explanation

1. **Input Validation**:
   - **Empty List**: If there are no records, return `None`.
   - **Sort Records**: Sort the records by `record_id` to ensure they are in the correct order.
   - **Check for Gaps**: Ensure each `record_id` matches its position in the sorted list to avoid gaps.
   - **Root Validation**: Ensure the root's `parent_id` is 0.
   - **Parent-Child Relationship**: Validate that no non-root record has a `parent_id` greater than or equal to its `record_id`.

2. **Building the Nodes**:
   - Create a dictionary to store nodes, which allows quick access by `record_id`.
   - Initialize the `Node` instances for each record.

3. **Linking Nodes**:
   - Link each node to its parent node by appending it to the parent's `children` list.
   - Skip linking for the root node since it has no parent.

4. **Exception Handling**:
   - Raises `ValueError` with meaningful messages when encountering invalid records.

This refactored implementation is more efficient and readable while correctly handling the construction of the tree and validation of the input records.

To implement the `ConnectGame` class that determines the winner in a game of Hex, we need to simulate the connectivity of the stones placed by each player. Here’s the plan:

1. **Initialization**: Parse the board from the input string.
2. **Determine the Winner**: Implement methods to check connectivity from top to bottom for player 'O' and from left to right for player 'X'.

### Steps to Implement

1. **Parse the Board**: Convert the input board string into a 2D list for easier manipulation.
2. **Depth-First Search (DFS)**: Use DFS to explore if there’s a connected path for 'O' from the top to the bottom and for 'X' from the left to the right.
3. **Boundary Conditions**: Define boundaries for each player to determine the starting and ending points of their respective paths.

### Implementation

Here is the complete implementation of the `ConnectGame` class:

```python
class ConnectGame:
    def __init__(self, board):
        self.board = [list(line) for line in board.splitlines()]
        self.rows = len(self.board)
        self.cols = len(self.board[0]) if self.rows > 0 else 0

    def get_winner(self):
        if self.has_path('O'):
            return 'O'
        if self.has_path('X'):
            return 'X'
        return None

    def has_path(self, player):
        if player == 'O':
            for col in range(self.cols):
                if self.board[0][col] == 'O' and self.dfs(0, col, player, set()):
                    return True
        if player == 'X':
            for row in range(self.rows):
                if self.board[row][0] == 'X' and self.dfs(row, 0, player, set()):
                    return True
        return False

    def dfs(self, row, col, player, visited):
        if player == 'O' and row == self.rows - 1:
            return True
        if player == 'X' and col == self.cols - 1:
            return True
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, 1), (1, -1)]
        visited.add((row, col))
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            if (0 <= new_row < self.rows and 0 <= new_col < self.cols and 
                self.board[new_row][new_col] == player and 
                (new_row, new_col) not in visited):
                if self.dfs(new_row, new_col, player, visited):
                    return True
        return False

# Example Usage
board = [
    ". O . X .",
    " . X X O .",
    "  O O O X .",
    "   . X O X O",
    "    X O O O X"
]
game = ConnectGame("\n".join(board))
print(game.get_winner())  # Should print 'O'
```

### Explanation

1. **Initialization (`__init__` method)**:
   - The board is parsed from a string into a 2D list of characters for easier manipulation.

2. **Determine the Winner (`get_winner` method)**:
   - Checks if player 'O' has a connected path from the top to the bottom.
   - Checks if player 'X' has a connected path from the left to the right.
   - Returns the player who has a winning path or `None` if there is no winner.

3. **Check Connectivity (`has_path` method)**:
   - For player 'O', starts DFS from the top row.
   - For player 'X', starts DFS from the left column.

4. **Depth-First Search (`dfs` method)**:
   - Uses DFS to explore all possible paths.
   - Checks boundary conditions to see if the path completes the player's connection.
   - Uses a set to keep track of visited positions to avoid cycles.

This implementation effectively determines the winner of the Hex game by checking the connectivity of the stones placed by each player.

To implement a function that converts a number represented in one base to another base, we'll need to perform the following steps:

1. **Validate the Input**: Ensure the bases are valid and the digits are appropriate for the input base.
2. **Convert to Base 10**: Convert the number from the input base to a base-10 (decimal) integer.
3. **Convert from Base 10 to Output Base**: Convert the base-10 integer to the desired output base.

### Detailed Steps

1. **Validate Input**:
   - Ensure the input and output bases are greater than or equal to 2.
   - Ensure all digits are valid for the given input base.

2. **Convert to Base 10**:
   - Use positional notation to convert the digits from the input base to a base-10 integer.

3. **Convert from Base 10 to Output Base**:
   - Repeatedly divide the base-10 integer by the output base and collect the remainders.
   - The remainders (in reverse order) represent the number in the output base.

### Implementation

Here's the implementation of the `rebase` function:

```python
def rebase(input_base, digits, output_base):
    if input_base < 2:
        raise ValueError("input base must be >= 2")
    if output_base < 2:
        raise ValueError("output base must be >= 2")
    
    if any(d < 0 or d >= input_base for d in digits):
        raise ValueError("all digits must satisfy 0 <= d < input base")
    
    # Step 1: Convert input digits to a base-10 integer
    number_in_base_10 = 0
    for digit in digits:
        number_in_base_10 = number_in_base_10 * input_base + digit
    
    # Step 2: Convert base-10 integer to the output base
    if number_in_base_10 == 0:
        return [0]
    
    output_digits = []
    while number_in_base_10 > 0:
        output_digits.append(number_in_base_10 % output_base)
        number_in_base_10 //= output_base
    
    return output_digits[::-1]

# Example Usage:
print(rebase(2, [1, 0, 1, 0, 1, 0], 10))  # Should output [4, 2]
print(rebase(10, [4, 2], 2))  # Should output [1, 0, 1, 0, 1, 0]
```

### Explanation

1. **Input Validation**:
   - Raise `ValueError` if the input base or output base is less than 2.
   - Raise `ValueError` if any digit is not in the range `[0, input_base)`.

2. **Convert to Base 10**:
   - Initialize `number_in_base_10` to 0.
   - Iterate through the digits, updating `number_in_base_10` using positional notation.

3. **Convert from Base 10 to Output Base**:
   - If the number is 0, return `[0]`.
   - Otherwise, repeatedly divide the number by the output base, storing the remainders.
   - Reverse the list of remainders to get the correct order of digits in the output base.

This function effectively converts a number from any given base to another base, handling input validation and performing the necessary base conversions step by step.

To solve the Minesweeper problem, we need to transform a given board by adding mine counts to empty squares. Here's a step-by-step plan for implementing this:

1. **Input Validation**: Ensure the board is valid.
2. **Initialize a Result Board**: Create a board to store the result.
3. **Count Mines**: For each empty cell, count the adjacent mines.
4. **Update the Result Board**: Update the board with mine counts.

### Steps

1. **Input Validation**:
   - Check if all rows have the same length.
   - Ensure only valid characters (' ' and '*') are present.

2. **Initialize a Result Board**:
   - Create a board that will store the updated values.

3. **Count Mines**:
   - For each cell in the board, count the mines in the adjacent cells.

4. **Update the Result Board**:
   - If a cell is a mine, copy it directly.
   - If a cell is empty, replace it with the count of adjacent mines.

### Implementation

Here's the implementation of the `annotate` function:

```python
def annotate(minefield):
    if not minefield:
        return []

    # Validate input
    row_length = len(minefield[0])
    for row in minefield:
        if len(row) != row_length:
            raise ValueError("The board is invalid with current input.")
        if any(char not in " *" for char in row):
            raise ValueError("The board is invalid with current input.")

    def count_adjacent_mines(x, y):
        directions = [(-1, -1), (-1, 0), (-1, 1),
                      (0, -1),           (0, 1),
                      (1, -1), (1, 0), (1, 1)]
        count = 0
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(minefield) and 0 <= ny < len(minefield[0]):
                if minefield[nx][ny] == '*':
                    count += 1
        return count

    result = []
    for i in range(len(minefield)):
        result_row = []
        for j in range(len(minefield[0])):
            if minefield[i][j] == '*':
                result_row.append('*')
            else:
                mine_count = count_adjacent_mines(i, j)
                result_row.append(str(mine_count) if mine_count > 0 else ' ')
        result.append("".join(result_row))

    return result

# Example Usage
minefield = [
    "·*·*·",
    "··*··",
    "··*··",
    "·····"
]
minefield = [row.replace('·', ' ') for row in minefield]  # Replace '·' with ' ' for processing
annotated_board = annotate(minefield)
for row in annotated_board:
    print(row)
```

### Explanation

1. **Input Validation**:
   - Check that all rows have the same length.
   - Ensure only valid characters (' ' and '*') are present in the input.

2. **Counting Adjacent Mines**:
   - The function `count_adjacent_mines(x, y)` counts the number of mines adjacent to the cell at position `(x, y)` by checking all 8 possible directions (up, down, left, right, and the four diagonals).

3. **Constructing the Result Board**:
   - For each cell in the input board:
     - If it's a mine (`*`), place a mine in the result board.
     - If it's an empty cell (` `), count the adjacent mines and place the count in the result board. If the count is 0, leave the cell as empty.

This solution correctly processes the board and updates it with the appropriate mine counts, ensuring all input validations are handled with meaningful error messages.

To generate a spiral matrix of a given size, we need to fill a 2D list with numbers in a clockwise spiral order starting from 1. Here's a step-by-step plan to accomplish this:

1. **Initialize the Matrix**: Create a 2D list filled with zeros.
2. **Define Boundaries**: Use four boundaries (top, bottom, left, and right) to control the spiral filling process.
3. **Fill the Matrix**: Use a loop to fill the matrix while updating the boundaries and changing directions appropriately.

### Steps to Implement

1. **Initialize the Matrix**: Create a matrix of the given size initialized with zeros.
2. **Define Boundaries**: Start with the top boundary at 0, bottom boundary at `size - 1`, left boundary at 0, and right boundary at `size - 1`.
3. **Fill the Matrix**:
   - Move right across the top boundary, then increment the top boundary.
   - Move down the right boundary, then decrement the right boundary.
   - Move left across the bottom boundary, then decrement the bottom boundary.
   - Move up the left boundary, then increment the left boundary.
4. **Continue the Process**: Continue filling until all positions are filled.

### Implementation

Here's the implementation of the `spiral_matrix` function:

```python
def spiral_matrix(size):
    if size <= 0:
        return []

    matrix = [[0] * size for _ in range(size)]
    num = 1
    top, bottom, left, right = 0, size - 1, 0, size - 1

    while top <= bottom and left <= right:
        # Move right
        for i in range(left, right + 1):
            matrix[top][i] = num
            num += 1
        top += 1

        # Move down
        for i in range(top, bottom + 1):
            matrix[i][right] = num
            num += 1
        right -= 1

        # Move left
        if top <= bottom:
            for i in range(right, left - 1, -1):
                matrix[bottom][i] = num
                num += 1
            bottom -= 1

        # Move up
        if left <= right:
            for i in range(bottom, top - 1, -1):
                matrix[i][left] = num
                num += 1
            left += 1

    return matrix

# Example Usage:
matrix_3 = spiral_matrix(3)
for row in matrix_3:
    print(row)

matrix_4 = spiral_matrix(4)
for row in matrix_4:
    print(row)
```

### Explanation

1. **Initialize the Matrix**: Create a `size x size` matrix filled with zeros.
2. **Define Boundaries**: Set the initial boundaries for the top, bottom, left, and right edges of the matrix.
3. **Fill the Matrix**:
   - **Move Right**: Fill the top row from the left boundary to the right boundary and increment the top boundary.
   - **Move Down**: Fill the right column from the top boundary to the bottom boundary and decrement the right boundary.
   - **Move Left**: Fill the bottom row from the right boundary to the left boundary and decrement the bottom boundary.
   - **Move Up**: Fill the left column from the bottom boundary to the top boundary and increment the left boundary.
4. **Continue the Process**: Repeat the process until all positions are filled, adjusting the boundaries as needed.

This implementation ensures that the matrix is filled in a spiral order, handling various sizes appropriately.

To implement variable length quantity (VLQ) encoding and decoding, we need to follow the rules specified for VLQ:

1. **Encoding**:
   - Split the integer into 7-bit chunks.
   - Set the 8th bit to 1 for all but the last chunk.
   - The last chunk has the 8th bit set to 0.

2. **Decoding**:
   - Read bytes and assemble them into an integer.
   - Continue reading until you find a byte with the 8th bit set to 0.

### Implementation Steps

1. **Encoding**:
   - Use bitwise operations to split the number into 7-bit chunks.
   - Handle each chunk according to VLQ rules.
   
2. **Decoding**:
   - Read bytes and combine the 7-bit parts.
   - Check if the sequence is valid and complete.

### Exception Handling

If the sequence is incomplete, raise a `ValueError` with a message indicating the issue.

### Code Implementation

Here's the implementation of the `encode` and `decode` functions:

```python
def encode(numbers):
    result = []
    for number in numbers:
        if number < 0:
            raise ValueError("only non-negative integers are supported")
        chunks = []
        while number > 0 or not chunks:
            chunks.append(number & 0x7F)
            number >>= 7
        for i in range(len(chunks) - 1):
            chunks[i] |= 0x80
        result.extend(reversed(chunks))
    return result

def decode(bytes_):
    result = []
    current = 0
    for i, byte in enumerate(bytes_):
        current = (current << 7) | (byte & 0x7F)
        if byte & 0x80 == 0:
            result.append(current)
            current = 0
        elif i == len(bytes_) - 1:
            raise ValueError("incomplete sequence")
    if current != 0:
        raise ValueError("incomplete sequence")
    return result

# Example Usage
encoded = encode([0, 64, 127, 128, 8192, 16383, 16384, 1048576, 2097151, 2097152, 134217728, 268435455])
print("Encoded:", encoded)
decoded = decode(encoded)
print("Decoded:", decoded)
```

### Explanation

1. **Encoding**:
   - For each number, split it into 7-bit chunks.
   - If a number is zero, handle it as a special case to ensure at least one chunk is added.
   - Set the 8th bit to 1 for all chunks except the last one.
   - Reverse the order of chunks to ensure the least significant chunk comes last.
   - Append the chunks to the result.

2. **Decoding**:
   - Initialize `current` to accumulate the value.
   - For each byte, shift `current` left by 7 bits and add the lower 7 bits of the byte.
   - If the 8th bit is 0, it marks the end of the current value, so add `current` to the result and reset `current`.
   - If you reach the end of the bytes and `current` is not reset, raise a `ValueError` indicating an incomplete sequence.

### Exception Handling

If the encoding or decoding process encounters an issue with an incomplete sequence, it raises a `ValueError` with a descriptive message to aid in debugging.

This implementation ensures the correct conversion of numbers using VLQ encoding and decoding rules.

To solve the problem of finding the fewest number of coins that add up to a given target value, we can use dynamic programming. This approach helps us efficiently determine the minimum number of coins required to make the change for any given target value using a set of available coin denominations.

### Steps to Implement

1. **Handle Edge Cases**:
   - If the target value is negative, raise a `ValueError`.
   - If the target value is smaller than the smallest coin, raise a `ValueError`.

2. **Dynamic Programming Table Initialization**:
   - Create a table `dp` where `dp[i]` represents the minimum number of coins needed to make the value `i`.
   - Initialize `dp[0]` to 0 since 0 coins are needed to make the value 0.
   - Initialize the rest of the table with a value greater than any possible number of coins (e.g., `float('inf')`).

3. **Fill the Dynamic Programming Table**:
   - Iterate over each coin and for each value from the coin value to the target value, update the `dp` table with the minimum number of coins needed.

4. **Backtrack to Find the Coins**:
   - If `dp[target]` is still `float('inf')`, it means we cannot make the target with the given coins, so raise a `ValueError`.
   - Otherwise, backtrack from `dp[target]` to find which coins were used.

### Implementation

Here's the implementation of the `find_fewest_coins` function:

```python
def find_fewest_coins(coins, target):
    if target < 0:
        raise ValueError("target cannot be negative")
    if target == 0:
        return []

    dp = [float('inf')] * (target + 1)
    dp[0] = 0

    for coin in coins:
        for amount in range(coin, target + 1):
            dp[amount] = min(dp[amount], dp[amount - coin] + 1)

    if dp[target] == float('inf'):
        raise ValueError("can't make target with given coins")

    result = []
    amount = target
    while amount > 0:
        for coin in coins:
            if amount >= coin and dp[amount] == dp[amount - coin] + 1:
                result.append(coin)
                amount -= coin
                break

    return result

# Example Usage:
try:
    print(find_fewest_coins([1, 5, 10, 25, 100], 15))  # Should print [10, 5]
    print(find_fewest_coins([1, 5, 10, 25, 100], 40))  # Should print [25, 10, 5]
except ValueError as e:
    print(e)
```

### Explanation

1. **Edge Case Handling**:
   - If the target is negative or zero, appropriate exceptions or return values are managed.
   
2. **Dynamic Programming Table**:
   - The `dp` array is initialized with `float('inf')` to indicate that initially, no value can be made with zero coins except for `dp[0]` which is set to 0.

3. **Table Filling**:
   - For each coin, the table is updated to reflect the minimum number of coins needed for each value up to the target.

4. **Backtracking**:
   - Starting from the target value, the code backtracks to determine which coins were used by checking which coin would have reduced the number of coins to the current count.

This implementation ensures that we find the fewest number of coins required to make the target value, while also raising appropriate exceptions when the target cannot be made with the given coins.

To solve this problem, we need to generate all valid combinations of a given size that sum up to a specified target. Additionally, we must ensure that the combinations do not include any digits from a provided exclusion list.

### Steps to Implement

1. **Validate Input**: Ensure the input parameters are valid.
2. **Generate Combinations**: Use a recursive approach to generate all possible combinations.
3. **Filter Combinations**: Exclude any combinations that contain digits from the exclusion list.
4. **Sort and Return**: Sort the valid combinations before returning them.

### Detailed Implementation

Here's the implementation of the `combinations` function:

```python
def combinations(target, size, exclude):
    exclude_set = set(exclude)

    def valid_combination(combination):
        return sum(combination) == target and len(set(combination)) == len(combination)

    def backtrack(start, combination):
        if len(combination) == size:
            if valid_combination(combination):
                result.append(list(combination))
            return
        for num in range(start, 10):
            if num not in exclude_set and num not in combination:
                combination.append(num)
                backtrack(num + 1, combination)
                combination.pop()

    result = []
    backtrack(1, [])
    result.sort()
    return result

# Example Usage:
print(combinations(7, 3, []))        # Should return [[1, 2, 4]]
print(combinations(10, 2, []))       # Should return [[1, 9], [2, 8], [3, 7], [4, 6]]
print(combinations(10, 2, [1, 4]))   # Should return [[2, 8], [3, 7]]
```

### Explanation

1. **Validate Input**:
   - Ensure the `exclude` list is converted to a set for faster lookups.

2. **Generate Combinations**:
   - Use a recursive `backtrack` function to generate all combinations of digits from 1 to 9.
   - Start from the current number and go up to 9 to ensure combinations are unique and in increasing order.

3. **Filter Combinations**:
   - Use the `valid_combination` function to check if a combination has the correct sum and does not contain repeated digits.

4. **Sort and Return**:
   - Sort the resulting list of valid combinations before returning it.

This implementation uses a backtracking approach to efficiently generate and filter combinations, ensuring that the resulting combinations are valid and sorted as required.

The Rail Fence cipher works by writing the message in a zigzag pattern across multiple "rails" and then reading it row by row to form the encoded message. To decode, you need to recreate the zigzag pattern and then fill it with the encoded message to retrieve the original message.

### Encoding

To encode a message using the Rail Fence cipher:
1. Write the message in a zigzag pattern across the specified number of rails.
2. Read the message row by row.

### Decoding

To decode an encoded message:
1. Create the zigzag pattern with placeholders.
2. Fill the pattern with the encoded message row by row.
3. Read the message in a zigzag pattern to retrieve the original message.

### Implementation

Here is the Python implementation of the Rail Fence cipher for both encoding and decoding:

```python
def encode(message, rails):
    if rails == 1:
        return message
    
    rail_fence = [[] for _ in range(rails)]
    row, step = 0, 1

    for char in message:
        rail_fence[row].append(char)
        if row == 0:
            step = 1
        elif row == rails - 1:
            step = -1
        row += step
    
    encoded_message = ''.join([''.join(rail) for rail in rail_fence])
    return encoded_message

def decode(encoded_message, rails):
    if rails == 1:
        return encoded_message

    n = len(encoded_message)
    rail_lengths = [0] * rails
    row, step = 0, 1

    for _ in range(n):
        rail_lengths[row] += 1
        if row == 0:
            step = 1
        elif row == rails - 1:
            step = -1
        row += step

    rail_fence = [[] for _ in range(rails)]
    idx = 0
    for r in range(rails):
        for _ in range(rail_lengths[r]):
            rail_fence[r].append(encoded_message[idx])
            idx += 1

    decoded_message = []
    row, step = 0, 1
    rail_indices = [0] * rails

    for _ in range(n):
        decoded_message.append(rail_fence[row][rail_indices[row]])
        rail_indices[row] += 1
        if row == 0:
            step = 1
        elif row == rails - 1:
            step = -1
        row += step

    return ''.join(decoded_message)

# Example Usage:
encoded = encode("WE ARE DISCOVERED FLEE AT ONCE", 3)
print("Encoded:", encoded)  # Should print "WECRLTEERDSOEEFEAOCAIVDEN"

decoded = decode("WECRLTEERDSOEEFEAOCAIVDEN", 3)
print("Decoded:", decoded)  # Should print "WEAREDISCOVEREDFLEEATONCE"
```

### Explanation

1. **Encoding**:
   - Initialize `rail_fence` as a list of lists, where each sublist represents a rail.
   - Iterate over each character in the message and append it to the appropriate rail.
   - Adjust the row index (`row`) and step (`step`) to move down or up the rails.
   - Concatenate the characters from each rail to form the encoded message.

2. **Decoding**:
   - Determine the length of each rail by simulating the zigzag traversal.
   - Create placeholders (`rail_fence`) to store characters for each rail.
   - Fill each rail with the corresponding characters from the encoded message.
   - Read the characters in the zigzag pattern to form the decoded message.

This implementation ensures the correct encoding and decoding of messages using the Rail Fence cipher.

To implement the `largest` and `smallest` functions for finding the largest and smallest palindromic products within a given range of factors, we need to perform the following steps:

1. **Input Validation**: Ensure that `min_factor` is less than or equal to `max_factor`.
2. **Generate Products**: Compute the product of all pairs of numbers within the specified range.
3. **Check for Palindromes**: Determine if a product is a palindrome.
4. **Track Factors**: Store the factors for each palindrome found.
5. **Return Results**: Return the smallest and largest palindromic products along with their factors.

### Implementation

Here's the Python implementation of the `largest` and `smallest` functions:

```python
def is_palindrome(number):
    return str(number) == str(number)[::-1]

def largest(min_factor, max_factor):
    if min_factor > max_factor:
        raise ValueError("min must be <= max")

    max_palindrome = 0
    factors = []

    for i in range(min_factor, max_factor + 1):
        for j in range(i, max_factor + 1):
            product = i * j
            if is_palindrome(product):
                if product > max_palindrome:
                    max_palindrome = product
                    factors = [(i, j)]
                elif product == max_palindrome:
                    factors.append((i, j))

    return max_palindrome, factors

def smallest(min_factor, max_factor):
    if min_factor > max_factor:
        raise ValueError("min must be <= max")

    min_palindrome = float('inf')
    factors = []

    for i in range(min_factor, max_factor + 1):
        for j in range(i, max_factor + 1):
            product = i * j
            if is_palindrome(product):
                if product < min_palindrome:
                    min_palindrome = product
                    factors = [(i, j)]
                elif product == min_palindrome:
                    factors.append((i, j))

    return min_palindrome, factors

# Example Usage:
print(largest(1, 9))         # Should return (9, [(1, 9), (3, 3)])
print(smallest(1, 9))        # Should return (1, [(1, 1)])
print(largest(10, 99))       # Should return (9009, [(91, 99)])
print(smallest(10, 99))      # Should return (121, [(11, 11)])
```

### Explanation

1. **Input Validation**:
   - Both `largest` and `smallest` functions start by validating that `min_factor` is less than or equal to `max_factor`. If not, they raise a `ValueError`.

2. **Generate Products**:
   - Iterate over all pairs of numbers `(i, j)` within the range `[min_factor, max_factor]`. To avoid duplicate pairs, start `j` from `i`.

3. **Check for Palindromes**:
   - For each product, check if it is a palindrome using the `is_palindrome` helper function.

4. **Track Factors**:
   - For the `largest` function:
     - If a new maximum palindrome is found, update `max_palindrome` and reset the `factors` list.
     - If the current product equals the `max_palindrome`, append the pair `(i, j)` to the `factors` list.
   - For the `smallest` function:
     - If a new minimum palindrome is found, update `min_palindrome` and reset the `factors` list.
     - If the current product equals the `min_palindrome`, append the pair `(i, j)` to the `factors` list.

5. **Return Results**:
   - Return the palindrome and its factors as a tuple.

This implementation ensures that the functions correctly identify the largest and smallest palindromic products within the specified range, along with all pairs of factors that produce these palindromes.

To tackle this problem, we need to follow a systematic approach to tally the results of the football matches and produce the desired standings. Here is a step-by-step plan for the implementation:

1. **Parse the Input**: Read the input lines to extract match results.
2. **Update the Team Statistics**: Track the statistics for each team based on match outcomes.
3. **Sort the Teams**: Sort the teams first by points (descending) and then alphabetically.
4. **Format the Output**: Format the output in a tabular format.

### Implementation Steps

1. **Data Structures**:
   - Use a dictionary to store statistics for each team.
   - Each team’s statistics will include: Matches Played (MP), Wins (W), Draws (D), Losses (L), and Points (P).

2. **Parsing and Updating**:
   - Parse each input line to determine the outcome of the match.
   - Update the statistics for both teams involved in the match.

3. **Sorting**:
   - Sort the teams by their points in descending order.
   - If two teams have the same points, sort them alphabetically.

4. **Formatting**:
   - Create a formatted string that represents the final standings.

### Code Implementation

Here is the code to accomplish this:

```python
def tally(rows):
    # Initialize a dictionary to store team statistics
    teams = {}
    
    # Function to initialize a team's record
    def init_team(team):
        if team not in teams:
            teams[team] = {'MP': 0, 'W': 0, 'D': 0, 'L': 0, 'P': 0}

    # Process each match result
    for row in rows:
        team1, team2, result = row.split(';')
        init_team(team1)
        init_team(team2)
        
        # Update matches played
        teams[team1]['MP'] += 1
        teams[team2]['MP'] += 1
        
        if result == 'win':
            teams[team1]['W'] += 1
            teams[team1]['P'] += 3
            teams[team2]['L'] += 1
        elif result == 'loss':
            teams[team1]['L'] += 1
            teams[team2]['W'] += 1
            teams[team2]['P'] += 3
        elif result == 'draw':
            teams[team1]['D'] += 1
            teams[team1]['P'] += 1
            teams[team2]['D'] += 1
            teams[team2]['P'] += 1
    
    # Sort the teams first by points (descending), then by name (ascending)
    sorted_teams = sorted(teams.items(), key=lambda item: (-item[1]['P'], item[0]))
    
    # Format the output
    output = []
    header = "Team                           | MP |  W |  D |  L |  P"
    output.append(header)
    
    for team, stats in sorted_teams:
        output.append(f"{team:31} | {stats['MP']:2} | {stats['W']:2} | {stats['D']:2} | {stats['L']:2} | {stats['P']:2}")
    
    return "\n".join(output)

# Example Usage:
rows = [
    "Allegoric Alaskans;Blithering Badgers;win",
    "Devastating Donkeys;Courageous Californians;draw",
    "Devastating Donkeys;Allegoric Alaskans;win",
    "Courageous Californians;Blithering Badgers;loss",
    "Blithering Badgers;Devastating Donkeys;loss",
    "Allegoric Alaskans;Courageous Californians;win"
]

print(tally(rows))
```

### Explanation

1. **Initialize the Team Statistics**:
   - `init_team` ensures that each team has an entry in the `teams` dictionary with initialized statistics.

2. **Process Each Match**:
   - Parse the result of each match and update the statistics for both teams involved.
   - Based on the result ('win', 'loss', 'draw'), update the statistics accordingly.

3. **Sort the Teams**:
   - Use `sorted()` to sort the teams by points in descending order. If points are equal, sort alphabetically.

4. **Format the Output**:
   - Append the formatted header to the output list.
   - Append each team's formatted statistics to the output list.
   - Join the output list with newline characters to create the final formatted string.

This implementation ensures that the results are accurately tallied and displayed in the required format.

To generate the lyrics for the song "I Know an Old Lady Who Swallowed a Fly" algorithmically, we need to follow the cumulative pattern of the song. Here's the step-by-step approach:

1. **Define the Verses**: Store each verse's unique lines and the cumulative lines that repeat and expand with each verse.
2. **Generate the Requested Verses**: Construct the lyrics for the requested range of verses.

### Implementation

Here is the code to generate the lyrics for the song:

```python
def recite(start_verse, end_verse):
    animals = [
        "fly",
        "spider",
        "bird",
        "cat",
        "dog",
        "goat",
        "cow",
        "horse"
    ]
    
    unique_lines = {
        "fly": "",
        "spider": "It wriggled and jiggled and tickled inside her.",
        "bird": "How absurd to swallow a bird!",
        "cat": "Imagine that, to swallow a cat!",
        "dog": "What a hog, to swallow a dog!",
        "goat": "Just opened her throat and swallowed a goat!",
        "cow": "I don't know how she swallowed a cow!",
        "horse": "She's dead, of course!"
    }
    
    cumulative_lines = {
        "spider": "She swallowed the spider to catch the fly.",
        "bird": "She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.",
        "cat": "She swallowed the cat to catch the bird.",
        "dog": "She swallowed the dog to catch the cat.",
        "goat": "She swallowed the goat to catch the dog.",
        "cow": "She swallowed the cow to catch the goat."
    }
    
    verses = []
    for i in range(start_verse - 1, end_verse):
        animal = animals[i]
        verse = [f"I know an old lady who swallowed a {animal}."]
        if unique_lines[animal]:
            verse.append(unique_lines[animal])
        
        if animal == "horse":
            verses.append("\n".join(verse))
            continue
        
        for j in range(i, 0, -1):
            prev_animal = animals[j]
            if prev_animal in cumulative_lines:
                verse.append(cumulative_lines[prev_animal])
        
        verse.append("I don't know why she swallowed the fly. Perhaps she'll die.")
        verses.append("\n".join(verse))
    
    return "\n\n".join(verses)

# Example Usage:
print(recite(1, 1))  # Verse 1
print(recite(1, 3))  # Verses 1 to 3
```

### Explanation

1. **Define the Animals and Unique Lines**:
   - `animals`: A list of animals in the order they appear in the song.
   - `unique_lines`: A dictionary with unique lines for each animal.

2. **Define the Cumulative Lines**:
   - `cumulative_lines`: A dictionary with cumulative lines that repeat and expand with each verse.

3. **Generate the Requested Verses**:
   - Iterate through the range of requested verses (`start_verse` to `end_verse`).
   - Construct each verse by starting with the unique line for the current animal.
   - Add cumulative lines by iterating backward through the previously mentioned animals.
   - Handle the special case for the "horse" verse where the song ends abruptly.

4. **Return the Generated Verses**:
   - Combine the verses into a single string separated by double newlines.

This implementation constructs the lyrics algorithmically, ensuring that the cumulative nature of the song is preserved while generating the requested range of verses.

To implement the `Scale` class for generating chromatic and diatonic scales based on a given tonic and intervals, we need to follow these steps:

1. **Initialize the Class**: Determine whether the scale should use sharps or flats based on the tonic.
2. **Generate the Chromatic Scale**: Shift the base scale to start from the given tonic.
3. **Generate Scales Based on Intervals**: Follow the given intervals to generate the required scale.

### Implementation

Here is the Python code for the `Scale` class:

```python
class Scale:
    def __init__(self, tonic):
        self.tonic = tonic.capitalize()
        self.sharps = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#']
        self.flats = ['A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab']
        
        self.flat_keys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'd', 'g', 'c', 'f', 'bb', 'eb']
        self.scale = self.flats if self.tonic in self.flat_keys else self.sharps
        
    def chromatic(self):
        start_index = self.scale.index(self.tonic)
        return self.scale[start_index:] + self.scale[:start_index]
    
    def interval(self, intervals):
        scale = self.chromatic()
        notes = [self.tonic]
        index = 0
        for interval in intervals:
            if interval == 'm':
                index += 1
            elif interval == 'M':
                index += 2
            elif interval == 'A':
                index += 3
            notes.append(scale[index % len(scale)])
        return notes

# Example Usage:
scale = Scale("C")
print("Chromatic scale for C:", scale.chromatic())
print("Diatonic scale for C with intervals 'MMmMMMm':", scale.interval("MMmMMMm"))

scale = Scale("G")
print("Chromatic scale for G:", scale.chromatic())
print("Diatonic scale for G with intervals 'MMmMMMm':", scale.interval("MMmMMMm"))
```

### Explanation

1. **Initialize the Class**:
   - The `__init__` method takes the tonic and capitalizes it to ensure consistency.
   - Two lists, `sharps` and `flats`, represent the chromatic scales using sharps and flats, respectively.
   - The `flat_keys` list contains the keys that should use the flat scale.
   - The `scale` attribute is set to either `sharps` or `flats` based on whether the tonic is in the `flat_keys` list.

2. **Generate the Chromatic Scale**:
   - The `chromatic` method finds the starting index of the tonic in the chosen scale and returns the scale starting from that index, wrapping around to the beginning.

3. **Generate Scales Based on Intervals**:
   - The `interval` method first gets the chromatic scale starting from the tonic.
   - It then iterates over the intervals, adjusting the index based on whether the interval is a half step ('m'), a whole step ('M'), or an augmented step ('A').
   - The notes are added to the `notes` list, which is returned at the end.

This implementation ensures that the scales are correctly generated based on the given tonic and intervals, and it handles both sharps and flats as required.

To solve the problem of finding the largest product of a series of adjacent digits within a given input string, we need to follow these steps:

1. **Input Validation**: Ensure the inputs are valid (e.g., the span is not negative, the span is not longer than the input string, and the input string contains only digits).
2. **Generate Series**: Extract all possible series of the given length from the input string.
3. **Calculate Products**: Compute the product of digits for each series.
4. **Find the Largest Product**: Identify the maximum product from the computed products.

### Implementation

Here's the implementation of the `largest_product` function:

```python
def largest_product(series, size):
    # Input validation
    if size < 0:
        raise ValueError("span must not be negative")
    if size > len(series):
        raise ValueError("span must be smaller than string length")
    if not all(char.isdigit() for char in series):
        raise ValueError("digits input must only contain digits")
    
    # If size is 0, the product of an empty series is considered 1
    if size == 0:
        return 1
    
    # Generate series and calculate products
    max_product = 0
    for i in range(len(series) - size + 1):
        product = 1
        for j in range(size):
            product *= int(series[i + j])
        if product > max_product:
            max_product = product
            
    return max_product

# Example Usage:
print(largest_product("63915", 3))  # Should print 162
print(largest_product("1027839564", 3))  # Should print 270
```

### Explanation

1. **Input Validation**:
   - **Negative Span**: Raise a `ValueError` if the span is negative.
   - **Span Larger Than Series**: Raise a `ValueError` if the span is larger than the length of the series.
   - **Non-Digit Characters**: Raise a `ValueError` if the series contains any non-digit characters.
   
2. **Special Case for Span 0**:
   - If the span is 0, the product of an empty series is defined as 1. This is based on the convention in combinatorics where the product of an empty set is the multiplicative identity (1).

3. **Generate Series and Calculate Products**:
   - Loop through the input series and extract all possible series of the given span.
   - Calculate the product of digits for each series.
   - Track the maximum product encountered.

4. **Return the Maximum Product**:
   - After processing all possible series, return the highest product found.

This implementation ensures the correct computation of the largest product for a given span of adjacent digits in the input series, and handles various edge cases and invalid inputs gracefully.

To refactor the given Markdown parser, we will:
1. Break down the code into smaller, more manageable functions.
2. Use more descriptive variable names to improve readability.
3. Remove redundant and repeated code by introducing helper functions.
4. Ensure all functionalities are preserved and tests continue to pass.

Here's the refactored code with explanations:

```python
import re

def parse(markdown):
    lines = markdown.split('\n')
    result = ''
    in_list = False
    
    for line in lines:
        if re.match(r'###### (.*)', line):
            result += parse_header(line, 6)
        elif re.match(r'##### (.*)', line):
            result += parse_header(line, 5)
        elif re.match(r'#### (.*)', line):
            result += parse_header(line, 4)
        elif re.match(r'### (.*)', line):
            result += parse_header(line, 3)
        elif re.match(r'## (.*)', line):
            result += parse_header(line, 2)
        elif re.match(r'# (.*)', line):
            result += parse_header(line, 1)
        elif re.match(r'\* (.*)', line):
            if not in_list:
                in_list = True
                result += '<ul>'
            result += parse_list_item(line)
        else:
            if in_list:
                in_list = False
                result += '</ul>'
            result += parse_paragraph(line)
    
    if in_list:
        result += '</ul>'
    
    return result

def parse_header(line, level):
    header_content = line[level + 1:]
    return f'<h{level}>{header_content}</h{level}>'

def parse_list_item(line):
    list_item_content = re.match(r'\* (.*)', line).group(1)
    list_item_content = apply_formatting(list_item_content)
    return f'<li>{list_item_content}</li>'

def parse_paragraph(line):
    line = apply_formatting(line)
    return f'<p>{line}</p>'

def apply_formatting(text):
    text = re.sub(r'__(.*?)__', r'<strong>\1</strong>', text)
    text = re.sub(r'_(.*?)_', r'<em>\1</em>', text)
    return text

# Example Usage:
markdown_input = """# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6

* List item 1
* List item 2 with _italic_ and __bold__ text

A paragraph with _italic_ and __bold__ text."""

html_output = parse(markdown_input)
print(html_output)
```

### Explanation

1. **Splitting the Input**:
   - The input Markdown string is split into lines using `split('\n')`.

2. **Processing Headers**:
   - The `parse_header` function handles headers of different levels by using regular expressions to match and capture the content, then formatting it as an HTML header.

3. **Processing List Items**:
   - The `parse_list_item` function processes list items by matching the content after the asterisk and applying formatting (bold and italic).

4. **Processing Paragraphs**:
   - The `parse_paragraph` function wraps non-header and non-list lines in `<p>` tags and applies formatting.

5. **Applying Formatting**:
   - The `apply_formatting` function uses regular expressions to replace Markdown bold (`__`) and italic (`_`) with corresponding HTML tags.

6. **Handling Lists**:
   - The code ensures that list items are wrapped in `<ul>` tags. It starts a list when the first list item is encountered and closes it when a non-list line is encountered or at the end of input.

This refactored code is easier to read, maintain, and extend while ensuring the same functionality as the original.

To implement the `meetup` function, we need to identify the exact date of a meetup given a month, year, weekday, and week specification. We also need to create an exception for invalid meetups.

### Steps:

1. **Define the Exception**:
    - Subclass `ValueError` to create `MeetupDayException`.

2. **Determine the Date**:
    - Depending on the week specification (`first`, `second`, `third`, `fourth`, `last`, `teenth`), compute the date that matches the given day of the week.

3. **Use Python's datetime Module**:
    - The `datetime` module provides tools to work with dates, such as finding out the day of the week for a given date.

### Implementation:

Here's the detailed implementation of the `meetup` function along with the exception class:

```python
from datetime import date, timedelta

# Define the custom exception
class MeetupDayException(ValueError):
    """Exception raised when the Meetup weekday and count do not result in a valid date.
    """
    def __init__(self, message="Invalid meetup day"):
        self.message = message
        super().__init__(self.message)

# Define the meetup function
def meetup(year, month, week, day_of_week):
    # Define the days of the week to map strings to numbers
    days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    
    # Ensure day_of_week is valid
    if day_of_week not in days_of_week:
        raise MeetupDayException("Invalid day of the week")
    
    # Get the corresponding weekday number (0 = Monday, 6 = Sunday)
    day_num = days_of_week.index(day_of_week)
    
    # Define helper functions to find the required date
    def get_teenth_day():
        for day in range(13, 20):
            if date(year, month, day).weekday() == day_num:
                return date(year, month, day)
        raise MeetupDayException("No valid teenth day found")
    
    def get_weekday_by_occurrence(occurrence):
        count = 0
        for day in range(1, 32):
            try:
                current_date = date(year, month, day)
            except ValueError:
                break
            if current_date.weekday() == day_num:
                count += 1
                if count == occurrence:
                    return current_date
        raise MeetupDayException("No valid date found for the given occurrence")
    
    def get_last_weekday():
        last_day = date(year, month + 1, 1) - timedelta(days=1) if month != 12 else date(year + 1, 1, 1) - timedelta(days=1)
        for day in range(last_day.day, 0, -1):
            if date(year, month, day).weekday() == day_num:
                return date(year, month, day)
        raise MeetupDayException("No valid last weekday found")
    
    # Determine the specific date based on the week specification
    if week == 'teenth':
        return get_teenth_day()
    elif week in ['first', 'second', 'third', 'fourth']:
        occurrence = ['first', 'second', 'third', 'fourth'].index(week) + 1
        return get_weekday_by_occurrence(occurrence)
    elif week == 'last':
        return get_last_weekday()
    else:
        raise MeetupDayException("Invalid week specification")

# Example Usage:
print(meetup(2023, 10, 'first', 'Monday'))    # Expected output: 2023-10-02
print(meetup(2023, 10, 'teenth', 'Wednesday')) # Expected output: 2023-10-18
print(meetup(2023, 10, 'last', 'Sunday'))      # Expected output: 2023-10-29
```

### Explanation:

1. **Initialization**:
    - The `days_of_week` list maps weekdays to their corresponding index.

2. **Helper Functions**:
    - `get_teenth_day`: Finds the first `teenth` day that matches the given weekday.
    - `get_weekday_by_occurrence`: Finds the nth occurrence of the given weekday.
    - `get_last_weekday`: Finds the last occurrence of the given weekday in the month.

3. **Main Logic**:
    - Based on the `week` specification, the appropriate helper function is called to find the required date.
    - If the `week` specification is invalid, a `MeetupDayException` is raised.

This implementation ensures that the function is modular, easy to understand, and handles all specified edge cases.

To compute Pascal's Triangle recursively, we need to follow these steps:

1. **Base Case**: Define the base case for the recursion. Pascal's Triangle starts with `[1]` as its first row.
2. **Recursive Case**: For each subsequent row, compute the values by adding the numbers to the right and left of the current position in the previous row.

Pascal's Triangle properties:
- The first and last elements of each row are always `1`.
- Each interior element is the sum of the two elements directly above it from the previous row.

We will create a recursive function to compute each row of Pascal's Triangle and build up to the desired number of rows.

### Implementation:

Here is the implementation of the `rows` function:

```python
def rows(row_count):
    if row_count < 0:
        raise ValueError("number of rows is negative")
    
    def generate_row(n):
        if n == 0:
            return [[1]]
        elif n == 1:
            return [[1], [1, 1]]
        else:
            previous_triangle = generate_row(n - 1)
            last_row = previous_triangle[-1]
            new_row = [1]  # first element
            for i in range(1, len(last_row)):
                new_row.append(last_row[i - 1] + last_row[i])
            new_row.append(1)  # last element
            previous_triangle.append(new_row)
            return previous_triangle
    
    return generate_row(row_count - 1)

# Example Usage:
print(rows(1))  # [[1]]
print(rows(2))  # [[1], [1, 1]]
print(rows(3))  # [[1], [1, 1], [1, 2, 1]]
print(rows(4))  # [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]
print(rows(5))  # [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
```

### Explanation:

1. **Input Validation**:
   - If `row_count` is negative, a `ValueError` is raised with a message "number of rows is negative".

2. **Recursive Function `generate_row`**:
   - The function generates the Pascal's Triangle up to the `n`-th row.
   - **Base Cases**:
     - For `n == 0`, it returns `[[1]]`.
     - For `n == 1`, it returns `[[1], [1, 1]]`.
   - **Recursive Case**:
     - The function calls itself to get the Pascal's Triangle up to the `n-1`-th row.
     - It then computes the new row by iterating through the last row and summing adjacent elements.
     - The new row is added to the triangle, and the updated triangle is returned.

3. **Building the Triangle**:
   - The `rows` function calls `generate_row` with `row_count - 1` because the row indices are 0-based in the recursive function.

This approach ensures that Pascal's Triangle is generated recursively, and it handles the input validation as required.

To implement a simplified version of the `grep` command, we need to consider the following steps:

1. **Input Parsing**: Parse the `pattern`, `flags`, and `files` from the input arguments.
2. **Reading Files**: Read the content of each file specified.
3. **Pattern Matching**: Match lines in the files based on the `pattern` and `flags`.
4. **Formatting Output**: Format the output based on the flags (`-n`, `-l`, `i`, `-v`, `-x`).

### Implementation

Here's the implementation of the `grep` function:

```python
import re

def grep(pattern, flags, files):
    result = []
    match_files = []
    
    # Parse flags
    show_line_numbers = '-n' in flags
    list_filenames = '-l' in flags
    case_insensitive = '-i' in flags
    invert_match = '-v' in flags
    match_entire_line = '-x' in flags
    
    if case_insensitive:
        pattern = pattern.lower()
    
    for filename in files:
        with open(filename, 'r') as file:
            lines = file.readlines()
        
        file_matches = []
        
        for line_number, line in enumerate(lines, start=1):
            original_line = line.rstrip('\n')
            search_line = original_line.lower() if case_insensitive else original_line
            
            # Match pattern
            if match_entire_line:
                match = (search_line == pattern)
            else:
                match = (pattern in search_line)
            
            # Invert match if '-v' flag is present
            if invert_match:
                match = not match
            
            if match:
                if list_filenames:
                    match_files.append(filename)
                    break
                formatted_line = original_line
                if show_line_numbers:
                    formatted_line = f"{line_number}:{formatted_line}"
                if len(files) > 1:
                    formatted_line = f"{filename}:{formatted_line}"
                file_matches.append(formatted_line)
        
        result.extend(file_matches)
    
    if list_filenames:
        return "\n".join(match_files)
    
    return "\n".join(result)

# Example Usage
print(grep("hello", ["-n"], ["file1.txt", "file2.txt"]))
print(grep("hello", ["-i"], ["file1.txt"]))
print(grep("hello", ["-v"], ["file1.txt"]))
print(grep("hello", ["-x"], ["file1.txt"]))
print(grep("hello", ["-l"], ["file1.txt", "file2.txt"]))
```

### Explanation

1. **Input Parsing**:
   - Parse the `flags` to set the corresponding boolean variables.
   - Convert the pattern to lowercase if `-i` flag is set for case-insensitive search.

2. **Reading Files**:
   - Iterate through each file, read its content line by line.

3. **Pattern Matching**:
   - Check if the `pattern` matches the entire line if `-x` flag is set.
   - Otherwise, check if the `pattern` is a substring of the line.
   - Invert the match result if `-v` flag is set.
   - If a match is found, format the line based on the `flags` (`-n` for line numbers, filename prefix for multiple files).

4. **Formatting Output**:
   - If `-l` flag is set, collect filenames of matching files and return them.
   - Otherwise, collect matching lines and format them as specified.

### Notes:
- **Exception Handling**: This implementation assumes files exist and are readable. In production code, you'd want to add error handling for file operations.
- **Performance**: This implementation reads files line by line which is efficient for large files.

This approach covers the required functionality for the simplified `grep` command and handles all specified flags correctly.

To implement a doubly linked list in Python, we need two classes: `Node` and `LinkedList`. The `Node` class will represent each station in the train route, and the `LinkedList` class will manage the operations on the route, such as adding or removing stations and calculating the route size.

### Node Class
The `Node` class should store:
- The value of the station.
- References to the previous and succeeding nodes in the list.

### LinkedList Class
The `LinkedList` class should support the following operations:
- `push(value)`: Add a node with the given value to the end of the list.
- `pop()`: Remove and return the value of the node from the end of the list.
- `shift(value)`: Add a node with the given value to the beginning of the list.
- `unshift()`: Remove and return the value of the node from the beginning of the list.
- `delete(value)`: Remove the first node with the given value from the list.
- `__len__()`: Return the number of nodes in the list.
- `__iter__()`: Iterate over the values in the list.

Here is the complete implementation:

```python
class Node:
    def __init__(self, value, succeeding=None, previous=None):
        self.value = value
        self.succeeding = succeeding
        self.previous = previous

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def push(self, value):
        new_node = Node(value)
        if self.tail is None:
            self.head = self.tail = new_node
        else:
            new_node.previous = self.tail
            self.tail.succeeding = new_node
            self.tail = new_node
        self.size += 1

    def pop(self):
        if self.tail is None:
            raise IndexError("pop from empty list")
        value = self.tail.value
        if self.head == self.tail:
            self.head = self.tail = None
        else:
            self.tail = self.tail.previous
            self.tail.succeeding = None
        self.size -= 1
        return value

    def shift(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = self.tail = new_node
        else:
            new_node.succeeding = self.head
            self.head.previous = new_node
            self.head = new_node
        self.size += 1

    def unshift(self):
        if self.head is None:
            raise IndexError("unshift from empty list")
        value = self.head.value
        if self.head == self.tail:
            self.head = self.tail = None
        else:
            self.head = self.head.succeeding
            self.head.previous = None
        self.size -= 1
        return value

    def delete(self, value):
        current = self.head
        while current:
            if current.value == value:
                if current.previous:
                    current.previous.succeeding = current.succeeding
                else:
                    self.head = current.succeeding
                if current.succeeding:
                    current.succeeding.previous = current.previous
                else:
                    self.tail = current.previous
                self.size -= 1
                return
            current = current.succeeding
        raise ValueError(f"Value {value} not found in list")

    def __len__(self):
        return self.size

    def __iter__(self):
        current = self.head
        while current:
            yield current.value
            current = current.succeeding

# Example Usage:
ll = LinkedList()
ll.push(1)
ll.push(2)
ll.push(3)
ll.shift(0)
print(list(ll))  # Output: [0, 1, 2, 3]
ll.pop()
print(list(ll))  # Output: [0, 1, 2]
ll.unshift()
print(list(ll))  # Output: [1, 2]
ll.delete(1)
print(list(ll))  # Output: [2]
```

### Explanation:

1. **Node Class**:
   - `__init__`: Initializes a node with value and optional succeeding and previous nodes.

2. **LinkedList Class**:
   - `__init__`: Initializes an empty list with head and tail pointers and a size counter.
   - `push(value)`: Adds a new node to the end of the list.
   - `pop()`: Removes and returns the value of the last node.
   - `shift(value)`: Adds a new node to the beginning of the list.
   - `unshift()`: Removes and returns the value of the first node.
   - `delete(value)`: Removes the first node with the given value.
   - `__len__()`: Returns the number of nodes in the list.
   - `__iter__()`: Iterates over the values in the list, making the list iterable.

This implementation ensures that the linked list operations are efficient and that the list can be used as part of a larger train scheduling system.


Here's the implementation of a `ComplexNumber` class that supports the operations specified:

### ComplexNumber Class Implementation

```python
import math

class ComplexNumber:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __eq__(self, other):
        return self.real == other.real and self.imaginary == other.imaginary

    def __add__(self, other):
        return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary)

    def __sub__(self, other):
        return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary)

    def __mul__(self, other):
        real = self.real * other.real - self.imaginary * other.imaginary
        imaginary = self.real * other.imaginary + self.imaginary * other.real
        return ComplexNumber(real, imaginary)

    def __truediv__(self, other):
        if other.real == 0 and other.imaginary == 0:
            raise ZeroDivisionError("division by zero")
        denominator = other.real ** 2 + other.imaginary ** 2
        real = (self.real * other.real + self.imaginary * other.imaginary) / denominator
        imaginary = (self.imaginary * other.real - self.real * other.imaginary) / denominator
        return ComplexNumber(real, imaginary)

    def __abs__(self):
        return math.sqrt(self.real ** 2 + self.imaginary ** 2)

    def conjugate(self):
        return ComplexNumber(self.real, -self.imaginary)

    def exp(self):
        exp_real = math.exp(self.real)
        return ComplexNumber(exp_real * math.cos(self.imaginary), exp_real * math.sin(self.imaginary))

    def __repr__(self):
        return f"{self.real} + {self.imaginary}i"

# Example Usage:
c1 = ComplexNumber(1, 2)
c2 = ComplexNumber(3, 4)

print(f"c1: {c1}")
print(f"c2: {c2}")

print(f"c1 + c2 = {c1 + c2}")
print(f"c1 - c2 = {c1 - c2}")
print(f"c1 * c2 = {c1 * c2}")
print(f"c1 / c2 = {c1 / c2}")
print(f"abs(c1) = {abs(c1)}")
print(f"c1.conjugate() = {c1.conjugate()}")
print(f"c1.exp() = {c1.exp()}")
```

### Explanation

1. **Initialization (`__init__`)**:
   - Initializes the real and imaginary parts of the complex number.

2. **Equality (`__eq__`)**:
   - Checks if two complex numbers are equal by comparing their real and imaginary parts.

3. **Addition (`__add__`)**:
   - Adds two complex numbers by adding their respective real and imaginary parts.

4. **Subtraction (`__sub__`)**:
   - Subtracts two complex numbers by subtracting their respective real and imaginary parts.

5. **Multiplication (`__mul__`)**:
   - Multiplies two complex numbers using the formula `(a + i * b) * (c + i * d) = (a * c - b * d) + (b * c + a * d) * i`.

6. **Division (`__truediv__`)**:
   - Divides two complex numbers using the formula `(a + i * b) / (c + i * d) = (a * c + b * d)/(c^2 + d^2) + (b * c - a * d)/(c^2 + d^2) * i`.
   - Raises `ZeroDivisionError` if the divisor is zero.

7. **Absolute Value (`__abs__`)**:
   - Returns the absolute value (magnitude) of the complex number using the formula `|z| = sqrt(a^2 + b^2)`.

8. **Conjugate (`conjugate`)**:
   - Returns the conjugate of the complex number, which is `a - b * i` for a complex number `a + b * i`.

9. **Exponential (`exp`)**:
   - Returns the exponential of the complex number using Euler's formula `e^(a + i * b) = e^a * (cos(b) + i * sin(b))`.

10. **String Representation (`__repr__`)**:
    - Returns a string representation of the complex number in the form `a + bi`.

### Example Usage
- The provided example demonstrates creating two complex numbers, performing various operations on them, and printing the results. This includes addition, subtraction, multiplication, division, absolute value, conjugate, and exponential functions.

This implementation covers all the necessary operations for handling complex numbers in a robust and readable manner.

Here's the refactored code for the ledger printer:

### Refactored Code

```python
# -*- coding: utf-8 -*-
from datetime import datetime

class LedgerEntry:
    def __init__(self, date, description, change):
        self.date = datetime.strptime(date, '%Y-%m-%d')
        self.description = description
        self.change = change

    def format_date(self, locale):
        if locale == 'en_US':
            return self.date.strftime('%m/%d/%Y')
        elif locale == 'nl_NL':
            return self.date.strftime('%d-%m-%Y')

    def format_description(self):
        if len(self.description) > 25:
            return self.description[:22] + '...'
        return self.description.ljust(25)

    def format_change(self, currency, locale):
        abs_change = abs(self.change)
        if locale == 'en_US':
            change_str = f"${abs_change // 100:,}.{abs_change % 100:02d}"
            if self.change < 0:
                change_str = f"({change_str})"
            else:
                change_str += ' '
        elif locale == 'nl_NL':
            change_str = f"€ {abs_change // 100:,}.{abs_change % 100:02d}"
            if self.change < 0:
                change_str = '-' + change_str
            change_str += ' '
        return change_str.rjust(13)

def create_entry(date, description, change):
    return LedgerEntry(date, description, change)

def format_entries(currency, locale, entries):
    if locale == 'en_US':
        header = 'Date       | Description               | Change       '
    elif locale == 'nl_NL':
        header = 'Datum      | Omschrijving              | Verandering  '

    formatted_entries = [header]
    
    entries.sort(key=lambda x: (x.date, x.change, x.description))
    
    for entry in entries:
        date_str = entry.format_date(locale)
        description_str = entry.format_description()
        change_str = entry.format_change(currency, locale)
        formatted_entries.append(f"{date_str} | {description_str} | {change_str}")

    return '\n'.join(formatted_entries)

# Example Usage
entries = [
    create_entry('2021-12-01', 'Sample entry 1', -12345),
    create_entry('2021-11-01', 'Another entry', 54321),
    create_entry('2021-11-15', 'Short desc', 1000),
    create_entry('2021-12-02', 'Long description that needs truncation', 999),
]

print(format_entries('USD', 'en_US', entries))
print(format_entries('EUR', 'nl_NL', entries))
```

### Changes Made

1. **Created `LedgerEntry` Class**:
    - Encapsulated `date`, `description`, and `change` attributes.
    - Added methods `format_date`, `format_description`, and `format_change` to handle specific formatting tasks.

2. **Updated `create_entry` Function**:
    - Now returns an instance of `LedgerEntry`.

3. **Refactored `format_entries` Function**:
    - Simplified the header generation using a conditional based on `locale`.
    - Used the `sort` method with a lambda function for sorting entries.
    - Utilized the `format_date`, `format_description`, and `format_change` methods from `LedgerEntry` for formatting.
    - Joined the formatted entries into a single string with `\n`.

4. **Handled Locale-Specific Date Formatting**:
    - Used `strftime` for locale-specific date formatting within the `LedgerEntry` class.

5. **Handled Currency Formatting**:
    - Simplified currency formatting logic by directly formatting the string within the `format_change` method.

### Benefits of Refactoring

- **Readability**: The code is now more modular and easier to understand.
- **Maintainability**: Each functionality is encapsulated within methods, making it easier to manage and extend.
- **Reusability**: The `LedgerEntry` class can be reused and extended for other purposes.

The refactored code maintains all the functionality of the original code while being more readable, maintainable, and extendable.

Here's the implementation of the Hangman game with the logic and exception handling required:

```python
# Game status categories
# Change the values as you see fit
STATUS_WIN = 'win'
STATUS_LOSE = 'lose'
STATUS_ONGOING = 'ongoing'


class Hangman:
    def __init__(self, word):
        self.word = word
        self.remaining_guesses = 9
        self.status = STATUS_ONGOING
        self.guessed_letters = set()
        self.masked_word = ['_' for _ in word]

    def guess(self, char):
        if self.status != STATUS_ONGOING:
            raise ValueError("The game has already ended.")

        if char in self.guessed_letters:
            return

        self.guessed_letters.add(char)

        if char in self.word:
            for i, c in enumerate(self.word):
                if c == char:
                    self.masked_word[i] = char
            if '_' not in self.masked_word:
                self.status = STATUS_WIN
        else:
            self.remaining_guesses -= 1
            if self.remaining_guesses < 0:
                self.status = STATUS_LOSE

    def get_masked_word(self):
        return ''.join(self.masked_word)

    def get_status(self):
        return self.status
```

### Explanation
1. **Initialization**:
    - `self.word`: The word to guess.
    - `self.remaining_guesses`: Number of guesses remaining, set to 9.
    - `self.status`: Game status, initially set to `STATUS_ONGOING`.
    - `self.guessed_letters`: Set of letters guessed so far.
    - `self.masked_word`: List representing the masked word (using `_` for unguessed letters).

2. **Guess Method**:
    - Checks if the game is ongoing. If not, raises a `ValueError` with the message "The game has already ended."
    - Checks if the letter has already been guessed. If so, it returns immediately.
    - Adds the guessed letter to the set of guessed letters.
    - If the guessed letter is in the word, it updates the masked word.
    - If the entire word is guessed, it updates the status to `STATUS_WIN`.
    - If the guessed letter is not in the word, it decreases the remaining guesses. If the remaining guesses are less than 0, it updates the status to `STATUS_LOSE`.

3. **Get Masked Word Method**:
    - Returns the current state of the masked word as a string.

4. **Get Status Method**:
    - Returns the current status of the game.

### Example Usage
```python
game = Hangman('python')
game.guess('p')
print(game.get_masked_word())  # Output: p_____
game.guess('y')
print(game.get_masked_word())  # Output: py____
game.guess('o')
print(game.get_masked_word())  # Output: pytho_
print(game.get_status())       # Output: ongoing
game.guess('n')
print(game.get_masked_word())  # Output: python
print(game.get_status())       # Output: win
```

This implementation ensures that the game logic is correctly handled and provides the required exception handling for attempts to continue playing after the game has ended.

Here's the implementation of the `Board` class with the required methods and exception handling:

```python
class Board:
    """Count territories of each player in a Go game

    Args:
        board (list[str]): A two-dimensional Go board
    """

    def __init__(self, board):
        self.board = board
        self.rows = len(board)
        self.cols = len(board[0]) if board else 0
        self.visited = set()

    def territory(self, x, y):
        """Find the owner and the territories given a coordinate on the board

        Args:
            x (int): Column on the board
            y (int): Row on the board

        Returns:
            (str, set): A tuple, the first element being the owner
                        of that area.  One of "W", "B", "".  The
                        second being a set of coordinates, representing
                        the owner's territories.
        """
        if not (0 <= x < self.cols and 0 <= y < self.rows):
            raise ValueError('Invalid coordinate')

        if self.board[y][x] != ' ':
            return '', set()

        territory, border_colors = self._explore_territory(x, y)
        owner = self._determine_owner(border_colors)

        return owner, territory

    def territories(self):
        """Find the owners and the territories of the whole board

        Args:
            none

        Returns:
            dict(str, set): A dictionary whose key being the owner
                        , i.e. "W", "B", "".  The value being a set
                        of coordinates owned by the owner.
        """
        territories = {'W': set(), 'B': set(), '': set()}

        for y in range(self.rows):
            for x in range(self.cols):
                if (x, y) not in self.visited and self.board[y][x] == ' ':
                    owner, territory = self.territory(x, y)
                    territories[owner].update(territory)

        return territories

    def _explore_territory(self, x, y):
        stack = [(x, y)]
        territory = set()
        border_colors = set()
        while stack:
            cx, cy = stack.pop()
            if (cx, cy) in self.visited:
                continue
            self.visited.add((cx, cy))
            territory.add((cx, cy))

            for nx, ny in self._neighbors(cx, cy):
                if self.board[ny][nx] == ' ' and (nx, ny) not in self.visited:
                    stack.append((nx, ny))
                elif self.board[ny][nx] in 'WB':
                    border_colors.add(self.board[ny][nx])

        return territory, border_colors

    def _determine_owner(self, border_colors):
        if len(border_colors) == 1:
            return border_colors.pop()
        return ''

    def _neighbors(self, x, y):
        neighbors = []
        if x > 0:
            neighbors.append((x - 1, y))
        if x < self.cols - 1:
            neighbors.append((x + 1, y))
        if y > 0:
            neighbors.append((x, y - 1))
        if y < self.rows - 1:
            neighbors.append((x, y + 1))
        return neighbors
```

### Explanation
1. **Initialization (`__init__` method)**:
    - Stores the board and its dimensions.
    - Initializes an empty set to keep track of visited coordinates.

2. **Territory (`territory` method)**:
    - Checks if the given coordinates are valid. Raises `ValueError` with the message 'Invalid coordinate' if they are not.
    - If the given position is not an empty intersection (' '), returns an empty string and an empty set.
    - Otherwise, explores the territory starting from the given coordinates.
    - Determines the owner based on the colors found around the territory.

3. **Territories (`territories` method)**:
    - Iterates over each cell on the board.
    - For each unvisited empty cell, calls the `territory` method to determine the territory and its owner.
    - Aggregates territories by owner in a dictionary.

4. **Helper Methods**:
    - `_explore_territory`: Uses a stack-based approach to explore the territory from a starting coordinate. Tracks the territory and bordering colors.
    - `_determine_owner`: Determines the owner of a territory based on bordering colors.
    - `_neighbors`: Returns the valid neighboring coordinates for a given cell.

### Example Usage
```python
board = [
    "  B  ",
    " B B ",
    "B W B",
    " W W ",
    "  W  "
]

game = Board(board)
print(game.territory(0, 1))  # Output: ('', {(0, 1), (0, 0), (1, 0)})
print(game.territories())
# Output: {'W': set(), 'B': set(), '': {(1, 1), (0, 1), (0, 0), (1, 0), (2, 1)}}
```

Here's a comprehensive implementation of the Forth evaluator, along with custom exception handling for stack underflow errors:

```python
class StackUnderflowError(Exception):
    """Exception raised when Stack is not full.
       message: explanation of the error.
    """
    def __init__(self, message):
        self.message = message

class ForthEvaluator:
    def __init__(self):
        self.stack = []
        self.definitions = {}

    def evaluate(self, input_data):
        instructions = self._tokenize(input_data)
        i = 0
        while i < len(instructions):
            token = instructions[i].upper()
            if token.isdigit() or (token[0] == '-' and token[1:].isdigit()):
                self.stack.append(int(token))
            elif token in self.definitions:
                for definition_token in self.definitions[token]:
                    self._execute_token(definition_token)
            elif token == ':':
                i = self._define_word(instructions, i)
            else:
                self._execute_token(token)
            i += 1

    def _tokenize(self, input_data):
        return input_data.split()

    def _define_word(self, instructions, start_index):
        end_index = start_index + 1
        while instructions[end_index] != ';':
            end_index += 1
        word_name = instructions[start_index + 1].upper()
        definition = instructions[start_index + 2:end_index]
        self.definitions[word_name] = definition
        return end_index

    def _execute_token(self, token):
        if token == '+':
            self._check_stack(2)
            self.stack.append(self.stack.pop() + self.stack.pop())
        elif token == '-':
            self._check_stack(2)
            b, a = self.stack.pop(), self.stack.pop()
            self.stack.append(a - b)
        elif token == '*':
            self._check_stack(2)
            self.stack.append(self.stack.pop() * self.stack.pop())
        elif token == '/':
            self._check_stack(2)
            b, a = self.stack.pop(), self.stack.pop()
            if b == 0:
                raise ZeroDivisionError("Division by zero is not allowed.")
            self.stack.append(a // b)
        elif token == 'DUP':
            self._check_stack(1)
            self.stack.append(self.stack[-1])
        elif token == 'DROP':
            self._check_stack(1)
            self.stack.pop()
        elif token == 'SWAP':
            self._check_stack(2)
            self.stack[-1], self.stack[-2] = self.stack[-2], self.stack[-1]
        elif token == 'OVER':
            self._check_stack(2)
            self.stack.append(self.stack[-2])
        else:
            raise ValueError(f"Unknown word: {token}")

    def _check_stack(self, num_items):
        if len(self.stack) < num_items:
            raise StackUnderflowError("Insufficient number of items in stack")

def evaluate(input_data):
    forth = ForthEvaluator()
    forth.evaluate(input_data)
    return forth.stack
```

### Explanation

1. **Exception Handling**:
   - `StackUnderflowError`: Custom exception for handling stack underflow errors.
   
2. **ForthEvaluator Class**:
   - **`__init__`**: Initializes the stack and a dictionary for custom word definitions.
   - **`evaluate`**: Processes the input instructions. It handles numbers, predefined operations, and custom word definitions.
   - **`_tokenize`**: Splits the input data into individual tokens.
   - **`_define_word`**: Handles the definition of new words. It updates the custom definitions dictionary.
   - **`_execute_token`**: Executes the Forth commands, handling stack operations and predefined arithmetic operations.
   - **`_check_stack`**: Ensures the stack has enough items for the operation and raises `StackUnderflowError` if it doesn't.

3. **Operations**:
   - Handles arithmetic operations (`+`, `-`, `*`, `/`), ensuring there are at least two items on the stack.
   - Handles stack manipulation operations (`DUP`, `DROP`, `SWAP`, `OVER`).
   - Custom word definitions are stored and expanded as needed.

### Usage Example
```python
commands = "10 2 + DUP * : square DUP * ; 4 square"
print(evaluate(commands))  # Output: [144]
```

This implementation ensures the Forth evaluator handles all specified operations and provides meaningful error messages when stack underflows occur.

class TreeNode:
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

    def __str__(self):
        return f'TreeNode(data={self.data}, left={self.left}, right={self.right})'


class BinarySearchTree:
    def __init__(self, tree_data):
        self.root = None
        for value in tree_data:
            self.insert(value)

    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)

    def _insert_recursive(self, node, data):
        if data <= node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)

    def data(self):
        return self.root

    def sorted_data(self):
        return self._inorder_traversal(self.root)

    def _inorder_traversal(self, node):
        if node is None:
            return []
        return self._inorder_traversal(node.left) + [node.data] + self._inorder_traversal(node.right)

# Example usage:
tree = BinarySearchTree([4, 2, 5, 1, 3])
print(tree.data())  # Output: TreeNode(data=4, left=TreeNode(data=2, left=TreeNode(data=1, left=None, right=None), right=TreeNode(data=3, left=None, right=None)), right=TreeNode(data=5, left=None, right=None))
print(tree.sorted_data())  # Output: [1, 2, 3, 4, 5]


import math

def gcd(a, b):
    """Compute the greatest common divisor of a and b"""
    while b != 0:
        a, b = b, a % b
    return abs(a)

class Rational:
    def __init__(self, numer, denom):
        if denom == 0:
            raise ValueError("Denominator cannot be zero")
        common = gcd(numer, denom)
        self.numer = numer // common
        self.denom = denom // common
        if self.denom < 0:  # ensure the denominator is positive
            self.numer = -self.numer
            self.denom = -self.denom

    def __eq__(self, other):
        return self.numer == other.numer and self.denom == other.denom

    def __repr__(self):
        return f'{self.numer}/{self.denom}'

    def __add__(self, other):
        numer = self.numer * other.denom + other.numer * self.denom
        denom = self.denom * other.denom
        return Rational(numer, denom)

    def __sub__(self, other):
        numer = self.numer * other.denom - other.numer * self.denom
        denom = self.denom * other.denom
        return Rational(numer, denom)

    def __mul__(self, other):
        numer = self.numer * other.numer
        denom = self.denom * other.denom
        return Rational(numer, denom)

    def __truediv__(self, other):
        if other.numer == 0:
            raise ZeroDivisionError("Cannot divide by zero")
        numer = self.numer * other.denom
        denom = self.denom * other.numer
        return Rational(numer, denom)

    def __abs__(self):
        return Rational(abs(self.numer), abs(self.denom))

    def __pow__(self, power):
        if isinstance(power, int):
            if power >= 0:
                return Rational(self.numer ** power, self.denom ** power)
            else:
                return Rational(self.denom ** abs(power), self.numer ** abs(power))
        elif isinstance(power, float):
            return (self.numer ** power) / (self.denom ** power)
        else:
            raise TypeError("Power must be an integer or a float")

    def __rpow__(self, base):
        return base ** (self.numer / self.denom)

# Example usage:
r1 = Rational(4, 5)
r2 = Rational(2, 3)
print(r1 + r2)  # Output: 22/15
print(r1 - r2)  # Output: 2/15
print(r1 * r2)  # Output: 8/15
print(r1 / r2)  # Output: 6/5
print(abs(Rational(-3, 4)))  # Output: 3/4
print(r1 ** 2)  # Output: 16/25
print(2 ** r2)  # Output: 1.5874010519681994 (which is 2^(2/3))


class BowlingGame:
    def __init__(self):
        self.rolls = []
        self.current_roll = 0

    def roll(self, pins):
        if pins < 0 or pins > 10:
            raise ValueError("Invalid number of pins")
        if len(self.rolls) >= 21:
            raise IndexError("Cannot roll after game is over")
        self.rolls.append(pins)

    def score(self):
        score = 0
        roll_index = 0
        for frame in range(10):
            if self.is_strike(roll_index):
                score += 10 + self.strike_bonus(roll_index)
                roll_index += 1
            elif self.is_spare(roll_index):
                score += 10 + self.spare_bonus(roll_index)
                roll_index += 2
            else:
                score += self.sum_of_balls_in_frame(roll_index)
                roll_index += 2
        if len(self.rolls) > roll_index:
            raise ValueError("Too many rolls")
        return score

    def is_strike(self, roll_index):
        return self.rolls[roll_index] == 10

    def is_spare(self, roll_index):
        return self.rolls[roll_index] + self.rolls[roll_index + 1] == 10

    def strike_bonus(self, roll_index):
        return self.rolls[roll_index + 1] + self.rolls[roll_index + 2]

    def spare_bonus(self, roll_index):
        return self.rolls[roll_index + 2]

    def sum_of_balls_in_frame(self, roll_index):
        return self.rolls[roll_index] + self.rolls[roll_index + 1]


def maximum_value(maximum_weight, items):
    # Create a 2D list to store the maximum value at each n-th item and weight w
    n = len(items)
    dp = [[0 for _ in range(maximum_weight + 1)] for _ in range(n + 1)]

    # Fill the dp array
    for i in range(1, n + 1):
        item_weight = items[i - 1]["weight"]
        item_value = items[i - 1]["value"]
        for w in range(maximum_weight + 1):
            if item_weight <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - item_weight] + item_value)
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][maximum_weight]

# Example usage
items = [
    { "weight": 5, "value": 10 },
    { "weight": 4, "value": 40 },
    { "weight": 6, "value": 30 },
    { "weight": 4, "value": 50 }
]

maximum_weight = 10
print(maximum_value(maximum_weight, items))  # Output should be 90


NODE, EDGE, ATTR = range(3)

class Node:
    def __init__(self, name, attrs):
        self.name = name
        self.attrs = attrs

    def __eq__(self, other):
        return self.name == other.name and self.attrs == other.attrs

    def __repr__(self):
        return f'Node(name={self.name}, attrs={self.attrs})'


class Edge:
    def __init__(self, src, dst, attrs):
        self.src = src
        self.dst = dst
        self.attrs = attrs

    def __eq__(self, other):
        return (self.src == other.src and
                self.dst == other.dst and
                self.attrs == other.attrs)

    def __repr__(self):
        return f'Edge(src={self.src}, dst={self.dst}, attrs={self.attrs})'


class Graph:
    def __init__(self, data=None):
        self.nodes = []
        self.edges = []
        self.attrs = {}
        if data:
            self.parse_data(data)

    def parse_data(self, data):
        if not isinstance(data, list):
            raise TypeError("Graph data malformed")
        
        for item in data:
            if not isinstance(item, tuple) or len(item) != 3:
                raise TypeError("Graph data malformed")

            item_type, identifier, attributes = item
            if item_type == NODE:
                self.add_node(identifier, attributes)
            elif item_type == EDGE:
                self.add_edge(identifier, attributes)
            elif item_type == ATTR:
                self.add_attr(identifier, attributes)
            else:
                raise TypeError("Graph data malformed")

    def add_node(self, name, attrs):
        if not isinstance(name, str) or not isinstance(attrs, dict):
            raise ValueError("NODE malformed")
        self.nodes.append(Node(name, attrs))

    def add_edge(self, endpoints, attrs):
        if (not isinstance(endpoints, tuple) or len(endpoints) != 2 or
            not isinstance(attrs, dict)):
            raise ValueError("EDGE malformed")
        src, dst = endpoints
        if not isinstance(src, str) or not isinstance(dst, str):
            raise ValueError("EDGE malformed")
        self.edges.append(Edge(src, dst, attrs))

    def add_attr(self, graph_attr, attrs):
        if not isinstance(graph_attr, str) or not isinstance(attrs, dict):
            raise ValueError("ATTR malformed")
        self.attrs[graph_attr] = attrs

    def __repr__(self):
        return f'Graph(nodes={self.nodes}, edges={self.edges}, attrs={self.attrs})'


class CustomSet:
    def __init__(self, elements=[]):
        self.elements = list(dict.fromkeys(elements))  # Ensure elements are unique

    def isempty(self):
        return len(self.elements) == 0

    def __contains__(self, element):
        return element in self.elements

    def issubset(self, other):
        return all(elem in other.elements for elem in self.elements)

    def isdisjoint(self, other):
        return all(elem not in other.elements for elem in self.elements)

    def __eq__(self, other):
        return sorted(self.elements) == sorted(other.elements)

    def add(self, element):
        if element not in self.elements:
            self.elements.append(element)

    def intersection(self, other):
        return CustomSet([elem for elem in self.elements if elem in other.elements])

    def __sub__(self, other):
        return CustomSet([elem for elem in self.elements if elem not in other.elements])

    def __add__(self, other):
        return CustomSet(self.elements + [elem for elem in other.elements if elem not in self.elements])

    def __repr__(self):
        return f'CustomSet({self.elements})'


def drinks_water():
    return solve_zebra_puzzle()[0]

def owns_zebra():
    return solve_zebra_puzzle()[1]

def solve_zebra_puzzle():
    from itertools import permutations

    # There are five houses with attributes: color, nationality, pet, drink, cigarette
    colors = ['red', 'green', 'ivory', 'yellow', 'blue']
    nationalities = ['Englishman', 'Spaniard', 'Ukrainian', 'Norwegian', 'Japanese']
    pets = ['dog', 'snails', 'fox', 'horse', 'zebra']
    drinks = ['coffee', 'tea', 'milk', 'orange juice', 'water']
    cigarettes = ['Old Gold', 'Kools', 'Chesterfields', 'Lucky Strike', 'Parliaments']
    
    for color in permutations(colors):
        if color.index('green') == color.index('ivory') + 1:
            for nationality in permutations(nationalities):
                if (nationality[0] == 'Norwegian' and
                    nationality[color.index('red')] == 'Englishman' and
                    nationality[color.index('blue') - 1] == 'Norwegian' and
                    nationality[4] != 'Norwegian'):
                    for pet in permutations(pets):
                        if (pet[nationality.index('Spaniard')] == 'dog' and
                            pet[cigarettes.index('Old Gold')] == 'snails' and
                            abs(pet.index('fox') - cigarettes.index('Chesterfields')) == 1 and
                            abs(pet.index('horse') - cigarettes.index('Kools')) == 1):
                            for drink in permutations(drinks):
                                if (drink[2] == 'milk' and
                                    drink[color.index('green')] == 'coffee' and
                                    drink[nationality.index('Ukrainian')] == 'tea' and
                                    drink[cigarettes.index('Lucky Strike')] == 'orange juice'):
                                    for cigarette in permutations(cigarettes):
                                        if (cigarette[color.index('yellow')] == 'Kools' and
                                            cigarette[nationality.index('Japanese')] == 'Parliaments'):
                                            houses = list(zip(color, nationality, pet, drink, cigarette))
                                            for house in houses:
                                                if house[3] == 'water':
                                                    water_drinker = house[1]
                                                if house[2] == 'zebra':
                                                    zebra_owner = house[1]
                                            return water_drinker, zebra_owner

# Example usage:
print("Resident who drinks water:", drinks_water())
print("Resident who owns the zebra:", owns_zebra())


def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def mod_inverse(a, m):
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError("a and m must be coprime.")

def check_coprime(a, m):
    if gcd(a, m) != 1:
        raise ValueError("a and m must be coprime.")

def process_text(text):
    return ''.join([char.lower() for char in text if char.isalnum()])

def encode(plain_text, a, b):
    m = 26
    check_coprime(a, m)
    processed_text = process_text(plain_text)
    encoded_chars = []
    for char in processed_text:
        if char.isdigit():
            encoded_chars.append(char)
        else:
            x = ord(char) - ord('a')
            encoded_char = (a * x + b) % m
            encoded_chars.append(chr(encoded_char + ord('a')))
    encoded_text = ''.join(encoded_chars)
    return ' '.join([encoded_text[i:i+5] for i in range(0, len(encoded_text), 5)])

def decode(ciphered_text, a, b):
    m = 26
    check_coprime(a, m)
    a_inv = mod_inverse(a, m)
    processed_text = process_text(ciphered_text)
    decoded_chars = []
    for char in processed_text:
        if char.isdigit():
            decoded_chars.append(char)
        else:
            y = ord(char) - ord('a')
            decoded_char = (a_inv * (y - b)) % m
            decoded_chars.append(chr(decoded_char + ord('a')))
    return ''.join(decoded_chars)

# Example usage:
print(encode("test", 5, 7))  # Output: "ybty"
print(decode("ybty", 5, 7))  # Output: "test"


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __repr__(self):
        return f"Point({self.x}, {self.y})"

class WordSearch:
    def __init__(self, puzzle):
        self.puzzle = puzzle
        self.rows = len(puzzle)
        self.cols = len(puzzle[0]) if self.rows > 0 else 0
        self.directions = [
            (0, 1),   # Left to Right
            (0, -1),  # Right to Left
            (1, 0),   # Top to Bottom
            (-1, 0),  # Bottom to Top
            (1, 1),   # Diagonal Top-left to Bottom-right
            (-1, -1), # Diagonal Bottom-right to Top-left
            (1, -1),  # Diagonal Bottom-left to Top-right
            (-1, 1)   # Diagonal Top-right to Bottom-left
        ]

    def search(self, word):
        for row in range(self.rows):
            for col in range(self.cols):
                for direction in self.directions:
                    if self._search_from(word, row, col, direction):
                        start = Point(row, col)
                        end = Point(row + (len(word) - 1) * direction[0],
                                    col + (len(word) - 1) * direction[1])
                        return (start, end)
        return None

    def _search_from(self, word, row, col, direction):
        for i in range(len(word)):
            new_row = row + i * direction[0]
            new_col = col + i * direction[1]
            if not (0 <= new_row < self.rows and 0 <= new_col < self.cols):
                return False
            if self.puzzle[new_row][new_col] != word[i]:
                return False
        return True

# Example usage:
puzzle = [
    "jefblpepre",
    "camdcimgtc",
    "oivokprjsm",
    "pbwasqroua",
    "rixilelhrs",
    "wolcqlirpc",
    "screeaumgr",
    "alxhpburyi",
    "jalaycalmp",
    "clojurermt"
]

ws = WordSearch(puzzle)
print(ws.search("clojure"))  # Example output: (Point(9, 0), Point(9, 6))
print(ws.search("python"))   # Should return None if the word is not found


import re
from itertools import permutations

def solve(puzzle):
    # Extract unique letters from the puzzle
    letters = ''.join(set(re.findall(r'[A-Z]', puzzle)))
    
    if len(letters) > 10:
        raise ValueError("Too many letters in the puzzle")

    # Create the formula for eval
    formula = re.sub(r'([A-Z])', r'{\1}', puzzle)
    
    for perm in permutations('0123456789', len(letters)):
        table = str.maketrans(letters, ''.join(perm))
        try:
            if eval(formula.translate(table)):
                return {letters[i]: int(perm[i]) for i in range(len(letters))}
        except:
            continue
    
    return None

# Example usage
puzzle = "SEND + MORE == MONEY"
solution = solve(puzzle)
print(solution)

import threading

class BankAccount:
    def __init__(self):
        self.balance = 0
        self.lock = threading.Lock()
        self.is_open = False

    def get_balance(self):
        with self.lock:
            if not self.is_open:
                raise ValueError('account not open')
            return self.balance

    def open(self):
        with self.lock:
            if self.is_open:
                raise ValueError('account already open')
            self.is_open = True
            self.balance = 0

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError('amount must be greater than 0')
        with self.lock:
            if not self.is_open:
                raise ValueError('account not open')
            self.balance += amount

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError('amount must be greater than 0')
        with self.lock:
            if not self.is_open:
                raise ValueError('account not open')
            if amount > self.balance:
                raise ValueError('amount must be less than balance')
            self.balance -= amount

    def close(self):
        with self.lock:
            if not self.is_open:
                raise ValueError('account not open')
            self.is_open = False
            self.balance = 0


class InputCell:
    def __init__(self, initial_value):
        self.value = initial_value
        self._observers = []

    def set_value(self, new_value):
        if new_value != self.value:
            self.value = new_value
            self._notify_observers()

    def _notify_observers(self):
        for observer in self._observers:
            observer()

    def add_observer(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def remove_observer(self, observer):
        if observer in self._observers:
            self._observers.remove(observer)


class ComputeCell:
    def __init__(self, inputs, compute_function):
        self.inputs = inputs
        self.compute_function = compute_function
        self._observers = []
        self._callbacks = []
        self._value = self._compute_value()

        for input_cell in self.inputs:
            input_cell.add_observer(self._recompute)

    def _compute_value(self):
        return self.compute_function([input_cell.value for input_cell in self.inputs])

    @property
    def value(self):
        return self._value

    def _recompute(self):
        new_value = self._compute_value()
        if new_value != self._value:
            old_value = self._value
            self._value = new_value
            self._notify_observers()
            self._notify_callbacks(old_value, new_value)

    def _notify_observers(self):
        for observer in self._observers:
            observer()

    def _notify_callbacks(self, old_value, new_value):
        for callback in self._callbacks:
            callback(new_value)

    def add_callback(self, callback):
        if callback not in self._callbacks:
            self._callbacks.append(callback)

    def remove_callback(self, callback):
        if callback in self._callbacks:
            self._callbacks.remove(callback)


class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class Zipper:
    def __init__(self, tree, path=[]):
        self.tree = tree
        self.path = path

    @staticmethod
    def from_tree(tree):
        return Zipper(tree)

    def to_tree(self):
        z = self
        while z.up() is not None:
            z = z.up()
        return z.tree

    def value(self):
        return self.tree.value

    def set_value(self, value):
        return Zipper(Node(value, self.tree.left, self.tree.right), self.path)

    def left(self):
        if self.tree.left is None:
            return None
        return Zipper(self.tree.left, [(self.tree, 'left', self.tree.right)] + self.path)

    def set_left(self, left):
        return Zipper(Node(self.tree.value, left, self.tree.right), self.path)

    def right(self):
        if self.tree.right is None:
            return None
        return Zipper(self.tree.right, [(self.tree, 'right', self.tree.left)] + self.path)

    def set_right(self, right):
        return Zipper(Node(self.tree.value, self.tree.left, right), self.path)

    def up(self):
        if not self.path:
            return None
        parent, direction, sibling = self.path[0]
        if direction == 'left':
            return Zipper(Node(parent.value, self.tree, sibling), self.path[1:])
        else:
            return Zipper(Node(parent.value, sibling, self.tree), self.path[1:])

# Example Usage:
# Construct a simple binary tree
root = Node(1, Node(2), Node(3))

# Create a zipper focused on the root of the tree
zipper = Zipper.from_tree(root)

# Navigate to the left child
left_z = zipper.left()
print(left_z.value())  # Output: 2

# Set a new value to the left child
new_z = left_z.set_value(4)
print(new_z.value())  # Output: 4

# Convert the zipper back to a tree
new_tree = new_z.to_tree()
print(new_tree.left.value)  # Output: 4


from collections import deque

def measure(bucket_one, bucket_two, goal, start_bucket):
    # Define initial state based on starting bucket
    if start_bucket == "one":
        initial_state = (bucket_one, 0, 1)
    elif start_bucket == "two":
        initial_state = (0, bucket_two, 2)
    else:
        raise ValueError("Invalid start bucket. Must be 'one' or 'two'.")

    queue = deque([initial_state])
    visited = set()
    visited.add((initial_state[0], initial_state[1]))

    while queue:
        current_one, current_two, actions = queue.popleft()
        
        # Check if we have reached the goal
        if current_one == goal:
            return (actions, 1, current_two)
        if current_two == goal:
            return (actions, 2, current_one)
        
        # Generate all possible states
        possible_states = [
            (bucket_one, current_two),  # Fill bucket one
            (current_one, bucket_two),  # Fill bucket two
            (0, current_two),           # Empty bucket one
            (current_one, 0),           # Empty bucket two
            (max(0, current_one - (bucket_two - current_two)), min(bucket_two, current_two + current_one)),  # Pour one into two
            (min(bucket_one, current_one + current_two), max(0, current_two - (bucket_one - current_one)))   # Pour two into one
        ]
        
        for next_one, next_two in possible_states:
            if (next_one, next_two) not in visited:
                visited.add((next_one, next_two))
                queue.append((next_one, next_two, actions + 1))
    
    raise ValueError("It's not possible to measure the goal with the given bucket sizes.")

# Example usage:
print(measure(3, 5, 4, "one"))  # should return (6, 2, 0)


from collections import defaultdict

def can_chain(dominoes):
    def backtrack(chain):
        if len(chain) == len(dominoes):
            return chain[0][0] == chain[-1][1]
        
        last_num = chain[-1][1]
        for i in range(len(dominoes)):
            if not used[i]:
                domino = dominoes[i]
                if domino[0] == last_num or domino[1] == last_num:
                    used[i] = True
                    if domino[0] == last_num:
                        chain.append(domino)
                    else:
                        chain.append((domino[1], domino[0]))
                    
                    if backtrack(chain):
                        return True
                    
                    chain.pop()
                    used[i] = False
        return False
    
    if not dominoes:
        return True

    used = [False] * len(dominoes)
    for i in range(len(dominoes)):
        used[i] = True
        chain = [dominoes[i]]
        if backtrack(chain):
            return True
        used[i] = False

    return False

# Example usage:
print(can_chain([(2, 1), (2, 3), (1, 3)]))  # True
print(can_chain([(1, 2), (4, 1), (2, 3)]))  # False


class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def tree_from_traversals(preorder, inorder):
    # Validations
    if len(preorder) != len(inorder):
        raise ValueError("traversals must have the same length")
    if set(preorder) != set(inorder):
        raise ValueError("traversals must have the same elements")
    if len(preorder) != len(set(preorder)):
        raise ValueError("traversals must contain unique items")

    # Helper function to build the tree
    def build_tree(pre_start, pre_end, in_start, in_end, pre_index_map, in_index_map):
        if pre_start > pre_end or in_start > in_end:
            return None
        
        # Root is always the first element in preorder list for the current subtree
        root_value = preorder[pre_start]
        root = TreeNode(root_value)

        # Root index in inorder list
        root_in_index = in_index_map[root_value]
        left_subtree_size = root_in_index - in_start
        
        # Recursively build left and right subtrees
        root.left = build_tree(pre_start + 1, pre_start + left_subtree_size, in_start, root_in_index - 1, pre_index_map, in_index_map)
        root.right = build_tree(pre_start + left_subtree_size + 1, pre_end, root_in_index + 1, in_end, pre_index_map, in_index_map)
        
        return root

    # Build index maps for quick lookups
    pre_index_map = {value: idx for idx, value in enumerate(preorder)}
    in_index_map = {value: idx for idx, value in enumerate(inorder)}

    # Build the tree
    return build_tree(0, len(preorder) - 1, 0, len(inorder) - 1, pre_index_map, in_index_map)

# Example usage
preorder = ['a', 'i', 'x', 'f', 'r']
inorder = ['i', 'a', 'f', 'x', 'r']
tree = tree_from_traversals(preorder, inorder)


def total(basket):
    # Prices and discounts
    book_price = 8
    discounts = [0, 0, 0.05, 0.1, 0.2, 0.25]

    # Count the frequency of each book
    from collections import Counter
    counts = Counter(basket)

    # Base case: If basket is empty, total cost is 0
    if not counts:
        return 0.0

    # Function to calculate the price of a given group
    def calculate_group_price(group):
        num_books = len(group)
        discount = discounts[num_books]
        return num_books * book_price * (1 - discount)

    # Recursive function to find minimum cost
    def find_minimum_cost(counts):
        # Convert counts to a sorted list of frequencies
        freq_list = sorted(counts.values(), reverse=True)
        
        # If all counts are zero, we're done
        if freq_list[0] == 0:
            return 0

        # Try to form groups of different sizes and calculate their costs
        min_cost = float('inf')
        for group_size in range(1, 6):
            if len(freq_list) >= group_size and freq_list[group_size - 1] > 0:
                # Form a group of 'group_size' different books
                new_counts = counts.copy()
                for i in range(group_size):
                    new_counts[i] -= 1
                    if new_counts[i] == 0:
                        del new_counts[i]

                # Calculate cost of this group and the remaining books
                cost = calculate_group_price(range(group_size)) + find_minimum_cost(new_counts)
                min_cost = min(min_cost, cost)

        return min_cost

    return round(find_minimum_cost(counts), 2)

# Example usage:
basket = [1, 1, 2, 2, 3, 3, 4, 5]
print(total(basket))  # Output should be 51.20


class SgfTree:
    def __init__(self, properties=None, children=None):
        self.properties = properties or {}
        self.children = children or []

    def __eq__(self, other):
        if not isinstance(other, SgfTree):
            return False
        return self.properties == other.properties and self.children == other.children

    def __ne__(self, other):
        return not self == other

def parse(input_string):
    if not input_string or not input_string.startswith('(') or not input_string.endswith(')'):
        raise ValueError("tree missing")

    def parse_node(substring):
        properties = {}
        children = []
        i = 0
        while i < len(substring):
            if substring[i].isupper():
                key = substring[i]
                i += 1
                if i >= len(substring) or substring[i] != '[':
                    raise ValueError("properties without delimiter")
                values = []
                while i < len(substring) and substring[i] == '[':
                    i += 1
                    value = ''
                    while i < len(substring) and substring[i] != ']':
                        if substring[i] == '\\':
                            i += 1
                            if i < len(substring):
                                value += substring[i]
                        else:
                            value += substring[i]
                        i += 1
                    if i >= len(substring):
                        raise ValueError("properties without delimiter")
                    values.append(value)
                    i += 1
                properties[key] = values
            elif substring[i] == '(':
                subtree, i = parse_subtree(substring, i)
                children.append(subtree)
            elif substring[i] == ';':
                i += 1
            else:
                raise ValueError("property must be in uppercase")
        return SgfTree(properties, children)

    def parse_subtree(substring, start_index):
        if substring[start_index] != '(':
            raise ValueError("tree with no nodes")
        nodes = []
        i = start_index + 1
        while i < len(substring) and substring[i] != ')':
            if substring[i] == ';':
                i += 1
                node, i = parse_node(substring, i)
                nodes.append(node)
            elif substring[i] == '(':
                subtree, i = parse_subtree(substring, i)
                nodes[-1].children.append(subtree)
            else:
                i += 1
        if i >= len(substring):
            raise ValueError("tree with no nodes")
        return nodes[0], i + 1

    root, _ = parse_subtree(input_string, 0)
    return root

# Test the implementation
if __name__ == "__main__":
    sgf_string = "(;FF[4]C[root]SZ[19];B[aa];W[ab])"
    expected = SgfTree(
        properties={'FF': ['4'], 'C': ['root'], 'SZ': ['19']},
        children=[
            SgfTree(properties={'B': ['aa']}, children=[
                SgfTree(properties={'W': ['ab']}, children=[])
            ])
        ]
    )
    result = parse(sgf_string)
    print(result == expected)  # Should print True


import io
import socket


class MeteredFile(io.BufferedRandom):
    """Implement using a subclassing model."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._read_bytes = 0
        self._read_ops = 0
        self._write_bytes = 0
        self._write_ops = 0

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __iter__(self):
        return self

    def __next__(self):
        line = self.readline()
        if line:
            return line
        else:
            raise StopIteration

    def read(self, size=-1):
        data = super().read(size)
        self._read_bytes += len(data)
        self._read_ops += 1
        return data

    @property
    def read_bytes(self):
        return self._read_bytes

    @property
    def read_ops(self):
        return self._read_ops

    def write(self, b):
        bytes_written = super().write(b)
        self._write_bytes += bytes_written
        self._write_ops += 1
        return bytes_written

    @property
    def write_bytes(self):
        return self._write_bytes

    @property
    def write_ops(self):
        return self._write_ops


class MeteredSocket:
    """Implement using a delegation model."""

    def __init__(self, socket):
        self._socket = socket
        self._recv_bytes = 0
        self._recv_ops = 0
        self._send_bytes = 0
        self._send_ops = 0

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._socket.close()

    def recv(self, bufsize, flags=0):
        data = self._socket.recv(bufsize, flags)
        self._recv_bytes += len(data)
        self._recv_ops += 1
        return data

    @property
    def recv_bytes(self):
        return self._recv_bytes

    @property
    def recv_ops(self):
        return self._recv_ops

    def send(self, data, flags=0):
        bytes_sent = self._socket.send(data, flags)
        self._send_bytes += bytes_sent
        self._send_ops += 1
        return bytes_sent

    @property
    def send_bytes(self):
        return self._send_bytes

    @property
    def send_ops(self):
        return self._send_ops


# Example usage:
# with MeteredFile(open('example.txt', 'r+b')) as f:
#     f.read()
#     f.write(b"Hello World")
#     print(f.read_bytes, f.read_ops, f.write_bytes, f.write_ops)

# sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# wrapped_sock = MeteredSocket(sock)
# wrapped_sock.connect(('example.com', 80))
# wrapped_sock.send(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
# wrapped_sock.recv(4096)
# print(wrapped_sock.send_bytes, wrapped_sock.send_ops, wrapped_sock.recv_bytes, wrapped_sock.recv_ops)

import json

class RestAPI:
    def __init__(self, database=None):
        self.database = database or {'users': []}

    def get(self, url, payload=None):
        if url == "/users":
            return self._get_users(payload)
        return {}

    def post(self, url, payload=None):
        if url == "/add":
            return self._add_user(payload)
        elif url == "/iou":
            return self._add_iou(payload)
        return {}

    def _get_users(self, payload):
        if payload:
            user_names = json.loads(payload).get("users", [])
            users = [user for user in self.database['users'] if user['name'] in user_names]
        else:
            users = self.database['users']
        return json.dumps({"users": users})

    def _add_user(self, payload):
        new_user = json.loads(payload)
        new_user['owes'] = {}
        new_user['owed_by'] = {}
        new_user['balance'] = 0.0
        self.database['users'].append(new_user)
        return json.dumps(new_user)

    def _add_iou(self, payload):
        data = json.loads(payload)
        lender_name = data['lender']
        borrower_name = data['borrower']
        amount = data['amount']

        lender = next(user for user in self.database['users'] if user['name'] == lender_name)
        borrower = next(user for user in self.database['users'] if user['name'] == borrower_name)

        # Update the borrower's owed_by and owes
        if lender_name in borrower['owed_by']:
            borrower['owed_by'][lender_name] += amount
        else:
            borrower['owed_by'][lender_name] = amount

        if borrower_name in borrower['owes']:
            borrower['owes'][lender_name] -= amount
            if borrower['owes'][lender_name] == 0:
                del borrower['owes'][lender_name]
        else:
            borrower['owes'][lender_name] = -amount

        # Update the lender's owed_by and owes
        if borrower_name in lender['owes']:
            lender['owes'][borrower_name] += amount
        else:
            lender['owes'][borrower_name] = amount

        if lender_name in lender['owed_by']:
            lender['owed_by'][borrower_name] -= amount
            if lender['owed_by'][borrower_name] == 0:
                del lender['owed_by'][borrower_name]
        else:
            lender['owed_by'][borrower_name] = -amount

        # Update balances
        lender['balance'] += amount
        borrower['balance'] -= amount

        return json.dumps({"users": [borrower, lender]})

# Example usage:
database = {
    "users": [
        {
            "name": "Adam",
            "owes": {
                "Bob": 12.0,
                "Chuck": 4.0,
                "Dan": 9.5
            },
            "owed_by": {
                "Bob": 6.5,
                "Dan": 2.75
            },
            "balance": -16.25
        },
        {
            "name": "Bob",
            "owes": {
                "Chuck": 8.0
            },
            "owed_by": {
                "Adam": 12.0
            },
            "balance": 4.0
        }
    ]
}

api = RestAPI(database)
print(api.get("/users"))  # Get all users
print(api.post("/add", json.dumps({"name": "Eve"})))  # Add a new user
print(api.post("/iou", json.dumps({"lender": "Bob", "borrower": "Adam", "amount": 5.0})))  # Add an IOU


from json import dumps

class Tree:
    def __init__(self, label, children=None):
        self.label = label
        self.children = children if children is not None else []

    def __dict__(self):
        return {self.label: [c.__dict__() for c in sorted(self.children)]}

    def __str__(self, indent=None):
        return dumps(self.__dict__(), indent=indent)

    def __lt__(self, other):
        return self.label < other.label

    def __eq__(self, other):
        return self.__dict__() == other.__dict__()

    def from_pov(self, from_node):
        # Find the path from the current root to the from_node
        path = self._find_path(self, from_node, [])
        if not path:
            raise ValueError("Tree could not be reoriented")

        # Rebuild the tree from the perspective of from_node
        return self._build_subtree(from_node, None)

    def path_to(self, from_node, to_node):
        # Reorient the tree from the perspective of from_node
        new_tree = self.from_pov(from_node)
        
        # Find the path from from_node to to_node in the reoriented tree
        path = self._find_path(new_tree, to_node, [])
        if not path:
            raise ValueError("No path found")
        return path

    def _find_path(self, node, target, path):
        if node.label == target:
            return path + [node.label]
        for child in node.children:
            result = self._find_path(child, target, path + [node.label])
            if result:
                return result
        return None

    def _build_subtree(self, node_label, parent_label):
        # Create the subtree starting from node_label
        node = self._find_node(self, node_label)
        if not node:
            raise ValueError("Tree could not be reoriented")

        # Detach the node from its current parent and attach it to the new parent
        new_children = [self._build_subtree(child.label, node.label) for child in node.children if child.label != parent_label]
        if parent_label is not None:
            parent_node = self._find_node(self, parent_label)
            new_children.append(Tree(parent_label, [child for child in parent_node.children if child.label != node_label]))

        return Tree(node.label, new_children)

    def _find_node(self, node, target):
        if node.label == target:
            return node
        for child in node.children:
            result = self._find_node(child, target)
            if result:
                return result
        return None

# Example usage:
tree = Tree("a", [Tree("i", [Tree("f"), Tree("r")]), Tree("x", [Tree("l"), Tree("p")])])
print(tree)  # Print the original tree

new_tree = tree.from_pov("i")
print(new_tree)  # Print the tree from the perspective of "i"

path = tree.path_to("i", "r")
print(path)  # Print the path from "i" to "r"
