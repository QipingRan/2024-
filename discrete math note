https://faculty.ksu.edu.sa/sites/default/files/rosen_discrete_mathematics_and_its_applications_7th_edition.pdf


### 1 基础：逻辑与证明

逻辑与证明是数学和计算机科学中的基本概念，奠定了许多高级理论和应用的基础。通过理解和掌握逻辑和证明方法，我们可以更加严谨地进行数学推理和算法设计。

### 1.1 命题逻辑

命题逻辑是研究命题及其组合和推理规则的一门学科。命题逻辑中的基本单位是命题，它是一种可以确定真假的陈述。命题逻辑通过逻辑运算符（如与、或、非、蕴涵等）将简单命题组合成复杂命题，并利用真值表、推理规则等方法分析和推理命题的真假。

### 1.2 命题逻辑的应用

命题逻辑在许多领域都有广泛的应用。例如，在计算机科学中，命题逻辑被用于设计和验证数字电路、编写和优化程序、进行软件测试和验证等。此外，命题逻辑还在人工智能、数据库理论、形式化方法等领域发挥重要作用。通过命题逻辑，我们可以构建严谨的逻辑模型，解决复杂的实际问题。

### 1.3 命题等价

命题等价是指两个命题在所有情况下都具有相同的真值。这种等价关系可以通过逻辑恒等式或真值表来验证。理解命题等价关系有助于简化逻辑表达式，提高推理和计算效率。例如，通过将复杂的逻辑表达式化简为等价的简单表达式，我们可以更容易地进行逻辑运算和推理。

### 1.4 谓词和量词

谓词逻辑扩展了命题逻辑，通过引入谓词和量词（如全称量词和存在量词），可以表达更复杂的陈述。谓词是关于某个对象属性的陈述，量词则用于表示对象的数量限制。通过谓词和量词，我们可以描述和推理关于集合和关系的复杂逻辑。

### 1.5 嵌套量词

嵌套量词是指在一个逻辑表达式中同时使用多个量词，形成嵌套结构。嵌套量词可以表达更复杂的逻辑关系和条件。例如，数学中常用的全称量词和存在量词的嵌套，可以用来描述多变量函数、复杂的定理和证明过程。

### 1.6 推理规则

推理规则是从已知命题得出新命题的逻辑规则。常见的推理规则包括：合取规则、析取规则、假言规则等。掌握这些推理规则有助于我们在逻辑推理过程中进行有效的论证和证明。例如，通过应用推理规则，我们可以从已知事实和前提出发，推导出结论，证明命题的正确性。

### 1.7 证明简介

证明是逻辑推理的核心，指的是通过一系列逻辑推理，从前提得出结论的过程。证明方法有多种，包括直接证明、间接证明、反证法、数学归纳法等。通过学习和掌握各种证明方法，我们可以更加严谨和系统地进行逻辑推理和论证。

### 1.8 证明方法和策略

不同类型的命题需要采用不同的证明方法和策略。理解和选择合适的证明方法，可以提高证明的效率和准确性。例如，对于简单的命题，可以直接证明；对于复杂的命题，则可能需要分解为多个子命题，分别证明后再组合起来。此外，反证法和数学归纳法等特殊证明方法在解决某些特定类型问题时非常有效。

### 章节结尾材料

章节结尾材料通常包括复习题、练习题、总结和扩展阅读等。这些材料帮助读者巩固所学知识，练习和应用所学方法，并进一步拓展相关知识领域。通过系统的复习和练习，读者可以加深理解，提高逻辑推理和证明能力。

### 2 基本结构：集合、函数、序列、和与矩阵

这一章介绍了数学和计算机科学中的基本结构，包括集合、函数、序列、和与矩阵。这些基本结构是理解更复杂概念的基础，对解决实际问题具有重要意义。

### 2.1 集合

集合是数学中最基本的概念之一，指的是一些确定的、无序的对象的整体。集合中的对象称为元素。集合理论是现代数学的基础，通过集合可以定义和研究各种数学结构和关系。集合之间的关系和运算，如并集、交集和差集，是理解数学逻辑和证明的重要工具。

### 2.2 集合运算

集合运算是指对集合进行的各种操作，如并集、交集、补集和差集等。集合运算的结果也是一个集合，这些运算有助于我们理解和分析集合之间的关系。例如，通过并集运算可以得到两个集合中所有元素的集合，而交集运算则得到两个集合共有元素的集合。

### 2.3 函数

函数是描述两个集合之间映射关系的基本概念。一个函数将一个集合中的每个元素映射到另一个集合中的唯一元素。函数的定义域、值域和映射规则是理解函数的重要组成部分。函数在数学和计算机科学中有广泛应用，如数值计算、数据处理和算法设计等。

### 2.4 序列与求和

序列是按照一定顺序排列的一组元素，可以看作是定义在自然数集上的函数。序列在数列、时间序列分析等方面有重要应用。求和是对序列元素进行加法运算的过程，常用的符号是Σ。求和公式和技术在统计、概率和工程中有广泛应用。

### 2.5 集合的基数

集合的基数是指集合中元素的数量。有限集合的基数是有限的，自然数表示；而无限集合的基数是无限的，可以用无穷大的概念表示。理解集合的基数有助于我们分类和比较不同类型的集合，如可数集合和不可数集合。

### 2.6 矩阵

矩阵是由行和列组成的矩形数组，是线性代数中的基本结构。矩阵在多维数据表示、线性变换和系统方程求解中有广泛应用。矩阵运算包括加法、乘法、转置和逆矩阵等，通过这些运算可以实现复杂的数据处理和分析。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 3 算法

算法是解决问题的一系列步骤和规则，是计算机科学的核心概念。理解和设计有效的算法是计算机程序开发和数据处理的基础。

### 3.1 算法

算法是指解决特定问题的一系列步骤和规则。一个好的算法应具有正确性、效率和可读性。通过分析和优化算法，我们可以提高计算效率，解决复杂的计算问题。

### 3.2 函数的增长

函数的增长描述了算法在输入规模增加时的性能变化。常用的度量包括大O表示法、小o表示法、Ω表示法和Θ表示法。这些度量帮助我们理解和比较不同算法的时间复杂度和空间复杂度。

### 3.3 算法的复杂性

算法的复杂性是指算法在运行过程中所需的时间和空间资源。理解算法的时间复杂度和空间复杂度有助于选择和设计高效的算法。通过优化算法，我们可以在有限的资源下解决更大规模的问题。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 4 数论与密码学

数论是研究整数性质的数学分支，与密码学密切相关。密码学是保护信息安全的重要技术，通过数学方法实现数据加密和解密。

### 4.1 可除性与模运算

可除性和模运算是数论中的基本概念。可除性描述了一个整数是否能被另一个整数整除，模运算则是求两个数相除后的余数。这些概念在算法设计和密码学中有重要应用。

### 4.2 整数表示与算法

整数的表示和算法是数论中的核心内容。常见的整数表示有二进制、十进制和十六进制等。通过算法可以实现整数的加法、乘法、除法等基本运算，这些算法在计算机科学中有广泛应用。

### 4.3 素数与最大公约数

素数是仅能被1和自身整除的整数，是数论中的重要研究对象。最大公约数是两个或多个整数的公约数中最大的一个。理解和计算素数及最大公约数在算法设计和密码学中有重要作用。

### 4.4 解同余方程

同余方程是模运算中的方程，解同余方程是数论中的重要问题。通过数论方法可以求解同余方程，解决实际问题中的模运算问题。

### 4.5 同余方程的应用

同余方程在密码学、计算机科学和工程中有广泛应用。例如，公钥加密算法和数字签名技术都基于同余方程的理论。通过研究同余方程的应用，可以设计和实现安全的加密算法。

### 4.6 密码学

密码学是保护信息安全的技术，涉及数据加密和解密、数字签名、身份验证等。现代密码学基于复杂的数学理论，如数论和代数，通过研究和应用这些理论，可以实现高效、安全的数据保护。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 5 归纳与递归

归纳与递归是数学和计算机科学中的重要概念。归纳法用于证明数学命题的正确性，而递归则是定义和解决问题的常用方法。

### 5.1 数学归纳法

数学归纳法是一种证明数学命题的方法。它包括两个主要步骤：基阶和归纳步。在基阶中，我们证明命题在初始情况下成立；在归纳步中，我们假设命题在某一特定情况下成立，然后证明命题在下一情况下也成立。通过数学归纳法，可以证明许多关于自然数的命题和定理。

### 5.2 强归纳和良序原理

强归纳是数学归纳法的一个变种，适用于更复杂的命题。在强归纳中，我们假设命题在所有先前的情况下都成立，然后证明命题在当前情况下成立。良序原理是另一种证明工具，表明每个非空的自然数集合都有最小元素。良序原理和强归纳常用于证明复杂的数学命题。

### 5.3 递归定义与结构归纳

递归定义用于定义对象和函数，通过将一个对象定义为其自身的某种形式来实现。结构归纳是一种证明递归定义的正确性的方法。它通过证明递归定义的基阶和递归步的正确性来验证整个定义的有效性。递归定义和结构归纳广泛应用于数据结构和算法的设计与分析。

### 5.4 递归算法

递归算法是通过调用自身来解决问题的算法。它通常分为基阶和递归步。在基阶中，问题被简化到可以直接解决的情况；在递归步中，问题被分解为一个或多个子问题，然后递归解决这些子问题。递归算法在分治法、动态规划等领域有广泛应用。

### 5.5 程序正确性

程序正确性是指程序在所有情况下都能按照预期运行。通过形式化的方法，可以证明程序的正确性。常用的方法包括前置条件和后置条件、循环不变式等。程序正确性的证明有助于确保算法和程序的可靠性和安全性。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 6 计数

计数是组合数学中的基本问题，涉及如何计算某些特定对象的数量。通过掌握计数技巧，我们可以解决各种组合问题。

### 6.1 计数基础

计数基础包括基本的加法和乘法原理。加法原理用于计算互斥事件的总数，而乘法原理用于计算独立事件的组合数。这些基本原理是解决复杂计数问题的基础。

### 6.2 鸽巢原理

鸽巢原理是一种简单而强大的计数工具，表明如果n个物品放入m个容器（n > m），则至少有一个容器包含多个物品。鸽巢原理在证明存在性问题和优化问题中有重要应用。

### 6.3 排列与组合

排列和组合是计数问题中的基本概念。排列是指从一组元素中选取一定数量的元素并排列成不同顺序的方法数；组合是指从一组元素中选取一定数量的元素的不同选择方法数。通过排列和组合公式，我们可以解决各种复杂的计数问题。

### 6.4 二项式系数与恒等式

二项式系数是二项式定理中的系数，表示从n个元素中选取k个元素的组合数。二项式定理和相关恒等式在代数和组合数学中有重要应用，通过这些工具可以解决复杂的代数和计数问题。

### 6.5 广义排列与组合

广义排列与组合扩展了基本排列与组合的概念，允许元素重复选取或分组。这些概念在解决实际问题，如密码学、编码理论和概率计算中有广泛应用。

### 6.6 生成排列与组合

生成排列与组合是指通过算法生成所有可能的排列和组合。这些算法在计算机科学中有重要应用，如枚举所有可能的密码组合、生成所有可能的路径等。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 7 离散概率

离散概率研究离散事件的概率分布，是概率论的重要分支。通过离散概率理论，我们可以分析和预测离散事件的发生情况。

### 7.1 离散概率简介

离散概率是研究离散随机事件发生概率的数学工具。通过定义样本空间和事件，我们可以计算事件发生的概率。离散概率在统计学、计算机科学和工程中有广泛应用。

### 7.2 概率论

概率论是研究随机事件的数学理论，包括基本概率、条件概率和联合概率等概念。通过概率论，我们可以分析复杂的随机现象，预测事件发生的可能性，并解决实际问题。

### 7.3 贝叶斯定理

贝叶斯定理是概率论中的重要定理，用于计算条件概率。通过贝叶斯定理，我们可以根据新的证据更新事件发生的概率。贝叶斯定理在统计推断、机器学习和决策理论中有重要应用。

### 7.4 期望值与方差

期望值和方差是描述随机变量分布特征的重要指标。期望值表示随机变量的平均值，方差表示随机变量的离散程度。通过计算期望值和方差，我们可以分析随机现象的趋势和波动，预测事件发生的可能性。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 8 高级计数技术

高级计数技术在组合数学中发挥着重要作用，帮助解决复杂的计数问题。这些技术包括递归关系的应用、线性递归关系的求解、分治算法与递归关系、生成函数以及容斥原理。

### 8.1 递归关系的应用

递归关系是描述一个数列中各项之间关系的方程。通过应用递归关系，我们可以解决许多实际问题，如斐波那契数列和塔汉诺问题。递归关系的应用包括将复杂问题分解为更小、更易处理的子问题，然后逐步求解。

### 8.2 线性递归关系的求解

线性递归关系是一类特殊的递归关系，其形式为线性方程。求解线性递归关系的方法包括特征根法和初始条件替换法。通过求解线性递归关系，可以得到数列的通项公式，从而简化计算和分析。

### 8.3 分治算法与递归关系

分治算法是一种递归算法，将一个复杂问题分解为若干个更小的子问题，分别解决后再合并结果。分治算法通常伴随着递归关系，用于描述算法的时间复杂度。例如，快速排序和归并排序都是经典的分治算法，其时间复杂度可通过递归关系求解。

### 8.4 生成函数

生成函数是描述数列的一种工具，将数列的项表示为幂级数的系数。生成函数在组合数学中有广泛应用，帮助解决计数、递归关系和组合问题。通过生成函数，可以将复杂的数列问题转化为代数操作，从而简化求解过程。

### 8.5 容斥原理

容斥原理是计算集合并集元素数量的重要方法，用于解决包含交集的复杂计数问题。该原理通过加减集合的交集，精确计算并集的元素数目。容斥原理在组合数学、概率论和统计学中有广泛应用。

### 8.6 容斥原理的应用

容斥原理的应用包括解决复杂的计数和概率问题。例如，计算多个事件的联合概率、求解具有交集的集合元素数量等。通过应用容斥原理，可以准确分析和处理涉及多个集合的复杂问题。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 9 关系

关系是数学和计算机科学中的基本概念，用于描述对象之间的关联和结构。理解关系及其性质，有助于分析和解决各种数学和实际问题。

### 9.1 关系及其性质

关系是定义在两个集合之间的有序对的集合，用于描述对象之间的关联。关系的基本性质包括反射性、对称性和传递性。通过分析关系的性质，可以更好地理解对象之间的结构和联系。

### 9.2 n元关系及其应用

n元关系是定义在n个集合之间的关系，用于描述多个对象之间的复杂关联。n元关系在数据库、网络分析和多维数据处理等领域有重要应用。通过研究n元关系，可以解决涉及多个变量和约束的复杂问题。

### 9.3 关系的表示

关系可以用多种方式表示，包括矩阵表示、图表示和集合表示。不同的表示方式有助于理解和分析关系的结构和性质。例如，矩阵表示可以直观地显示关系的连通性，图表示可以用于分析关系的路径和连通分量。

### 9.4 关系的闭包

关系的闭包是指在原有关系的基础上，通过添加满足特定性质的有序对，使其满足某种特定性质的关系。常见的闭包包括传递闭包、对称闭包和反射闭包。通过计算关系的闭包，可以得到满足特定性质的最小关系，从而简化分析和计算。

### 9.5 等价关系

等价关系是满足反射性、对称性和传递性的关系，用于划分集合中的元素。通过等价关系，可以将集合划分为若干个等价类，每个等价类中的元素彼此等价。等价关系在分类、分组和数据聚类等方面有广泛应用。

### 9.6 偏序关系

偏序关系是满足反射性、反对称性和传递性的关系，用于描述对象之间的排序和层次结构。偏序关系在排序、层次分析和结构建模等领域有重要应用。通过研究偏序关系，可以分析和构建对象之间的层次结构和优先级。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 10 图论

图论是数学和计算机科学中的重要分支，用于研究对象及其关系。图论在许多领域都有广泛应用，如网络分析、路径优化和数据结构等。

### 10.1 图和图模型

图是一种数学结构，由顶点（节点）和边（连接）组成。图模型用于表示对象及其相互关系，广泛应用于社交网络、通信网络和交通网络等领域。通过图，可以直观地分析和解决复杂的关联问题。

### 10.2 图的术语和特殊类型

图的术语包括顶点、边、度数、路径、回路等。特殊类型的图包括简单图、多重图、有向图和无向图等。了解图的基本术语和类型，有助于更好地理解和分析图的结构和性质。

### 10.3 图的表示和同构

图的表示方式包括邻接矩阵、邻接表和边列表等。同构是指两个图在结构上是相同的，可以通过重新标记顶点使得它们的连接关系一致。理解图的表示和同构，有助于分析图的等价性和结构特征。

### 10.4 连通性

连通性是图的重要性质之一，表示图中顶点之间的可达性。一个图是连通的，如果任意两个顶点之间存在路径。连通性分析在网络设计和故障检测中有重要应用。

### 10.5 欧拉路径和哈密顿路径

欧拉路径是经过每条边一次且仅一次的路径，而欧拉回路是一个经过每条边一次且仅一次的回路。哈密顿路径是经过每个顶点一次且仅一次的路径，而哈密顿回路是一个经过每个顶点一次且仅一次的回路。欧拉路径和哈密顿路径在图的遍历和路径优化中有重要应用。

### 10.6 最短路径问题

最短路径问题是寻找图中两点之间路径长度最短的路径。常用的算法包括Dijkstra算法和Bellman-Ford算法。最短路径问题在交通规划、网络路由和资源分配等领域有广泛应用。

### 10.7 平面图

平面图是可以在平面上画出且不相交的图。平面图的研究涉及图的平面性判定和图的嵌入。平面图在电路设计和地理信息系统中有重要应用。

### 10.8 图的染色

图的染色是将图的顶点或边染成不同颜色，使得相邻元素颜色不同。顶点染色用于解决时间表安排、地图染色和频率分配等问题。边染色用于网络信道分配和资源管理。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 11 树

树是图的一种特殊形式，具有层次结构，广泛应用于数据结构和算法设计中。

### 11.1 树简介

树是一种无环连通图，由节点和边组成，具有唯一的根节点和层次结构。树在计算机科学中有广泛应用，如文件系统、数据结构和搜索算法等。通过树，可以直观地表示和处理层次关系。

### 11.2 树的应用

树的应用包括二叉树、搜索树、平衡树和决策树等。二叉树用于表达式计算和排序，搜索树用于高效查找和平衡树用于维护动态集合，决策树用于分类和预测。树结构的灵活性和高效性使其在各种应用场景中广受欢迎。

### 11.3 树的遍历

树的遍历是指按照一定顺序访问树中所有节点的方法。常见的遍历方法包括前序遍历、中序遍历、后序遍历和层次遍历。树的遍历在树的操作和算法设计中有重要作用，如表达式求值和数据排序。

### 11.4 生成树

生成树是从图中选取部分边形成的一棵树，包含图的所有顶点且不含环。生成树在网络设计和最小生成树问题中有重要应用。通过生成树，可以简化图的结构，优化资源配置。

### 11.5 最小生成树

最小生成树是生成树的一种，其边的权重之和最小。常用的最小生成树算法包括Kruskal算法和Prim算法。最小生成树在网络优化、聚类分析和资源分配等领域有广泛应用。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 12 布尔代数

布尔代数是一种数学结构，广泛应用于逻辑设计和数字电路中。布尔代数通过基本逻辑运算（如与、或、非）操作布尔变量，用于表示和简化逻辑表达式。

### 12.1 布尔函数

布尔函数是布尔代数中的基本对象，将布尔变量映射到布尔值。布尔函数通过逻辑运算组合布尔变量，形成复杂的逻辑表达式。理解布尔函数的性质和行为，对于设计和分析逻辑电路至关重要。

### 12.2 布尔函数的表示

布尔函数可以通过真值表、卡诺图或逻辑表达式等方式表示。真值表列出了布尔函数的所有输入组合及其对应输出，卡诺图通过图形化方式简化布尔函数，逻辑表达式则使用逻辑运算符直接表示函数关系。这些表示方法帮助我们更直观地分析和优化布尔函数。

### 12.3 逻辑门

逻辑门是实现布尔函数的基本电子元件，通过与、或、非等基本逻辑操作实现布尔运算。常见的逻辑门包括AND门、OR门、NOT门、NAND门、NOR门和XOR门等。逻辑门是数字电路的基本构建块，通过组合这些逻辑门可以实现复杂的逻辑功能。

### 12.4 电路最小化

电路最小化是指通过优化逻辑表达式，减少实现逻辑功能所需的逻辑门数量。常用的电路最小化方法包括卡诺图和Quine-McCluskey算法。电路最小化可以提高电路效率，减少功耗和成本，是逻辑设计中的关键步骤。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 13 计算模型

计算模型研究计算过程和计算机系统的抽象表示，帮助我们理解和设计计算系统。常见的计算模型包括语言与文法、有限状态机和图灵机等。

### 13.1 语言与文法

语言是符号的集合，用于表示信息和指令。文法是生成语言的规则系统，通过定义生成规则描述语言的结构。形式语言和文法在编译器设计和自动机理论中有重要应用，帮助我们理解和处理程序代码和数据格式。

### 13.2 有输出的有限状态机

有限状态机是描述系统状态和状态转移的数学模型。有输出的有限状态机（如Mealy机和Moore机）通过状态转移和输出函数描述系统的行为。这类模型在控制系统、通信协议和硬件设计中有广泛应用。

### 13.3 无输出的有限状态机

无输出的有限状态机（如DFA和NFA）专注于状态和状态转移，不考虑输出。这类模型主要用于语言识别和正则表达式匹配，是自动机理论的基础。

### 13.4 语言识别

语言识别是指通过有限状态机或文法判断字符串是否属于特定语言。常用的语言识别算法包括正则表达式匹配、DFA最小化和上下文无关文法解析。这些技术在编译器、搜索引擎和自然语言处理等领域有重要应用。

### 13.5 图灵机

图灵机是最强大的计算模型，能够模拟任何计算过程。图灵机通过无限长的纸带和有限状态控制器进行计算，是理论计算机科学的核心概念。通过研究图灵机，我们可以深入理解计算的本质和计算系统的能力与限制。

### 章节结尾材料

章节结尾材料包括复习题、练习题、总结和扩展阅读等，帮助读者巩固所学知识并进行实际应用。通过系统的复习和练习，读者可以加深理解，提高解决实际问题的能力。

### 附录

附录提供了一些补充材料和参考信息，帮助读者更好地理解和应用所学知识。

#### 1. 实数和正整数的公理

本部分列出了实数和正整数的基本公理，帮助读者理解这些数系的基础和性质。这些公理是数学分析和数论的基础。

#### 2. 指数函数和对数函数

本部分介绍了指数函数和对数函数的基本性质和应用。指数函数和对数函数在许多数学和工程问题中有重要应用，如指数增长、衰减模型和信息论等。

#### 3. 伪代码

本部分提供了伪代码的标准表示方法，帮助读者理解和编写算法。伪代码是一种介于自然语言和编程语言之间的描述工具，用于清晰地表达算法逻辑和步骤。

The universal quantification of P (x) is the statement “P (x) for all values of x in the domain.” The notation ∀xP (x) denotes the universal quantification of P (x). Here ∀ is called the universal quantifier. We read ∀xP (x) as “for all xP (x)” or “for every xP (x).” An element for which P (x) is false is called a counterexample of ∀xP (x).

### 全称量化

全称量化是逻辑中用于表达某一性质对所有元素都成立的陈述。具体来说，全称量化的陈述形式为“对定义域中的所有值x，性质P(x)成立”。用符号表示为 ∀xP(x)，其中 ∀ 是全称量词。我们可以将 ∀xP(x) 读作“对所有x，P(x)成立”或者“对每一个x，P(x)成立”。

### 全称量化的符号和意义

- **符号 ∀**：全称量词（Universal Quantifier），表示“对于所有”。
- **表达式 ∀xP(x)**：表示性质P(x)对定义域中的每一个x都成立。

### 举例说明

假设定义域是整数，P(x) 表示 “x 是偶数”。则 ∀xP(x) 表示“所有整数都是偶数”。显然，这是一个不真实的陈述，因为存在一些整数（如1, 3, 5等）不是偶数。

### 反例

对于全称量化陈述 ∀xP(x)，如果存在一个元素使得P(x)为假，那么这个元素称为 ∀xP(x) 的反例（Counterexample）。反例的存在表明全称量化陈述是假的。

#### 举例

- **陈述**： ∀x (x^2 ≥ 0)，表示“对于所有实数x，x的平方都大于等于0”。这个陈述是真的，因为对于所有实数x，x^2 都是非负数。
- **反例**： ∀x (x > 0)，表示“对于所有实数x，x都大于0”。这是假的，因为例如x = -1 是一个反例，使得P(x) = x > 0 不成立。

### 总结

全称量化 ∀xP(x) 表示性质P(x)对定义域中的所有元素x都成立。全称量化在数学和逻辑中用于表达普遍适用的性质或规则。反例是使得P(x)不成立的元素，用于证明全称量化陈述的错误性。理解和应用全称量化对于形式化证明和逻辑推理至关重要。

The existential quantification of P (x) is the proposition “There exists an element x in the domain such that P (x).” We use the notation ∃xP (x) for the existential quantification of P (x). Here ∃ is called the existential quantifier.
### 存在量化

存在量化是逻辑中用于表达某一性质在定义域中至少有一个元素成立的陈述。具体来说，存在量化的陈述形式为“存在一个定义域中的元素x，使得性质P(x)成立”。用符号表示为 ∃xP(x)，其中 ∃ 是存在量词。我们可以将 ∃xP(x) 读作“存在一个x，使得P(x)成立”。

### 存在量化的符号和意义

- **符号 ∃**：存在量词（Existential Quantifier），表示“存在”。
- **表达式 ∃xP(x)**：表示存在至少一个x使得性质P(x)成立。

### 举例说明

假设定义域是整数，P(x) 表示 “x 是偶数”。则 ∃xP(x) 表示“存在一个整数是偶数”。这个陈述是真实的，因为确实存在许多偶数，如2, 4, 6等。

### 反例和证明

对于存在量化陈述 ∃xP(x)，如果我们能找到一个元素使得P(x)为真，那么这个陈述就是真实的。如果要证明 ∃xP(x) 为假，则需要证明对于定义域中的所有元素x，P(x)都为假。

#### 举例

- **陈述**： ∃x (x^2 = 4)，表示“存在一个实数x，使得x的平方等于4”。这个陈述是真的，因为x = 2和x = -2都满足这个条件。
- **反例**：如果我们要证明 ∃x (x^2 < 0) 为假，则需要证明对于所有实数x，x^2 都不是负数。显然，这个陈述是假的，因为平方数不能为负。

### 总结

存在量化 ∃xP(x) 表示在定义域中存在至少一个元素x，使得性质P(x)成立。存在量化在数学和逻辑中用于表达某种性质的存在性或可能性。找到一个满足P(x)的元素就足以证明存在量化陈述的真实性，而要证明其为假则需要证明所有元素都不满足P(x)。理解和应用存在量化对于形式化证明和逻辑推理同样至关重要。

3 Statements involving predicates and quantifiers are logically equivalent if and only if they have the same truth value no matter which predicates are substituted into these statements and which domain of discourse is used for the variables in these propositional functions. We use the notation S ≡ T to indicate that two statements S and T involving predicates and quantifiers are logically equivalent.

### 谓词和量词语句的逻辑等价

谓词和量词语句在逻辑上等价，当且仅当无论将哪些谓词代入这些语句，以及使用何种论域，这些命题函数的真值总是相同的。

### 符号表示

- **符号 ≡**：表示逻辑等价（Logical Equivalence）。
- **表达式 S ≡ T**：表示语句S和语句T在逻辑上等价。

### 逻辑等价的意义

两个涉及谓词和量词的语句S和T，如果它们在所有可能的谓词替换和论域选择下，都具有相同的真值，那么我们说这两个语句在逻辑上等价。这意味着，无论我们如何定义谓词或如何选择论域，只要S为真，T也为真；只要S为假，T也为假。

### 举例说明

1. **等价语句**：
   - **语句 S**： ∀x (P(x) ∧ Q(x))
   - **语句 T**： ∀x P(x) ∧ ∀x Q(x)
   
   在这里，S和T是等价的，因为无论P(x)和Q(x)是什么样的谓词，只要它们定义在相同的论域上，S和T的真值总是相同的。即，对于所有x，如果P(x)和Q(x)同时成立，那么P(x)和Q(x)分别成立。

2. **非等价语句**：
   - **语句 S**： ∃x (P(x) ∨ Q(x))
   - **语句 T**： ∃x P(x) ∨ ∃x Q(x)
   
   在这里，S和T不是等价的。S表示存在一个x使得P(x)或Q(x)至少一个为真，而T表示存在一个x使得P(x)为真，或者存在一个x使得Q(x)为真。这两个语句在某些情况下可能有不同的真值，因此它们不是逻辑等价的。

### 逻辑等价的应用

逻辑等价在数学和逻辑推理中有重要应用，特别是在简化逻辑表达式、证明定理和进行形式化验证时。通过识别和使用等价语句，可以简化推理过程，提高推理的效率和准确性。

### 总结

两个涉及谓词和量词的语句S和T在逻辑上等价，当且仅当它们在所有可能的谓词替换和论域选择下具有相同的真值。我们用符号 S ≡ T 来表示这种逻辑等价性。理解和应用逻辑等价对于形式化证明和逻辑推理至关重要。

An argument in propositional logic is a sequence of propositions. All but the final proposition in the argument are called premises and the final proposition is called the conclusion. An argument is valid if the truth of all its premises implies that the conclusion is true. An argument form in propositional logic is a sequence of compound propositions involving propositional variables. An argument form is valid no matter which particular propositions are substituted for the propositional variables in its premises, the conclusion is true if the premises are all true.

### 命题逻辑中的论证

在命题逻辑中，论证是由一系列命题组成的序列。除了最后一个命题，其他命题都被称为前提，最后一个命题称为结论。如果所有前提的真值导致结论为真，那么这个论证就是有效的。

### 论证的组成部分

1. **前提**（Premises）：论证中的所有命题，除了最后一个。
2. **结论**（Conclusion）：论证中的最后一个命题。

### 论证的有效性

一个论证是有效的，当且仅当所有前提为真时，结论也必然为真。换句话说，前提的真值必须能逻辑地推导出结论的真值。

### 举例说明

假设有以下论证：

- 前提1：如果今天下雨，那么我带了伞。（P → Q）
- 前提2：今天下雨。（P）
- 结论：我带了伞。（Q）

在这个论证中，如果前提1和前提2都为真，那么结论Q也必然为真，因此这是一个有效的论证。

### 命题逻辑中的论证形式

论证形式是包含命题变量的复合命题序列。论证形式的有效性意味着，无论用什么具体命题代替这些命题变量，只要所有前提都为真，结论也必然为真。

### 举例说明论证形式

考虑以下论证形式：

- 前提1：P → Q
- 前提2：P
- 结论：Q

这个论证形式是有效的，因为无论P和Q具体为何种命题，只要前提1和前提2都为真，结论Q也必然为真。

### 论证形式的有效性

论证形式的有效性可以通过以下方法验证：

1. **真值表法**：构建真值表，检查在所有前提都为真的情况下，结论是否也为真。
2. **逻辑推理法**：使用逻辑推理规则，如假言推理（Modus Ponens）、否定前件（Modus Tollens）等，验证论证形式的有效性。

### 举例说明

使用真值表法验证论证形式的有效性：

- 论证形式：P → Q, P ⊢ Q

| P | Q | P → Q | P | Q |
|:-:|:-:|:-----:|:-:|:-:|
| T | T |   T   | T | T |
| T | F |   F   | T | F |
| F | T |   T   | F | T |
| F | F |   T   | F | F |

在真值表中，只有当P和P → Q都为真时，Q也为真，证明了这个论证形式的有效性。

### 总结

在命题逻辑中，论证是由前提和结论组成的命题序列。论证的有效性要求前提的真值能逻辑地推导出结论的真值。论证形式是包含命题变量的复合命题序列，论证形式的有效性意味着，无论用何种具体命题代替命题变量，只要所有前提为真，结论也必然为真。理解和验证论证的有效性是逻辑推理和形式化证明的重要组成部分。

The integer n is even if there exists an integer k such that n = 2k, and n is odd if there exists an integer k such that n = 2k + 1. (Note that every integer is either even or odd, and no integer is both even and odd.) Two integers have the same parity when both are even or both are odd; they have opposite parity when one is even and the other is odd.

The real number r is rational if there exist integers p and q with q = 0 such that r = p/q. A real number that is not rational is called irrational.

FERMAT’S LAST THEOREM The equation xn + yn = zn has no solutions in integers x, y, and z with xyz = 0 whenever n is an integer with n > 2

### 费马大定理

费马大定理（Fermat's Last Theorem）是数论中的一个著名命题，由法国数学家皮埃尔·德·费马于1637年提出。它的陈述如下：

对于任意整数n，当n > 2时，方程\( x^n + y^n = z^n \)在整数域中没有非零解(x, y, z)。

换句话说，不存在一组非零整数\( x, y, z \)，使得它们满足上述方程。

### 数学符号表示

费马大定理可以用数学符号表示为：
\[ \forall n \in \mathbb{Z}, n > 2, \nexists x, y, z \in \mathbb{Z} \setminus \{0\}, x^n + y^n = z^n \]

### 历史背景

费马在其所拥有的一本《算术》书的空白页上写下了这个命题，并附上了一句话，大意为“我已经发现了一个绝妙的证明，但这本书的空白处太小，写不下”。这一简短的注释激发了后世无数数学家的兴趣和研究。

### 证明历程

费马大定理在费马提出后的三个多世纪里，一直没有得到证明或反驳，成为数学史上的一大难题。许多著名数学家为其证明做出了重要贡献，但直到20世纪末才最终被证明。

- 1994年，英国数学家安德鲁·怀尔斯（Andrew Wiles）和他的学生理查德·泰勒（Richard Taylor）最终完成了费马大定理的证明。怀尔斯通过研究模形式和椭圆曲线之间的深刻联系，利用谷山-志村猜想（后来被称为模性定理）间接地证明了费马大定理。

### 证明概述

怀尔斯的证明涉及许多高深的数学理论和工具，包括模形式、椭圆曲线、Galois表示和同调代数等。具体证明过程非常复杂，超出了初等数论的范畴。

- 怀尔斯首先证明了一个特定类型的椭圆曲线（半稳定椭圆曲线）是模的，这意味着这些椭圆曲线可以与模形式相联系。
- 然后，通过建立这种联系，怀尔斯间接证明了费马大定理。

### 总结

费马大定理断言，对于n > 2的所有整数，方程\( x^n + y^n = z^n \)在整数域中没有非零解。这一命题从提出到最终证明，历经了350多年，成为数学史上最著名的难题之一。1994年，安德鲁·怀尔斯通过研究模形式和椭圆曲线之间的联系，最终成功证明了费马大定理。

### 术语定义

#### Proposition（命题）
- **定义**：命题是一个断言，可以是真或假的陈述。
- **示例**：命题“今天是晴天”要么为真，要么为假。

#### Propositional Variable（命题变量）
- **定义**：命题变量是表示命题的变量。
- **示例**：变量p和q可以分别表示命题“今天是晴天”和“明天是晴天”。

#### Truth Value（真值）
- **定义**：真值是指命题的真假属性。
- **真值**：true（真）或false（假）。

#### ¬p（Negation of p，p的否定）
- **定义**：¬p是与命题p真值相反的命题。
- **示例**：如果p表示“今天是晴天”，则¬p表示“今天不是晴天”。

#### Logical Operators（逻辑运算符）
- **定义**：逻辑运算符用于组合命题。
- **常见运算符**：与（∧），或（∨），否定（¬），蕴涵（→），等价（↔）。

#### Compound Proposition（复合命题）
- **定义**：复合命题是通过逻辑运算符组合多个命题形成的新命题。
- **示例**：命题p和q可以组合成“p ∧ q”，表示“今天是晴天且明天是晴天”。

#### Truth Table（真值表）
- **定义**：真值表列出了命题的所有可能的真值组合及其结果。
- **示例**：对于命题p和q的真值表：

| p   | q   | p ∧ q |
|-----|-----|-------|
| T   | T   | T     |
| T   | F   | F     |
| F   | T   | F     |
| F   | F   | F     |

#### p ∨ q（Disjunction of p and q，p和q的析取）
- **定义**：p ∨ q 是命题“p或q”，当且仅当p或q中至少一个为真时，该命题为真。
- **示例**：如果p表示“今天是晴天”，q表示“明天是晴天”，那么p ∨ q表示“今天是晴天或明天是晴天”。

### 总结

这些术语和定义是逻辑学和命题逻辑的基础。通过理解命题、命题变量、真值、逻辑运算符、复合命题和真值表等概念，我们可以构建和分析复杂的逻辑表达式，从而进行严谨的逻辑推理和证明。

### 术语定义

#### p ∧ q（p和q的合取）
- **定义**：p ∧ q 是命题“p和q”，当且仅当p和q都为真时，该命题为真。

#### p ⊕ q（p和q的异或）
- **定义**：p ⊕ q 是命题“p异或q”，当且仅当p和q中恰有一个为真时，该命题为真。

#### p → q（p蕴涵q）
- **定义**：p → q 是命题“如果p，那么q”，当且仅当p为真且q为假时，该命题为假。

#### converse of p → q（p → q 的逆命题）
- **定义**：q → p，即“如果q，那么p”。

#### contrapositive of p → q（p → q 的逆否命题）
- **定义**：¬q → ¬p，即“如果不q，那么不p”。

#### inverse of p → q（p → q 的逆命题）
- **定义**：¬p → ¬q，即“如果不p，那么不q”。

#### p ↔ q（p和q的双条件）
- **定义**：p ↔ q 是命题“p当且仅当q”，当且仅当p和q具有相同的真值时，该命题为真。

#### bit（位）
- **定义**：0或1。

#### Boolean variable（布尔变量）
- **定义**：值为0或1的变量。

#### bit operation（位操作）
- **定义**：对一个或多个位进行的操作。

#### bit string（位串）
- **定义**：一串位的列表。

#### bitwise operations（按位操作）
- **定义**：对两个位串中对应位进行操作的操作。

#### logic gate（逻辑门）
- **定义**：执行逻辑操作并产生输出位的逻辑元件。

#### logic circuit（逻辑电路）
- **定义**：由逻辑门组成的开关电路，产生一个或多个输出位。

#### tautology（重言式）
- **定义**：总为真的复合命题。

#### contradiction（矛盾）
- **定义**：总为假的复合命题。

#### contingency（偶然命题）
- **定义**：有时为真有时为假的复合命题。

#### consistent compound propositions（相容复合命题）
- **定义**：存在一种真值赋值使得所有这些复合命题都为真。

#### satisfiable compound proposition（可满足复合命题）
- **定义**：存在一种真值赋值使得该复合命题为真。

#### logically equivalent compound propositions（逻辑等价复合命题）
- **定义**：总是具有相同真值的复合命题。

#### predicate（谓词）
- **定义**：句子的部分，用于给主语赋予属性。

#### propositional function（命题函数）
- **定义**：包含一个或多个变量的陈述，当每个变量被赋值或由量词绑定时，成为命题。

#### domain (or universe) of discourse（论域或论述的宇宙）
- **定义**：命题函数中的变量可以取的值。

#### ∃x P(x)（P(x)的存在量化）
- **定义**：当且仅当在论域中存在一个x使得P(x)为真时，该命题为真。

#### ∀xP(x)（P(x)的全称量化）
- **定义**：当且仅当在论域中的每一个x使得P(x)为真时，该命题为真。

#### logically equivalent expressions（逻辑等价表达式）
- **定义**：无论使用何种命题函数和论域，总是具有相同真值的表达式。

#### free variable（自由变量）
- **定义**：在命题函数中未被量词绑定的变量。

#### bound variable（绑定变量）
- **定义**：被量词绑定的变量。

#### scope of a quantifier（量词的作用域）
- **定义**：量词绑定其变量的语句部分。

#### argument（论证）
- **定义**：一系列陈述的序列，其中包括前提和结论。

### 术语定义

#### argument form（论证形式）
- **定义**：涉及命题变量的复合命题序列。
- **示例**：如果p则q，p，因此q。

#### premise（前提）
- **定义**：在论证或论证形式中，除了最后一个命题之外的所有命题。
- **示例**：在“如果p则q，p，因此q”中，“如果p则q”和“p”是前提。

#### conclusion（结论）
- **定义**：论证或论证形式中的最后一个命题。
- **示例**：在“如果p则q，p，因此q”中，“q”是结论。

#### valid argument form（有效论证形式）
- **定义**：涉及命题变量的复合命题序列，前提为真时，结论必为真。
- **示例**：如果所有前提为真，则结论必为真的形式，如假言推理。

#### valid argument（有效论证）
- **定义**：具有有效论证形式的论证。
- **示例**：假言推理：“如果今天下雨，我就带伞。今天下雨。因此，我带伞。”

#### rule of inference（推理规则）
- **定义**：一种可以用来证明论证有效的有效论证形式。
- **示例**：假言推理、否定前件。

#### fallacy（谬误）
- **定义**：一种无效的论证形式，常被错误地用作推理规则（或更广义上，错误的论证）。
- **示例**：否定后件：“如果p则q，¬q，因此¬p” 是一种谬误。

#### circular reasoning or begging the question（循环推理或预设立场）
- **定义**：论证中的某一步基于被证明陈述的真值。
- **示例**：为了证明p是正确的，假设p是正确的。

#### theorem（定理）
- **定义**：可以被证明为真的数学断言。
- **示例**：费马大定理。

#### conjecture（猜想）
- **定义**：被提出为真的数学断言，但尚未被证明。
- **示例**：哥德巴赫猜想。

#### proof（证明）
- **定义**：展示定理为真的论证过程。
- **示例**：通过严格的数学推理证明定理。

#### axiom（公理）
- **定义**：被假定为真的陈述，可用作证明定理的基础。
- **示例**：欧几里得几何的公理。

#### lemma（引理）
- **定义**：用于证明其他定理的定理。
- **示例**：在证明大定理之前使用的辅助定理。

#### corollary（推论）
- **定义**：可以作为刚刚证明的定理的结果被证明的命题。
- **示例**：从一个定理中直接推导出的结论。

#### vacuous proof（空洞证明）
- **定义**：基于p为假，证明p → q为真。
- **示例**：如果“所有独角兽都是绿色的”是真，因为不存在独角兽。

#### trivial proof（平凡证明）
- **定义**：基于q为真，证明p → q为真。
- **示例**：如果“2是偶数”是真，则“如果1=0，那么2是偶数”也是真。

#### direct proof（直接证明）
- **定义**：通过展示当p为真时q必为真的证明方法。
- **示例**：证明“如果n是偶数，则n^2是偶数”通过假设n是偶数。

#### proof by contraposition（逆否命题证明）
- **定义**：通过展示当q为假时p必为假的证明方法。
- **示例**：证明“如果n^2是奇数，则n是奇数”，通过证明“如果n是偶数，则n^2是偶数”。

#### proof by contradiction（反证法）
- **定义**：基于 ¬p → q，其中q是矛盾，证明p为真。
- **示例**：通过假设“√2是有理数”并得出矛盾，证明“√2是无理数”。

#### exhaustive proof（穷举法）
- **定义**：通过检查所有可能情况来确立结果的证明方法。
- **示例**：证明一个命题对所有有限集合中的元素成立。

#### proof by cases（分情况证明）
- **定义**：将证明分为若干独立情况，这些情况涵盖所有可能性。
- **示例**：证明一个命题对整数n成立，通过分别考虑n为奇数和偶数的情况。

#### without loss of generality（不失一般性）
- **定义**：在证明中做出的假设，使得可以通过减少考虑的情况来证明定理。
- **示例**：证明一个对称问题时，只考虑一半情况。

#### counterexample（反例）
- **定义**：使得P(x)为假的元素x。
- **示例**：对于命题“所有自然数都是偶数”，1是一个反例。

#### constructive existence proof（构造性存在性证明）
- **定义**：通过显式找到一个具有指定性质的元素来证明其存在。
- **示例**：证明存在一个质数，通过给出2这个质数。

#### nonconstructive existence proof（非构造性存在性证明）
- **定义**：通过间接证明某个具有指定性质的元素存在，但不显式找到该元素。
- **示例**：证明存在无限多的质数，通过反证法。

#### rational number（有理数）
- **定义**：可以表示为两个整数p和q的比值的数，其中q ≠ 0。
- **示例**：3/4是一个有理数。

#### uniqueness proof（唯一性证明）
- **定义**：证明存在且仅存在一个满足指定性质的元素。
- **示例**：证明某个方程的唯一解。

A set is an unordered collection of objects, called elements or members of the set. A set is said to contain its elements. We write a ∈ A to denote that a is an element of the set A. The notation a ∈ A denotes that a is not an element of the set A.

atics: N = {0, 1, 2, 3,...}, the set of natural numbers Z = {..., −2, −1, 0, 1, 2,...}, the set of integers Z+ = {1, 2, 3,...}, the set of positive integers Q = {p/q | p ∈ Z, q ∈ Z, and q = 0}, the set of rational numbers R, the set of real numbers R+, the set of positive real numbers C, the set of complex numbers

Two sets are equal if and only if they have the same elements. Therefore, if A and B are sets, then A and B are equal if and only if ∀x(x ∈ A ↔ x ∈ B). We write A = B if A and B are equal sets.

The set A is a subset of B if and only if every element of A is also an element of B. We use the notation A ⊆ B to indicate that A is a subset of the set B.
Showing that A is a Subset of B To show that A ⊆ B, show that if x belongs to A then x also belongs to B. Showing that A is Not a Subset of B To show that A ⊆ B, find a single x ∈ A such that x ∈ B.

For every set S, (i) ∅ ⊆ S and (ii) S ⊆ S.

Showing Two Sets are Equal To show that two sets A and B are equal, show that A ⊆ B and B ⊆ A

Let S be a set. If there are exactly n distinct elements in S where n is a nonnegative integer, we say that S is a finite set and that n is the cardinality of S. The cardinality of S is denoted by |S|.

A set is said to be infinite if it is not finite.

Given a set S, the power set of S is the set of all subsets of the set S. The power set of S is denoted by P(S).

The ordered n-tuple (a1, a2,...,an) is the ordered collection that has a1 as its first element, a2 as its second element,..., and an as its nth element.

Let A and B be sets. The Cartesian product of A and B, denoted by A × B, is the set of all ordered pairs (a, b), where a ∈ A and b ∈ B. Hence, A × B = {(a, b) | a ∈ A ∧ b ∈ B}.

The Cartesian product of the sets A1, A2,...,An, denoted by A1 × A2 ×···× An, is the set of ordered n-tuples (a1, a2,...,an), where ai belongs to Ai for i = 1, 2,...,n. In other words, A1 × A2 ×···× An = {(a1, a2,...,an) | ai ∈ Ai for i = 1, 2,...,n}.

Let A and B be sets. The union of the sets A and B, denoted by A ∪ B, is the set that contains those elements that are either in A or in B, or in both.

Let A and B be sets. The intersection of the sets A and B, denoted by A ∩ B, is the set containing those elements in both A and B.
+
Two sets are called disjoint if their intersection is the empty set.

Let A and B be sets. The difference of A and B, denoted by A − B, is the set containing those elements that are in A but not in B. The difference of A and B is also called the complement of B with respect to A.

Let U be the universal set. The complement of the set A, denoted by A, is the complement of A with respect to U. Therefore, the complement of the set A is U − A.

The union of a collection of sets is the set that contains those elements that are members of at least one set in the collection

The intersection of a collection of sets is the set that contains those elements that are members of all the sets in the collection

Let A and B be nonempty sets. A function f from A to B is an assignment of exactly one element of B to each element of A. We write f (a) = b if b is the unique element of B assigned by the function f to the element a of A. If f is a function from A to B, we write f : A → B.

If f is a function from A to B, we say that A is the domain of f and B is the codomain of f. If f (a) = b, we say that b is the image of a and a is a preimage of b. The range, or image, of f is the set of all images of elements of A. Also, if f is a function from A to B, we say that f maps A to B.

Let f1 and f2 be functions from A to R. Then f1 + f2 and f1f2 are also functions from A to R defined for all x ∈ A by (f1 + f2)(x) = f1(x) + f2(x), (f1f2)(x) = f1(x)f2(x).

Let f be a function from A to B and let S be a subset of A. The image of S under the function f is the subset of B that consists of the images of the elements of S. We denote the image of S by f (S), so f (S) = {t | ∃s ∈S (t = f (s))}. We also use the shorthand {f (s) | s ∈ S} to denote this set.

A function f is said to be one-to-one, or an injunction, if and only if f (a) = f (b)implies that a = b for all a and b in the domain of f. A function is said to be injective if it is one-to-one.

A function f whose domain and codomain are subsets of the set of real numbers is called increasing if f (x) ≤ f (y), and strictly increasing if f (x) < f (y), whenever x f (y), whenever x

A function f from A to B is called onto, or a surjection, if and only if for every element b ∈ B there is an element a ∈ A with f (a) = b. A function f is called surjective if it is onto
### 函数的满射（Surjection）

一个从集合A到集合B的函数\( f \)称为满射（或称为“上射”），当且仅当对于集合B中的每个元素 \( b \)，存在集合A中的一个元素 \( a \)，使得 \( f(a) = b \)。如果一个函数是满射，我们称这个函数是“满射的”或“上射的”。

### 数学定义

- **定义**：函数 \( f: A \to B \) 是满射，当且仅当对于每个 \( b \in B \)，存在 \( a \in A \)，使得 \( f(a) = b \)。
- **符号表示**：\[ \forall b \in B, \exists a \in A \text{ such that } f(a) = b \]

### 举例说明

1. **示例1**：
   - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = 2x \)。
   - 对于任何 \( b \in \mathbb{R} \)，我们可以找到 \( a = \frac{b}{2} \in \mathbb{R} \)，使得 \( f(a) = 2(\frac{b}{2}) = b \)。
   - 因此，函数 \( f(x) = 2x \) 是满射的。

2. **示例2**：
   - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = x^2 \)。
   - 对于 \( b \geq 0 \)，我们可以找到 \( a = \sqrt{b} \) 或 \( a = -\sqrt{b} \) 使得 \( f(a) = b \)。
   - 但是，对于 \( b < 0 \)，不存在任何 \( a \in \mathbb{R} \) 使得 \( f(a) = b \)。
   - 因此，函数 \( f(x) = x^2 \) 不是满射的。

### 满射的图示

为了更好地理解满射，可以用映射图表示。满射的特点是每个目标集 \( B \) 中的元素至少被定义域 \( A \) 中的一个元素映射到。

- 满射示例：
  ```
  A: {1, 2, 3}
  B: {a, b}
  f(1) = a
  f(2) = b
  f(3) = a
  ```
  在这个示例中，每个 \( B \) 中的元素 \( a \) 和 \( b \) 都至少有一个 \( A \) 中的元素映射到，因此这是一个满射。

### 满射的重要性

满射函数在许多数学领域中都具有重要意义：
- 在代数中，满射映射确保了一个代数结构完全映射到另一个代数结构。
- 在分析中，满射函数用于构建和研究各种函数空间。
- 在拓扑学中，满射用于定义商空间和连续映射。

### 总结

满射函数确保了目标集中的每个元素都有对应的定义域中的元素映射到。理解满射的概念对于深入研究数学函数和映射理论至关重要。

The function f is a one-to-one correspondence, or a bijection, if it is both one-to-one and onto. We also say that such a function is bijective.

Suppose that f : A → B. To show that f is injective Show that if f (x) = f (y) for arbitrary x, y ∈ A with x = y, then x = y. To show that f is not injective Find particular elements x, y ∈ A such that x = y and f (x) = f (y). To show that f is surjective Consider an arbitrary element y ∈ B and find an element x ∈ A such that f (x) = y. To show that f is not surjective Find a particular y ∈ B such that f (x) = y for all x ∈ A

### 注射（Injective）和满射（Surjective）的证明方法

#### 证明函数是注射（Injective）

要证明函数 \( f: A \to B \) 是注射的，需要显示如果对任意的 \( x, y \in A \) 满足 \( f(x) = f(y) \)，则 \( x = y \)。

- **步骤**：
  1. 假设 \( f(x) = f(y) \) 对于任意的 \( x, y \in A \)。
  2. 证明 \( x = y \)。

- **示例**：
  - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = 2x + 1 \)。
  - 假设 \( f(x) = f(y) \)，即 \( 2x + 1 = 2y + 1 \)。
  - 解方程得出 \( 2x = 2y \)，即 \( x = y \)。
  - 因此，函数 \( f(x) = 2x + 1 \) 是注射的。

#### 证明函数不是注射（Not Injective）

要证明函数 \( f: A \to B \) 不是注射的，需要找到特定的 \( x, y \in A \)，使得 \( x \neq y \) 且 \( f(x) = f(y) \)。

- **步骤**：
  1. 找到特定的 \( x, y \in A \) 使得 \( x \neq y \) 且 \( f(x) = f(y) \)。

- **示例**：
  - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = x^2 \)。
  - 选择 \( x = 1 \) 和 \( y = -1 \)。
  - 则 \( f(1) = 1^2 = 1 \) 且 \( f(-1) = (-1)^2 = 1 \)。
  - \( f(1) = f(-1) \)，但 \( 1 \neq -1 \)。
  - 因此，函数 \( f(x) = x^2 \) 不是注射的。

#### 证明函数是满射（Surjective）

要证明函数 \( f: A \to B \) 是满射的，需要考虑任意的 \( y \in B \)，并找到 \( x \in A \) 使得 \( f(x) = y \)。

- **步骤**：
  1. 选择任意 \( y \in B \)。
  2. 找到一个 \( x \in A \) 使得 \( f(x) = y \)。

- **示例**：
  - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = 2x + 1 \)。
  - 选择任意 \( y \in \mathbb{R} \)。
  - 令 \( x = \frac{y - 1}{2} \)。
  - 则 \( f(x) = 2(\frac{y - 1}{2}) + 1 = y \)。
  - 因此，函数 \( f(x) = 2x + 1 \) 是满射的。

#### 证明函数不是满射（Not Surjective）

要证明函数 \( f: A \to B \) 不是满射的，需要找到特定的 \( y \in B \)，使得对所有 \( x \in A \) 都有 \( f(x) \neq y \)。

- **步骤**：
  1. 找到特定的 \( y \in B \) 使得对所有 \( x \in A \)，\( f(x) \neq y \)。

- **示例**：
  - 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = x^2 \)。
  - 选择 \( y = -1 \)。
  - 对于所有 \( x \in \mathbb{R} \)，\( f(x) = x^2 \geq 0 \)，不可能等于 -1。
  - 因此，函数 \( f(x) = x^2 \) 不是满射的。

### 总结

通过上述步骤和示例，可以有效地证明一个函数是否为注射或满射。这些方法和技术是数学和计算机科学中分析和验证函数性质的重要工具。

Let f be a one-to-one correspondence from the set A to the set B. The inverse function of f is the function that assigns to an element b belonging to B the unique element a in A such that f (a) = b. The inverse function of f is denoted by f −1. Hence, f −1(b) = a when f (a) = b.

### 逆函数（Inverse Function）

若函数 \( f \) 是从集合 \( A \) 到集合 \( B \) 的一一对应（双射），则 \( f \) 的逆函数 \( f^{-1} \) 是从 \( B \) 到 \( A \) 的函数，其作用是将集合 \( B \) 中的元素 \( b \) 映射到 \( A \) 中的唯一元素 \( a \)，使得 \( f(a) = b \)。

### 定义

- **逆函数**：函数 \( f^{-1}: B \to A \)。
- **性质**：对于任意 \( b \in B \)，若 \( f(a) = b \)，则 \( f^{-1}(b) = a \)。

### 数学符号表示

- 如果 \( f: A \to B \) 是一一对应函数，则 \( f^{-1}: B \to A \) 定义为：\[ f^{-1}(b) = a \iff f(a) = b \]

### 逆函数的性质

1. **双射性质**：
   - 如果 \( f \) 是双射（即同时是单射和满射），则 \( f^{-1} \) 也是双射。
   - \( f \) 的单射性质确保每个 \( b \in B \) 至多有一个 \( a \in A \) 满足 \( f(a) = b \)。
   - \( f \) 的满射性质确保每个 \( b \in B \) 至少有一个 \( a \in A \) 满足 \( f(a) = b \)。
   - 因此，\( f^{-1} \) 是良定义且唯一的。

2. **复合函数性质**：
   - \( f \) 和 \( f^{-1} \) 的复合函数满足：\[ f(f^{-1}(b)) = b \quad \text{对于所有} \ b \in B \]
   - \( f^{-1}(f(a)) = a \quad \text{对于所有} \ a \in A \]

### 举例说明

#### 例子1：简单线性函数

- 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = 2x + 3 \)。
- 要找到 \( f \) 的逆函数 \( f^{-1} \)，我们需要求解 \( y = 2x + 3 \) 的 \( x \)。
- 解方程得：\[ x = \frac{y - 3}{2} \]
- 因此，\( f^{-1}: \mathbb{R} \to \mathbb{R} \) 定义为：\[ f^{-1}(y) = \frac{y - 3}{2} \]

#### 例子2：非线性函数

- 设 \( f: \mathbb{R} \to \mathbb{R} \) 定义为 \( f(x) = x^3 \)。
- 要找到 \( f \) 的逆函数 \( f^{-1} \)，我们需要求解 \( y = x^3 \) 的 \( x \)。
- 解方程得：\[ x = \sqrt[3]{y} \]
- 因此，\( f^{-1}: \mathbb{R} \to \mathbb{R} \) 定义为：\[ f^{-1}(y) = \sqrt[3]{y} \]

### 逆函数的存在条件

一个函数 \( f \) 有逆函数 \( f^{-1} \) 存在的充要条件是 \( f \) 是双射，即 \( f \) 是单射（注射）且满射（上射）。

- **单射**：对于任意 \( a_1, a_2 \in A \)，若 \( f(a_1) = f(a_2) \)，则 \( a_1 = a_2 \)。
- **满射**：对于任意 \( b \in B \)，存在 \( a \in A \)，使得 \( f(a) = b \)。

### 总结

逆函数 \( f^{-1} \) 将集合 \( B \) 中的元素映射回集合 \( A \) 中的唯一元素，使得原函数 \( f \) 和逆函数 \( f^{-1} \) 之间存在相互逆转的关系。只有当 \( f \) 是双射时，\( f \) 的逆函数 \( f^{-1} \) 才存在。理解逆函数的概念和性质对于解决各种数学和实际问题至关重要。

Let g be a function from the set A to the set B and let f be a function from the set B to the set C. The composition of the functions f and g, denoted for all a ∈ A by f ◦ g, is defined by (f ◦ g)(a) = f (g(a)).

The floor function assigns to the real number x the largest integer that is less than or equal to x. The value of the floor function at x is denoted by x. The ceiling function assigns to the real number x the smallest integer that is greater than or equal to x. The value of the ceiling function at x is denoted by x.

A partial function f from a set A to a set B is an assignment to each element a in a subset of A, called the domain of definition of f , of a unique element b in B. The sets A and B are called the domain and codomain of f , respectively. We say that f is undefined for elements in A that are not in the domain of definition of f . When the domain of definition of f equals A, we say that f is a total function.

### 集合论和函数相关术语定义

#### Set（集合）
- **定义**：一组不同对象的集合。
- **示例**：{1, 2, 3} 是一个集合。

#### Axiom（公理）
- **定义**：理论的基本假设。
- **示例**：欧几里得几何中的五条公理。

#### Paradox（悖论）
- **定义**：逻辑上的矛盾。
- **示例**：罗素悖论。

#### Element, Member of a Set（集合的元素）
- **定义**：集合中的一个对象。
- **示例**：在集合{1, 2, 3}中，1是一个元素。

#### Roster Method（列举法）
- **定义**：通过列出集合的元素来描述集合的方法。
- **示例**：{1, 2, 3}。

#### Set Builder Notation（描述法）
- **定义**：通过描述元素必须满足的性质来表示集合的符号。
- **示例**：{x | x 是一个偶数}。

#### ∅（Empty Set, Null Set 空集）
- **定义**：没有元素的集合。
- **符号**：∅ 或 {}。

#### Universal Set（全集）
- **定义**：包含所有讨论对象的集合。
- **示例**：对于所有整数的全集。

#### Venn Diagram（文氏图）
- **定义**：集合的图形表示法。
- **示例**：用圆圈表示集合及其交集、并集等关系。

#### S = T（集合相等）
- **定义**：集合S和T有相同的元素。
- **符号**：S = T。

#### S ⊆ T（S是T的子集）
- **定义**：S的每个元素也是T的元素。
- **符号**：S ⊆ T。

#### S ⊂ T（S是T的真子集）
- **定义**：S是T的子集，且S ≠ T。
- **符号**：S ⊂ T。

#### Finite Set（有限集）
- **定义**：具有有限个元素的集合。
- **示例**：{1, 2, 3}。

#### Infinite Set（无限集）
- **定义**：不是有限集的集合。
- **示例**：所有自然数的集合。

#### |S|（集合S的基数）
- **定义**：集合S中的元素数量。
- **符号**：|S|。

#### P(S)（S的幂集）
- **定义**：S的所有子集的集合。
- **符号**：P(S)。

#### A ∪ B（A和B的并集）
- **定义**：包含在A或B中的所有元素的集合。
- **符号**：A ∪ B。

#### A ∩ B（A和B的交集）
- **定义**：包含在A和B中的所有元素的集合。
- **符号**：A ∩ B。

#### A − B（A和B的差集）
- **定义**：包含在A中但不在B中的所有元素的集合。
- **符号**：A − B。

#### A'（A的补集）
- **定义**：在全集中但不在A中的所有元素的集合。
- **符号**：A'。

#### A ⊕ B（A和B的对称差）
- **定义**：在A或B中，但不在两者中的元素的集合。
- **符号**：A ⊕ B。

#### Membership Table（元素表）
- **定义**：显示元素在集合中归属情况的表格。

#### Function from A to B（从A到B的函数）
- **定义**：将A中的每个元素唯一地映射到B中的一个元素。
- **符号**：f: A → B。

#### Domain of f（f的定义域）
- **定义**：函数f的定义域A。

#### Codomain of f（f的值域）
- **定义**：函数f的值域B。

#### b is the Image of a under f（b是a在f下的像）
- **定义**：b = f(a)。

#### a is a Pre-image of b under f（a是b在f下的原像）
- **定义**：f(a) = b。

#### Range of f（f的值域）
- **定义**：函数f的所有像的集合。

#### Onto Function, Surjection（满射）
- **定义**：从A到B的函数，使得B中的每个元素都是A中某个元素的像。
- **符号**：f: A → B。

#### One-to-one Function, Injection（单射）
- **定义**：定义域中的不同元素在值域中有不同的像。
- **符号**：f: A → B。

#### One-to-one Correspondence, Bijection（双射）
- **定义**：既是单射又是满射的函数。
- **符号**：f: A → B。

#### Inverse of f（f的逆函数）
- **定义**：逆函数f⁻¹，使得f⁻¹(b) = a，当且仅当f(a) = b。
- **符号**：f⁻¹。

#### f ◦ g（f和g的复合）
- **定义**：将g(x)的值作为f的输入，即f(g(x))。

#### ⌊x⌋（下取整函数）
- **定义**：不超过x的最大整数。

#### ⌈x⌉（上取整函数）
- **定义**：不小于x的最小整数。

#### Partial Function（部分函数）
- **定义**：定义域的一个子集上的每个元素都唯一地映射到值域中的一个元素。

#### Sequence（序列）
- **定义**：定义域是整数集的子集的函数。

#### Geometric Progression（等比数列）
- **定义**：形式为a, ar, ar²,... 的序列，其中a和r是实数。

#### Arithmetic Progression（等差数列）
- **定义**：形式为a, a + d, a + 2d,... 的序列，其中a和d是实数。

#### String（字符串）
- **定义**：有限序列。

#### Empty String（空字符串）
- **定义**：长度为零的字符串。

#### Recurrence Relation（递推关系）
- **定义**：用序列中前一项或多项表示序列第n项的方程。

#### Σⁿᵢ₌₁ aᵢ（求和符号）
- **定义**：a₁ + a₂ + ... + aₙ 的和。

#### ∏ⁿᵢ₌₁ aᵢ（求积符号）
- **定义**：a₁ * a₂ * ... * aₙ 的积。

#### Cardinality（基数）
- **定义**：如果集合A和B之间存在一一对应，则A和B具有相同的基数。

#### Countable Set（可数集）
- **定义**：有限集或可以与正整数集建立一一对应的集合。

#### Uncountable Set（不可数集）
- **定义**：不可数的集合。

#### ℵ₀（Aleph Null）
- **定义**：可数集合的基数。

#### c（连续统基数）
- **定义**：实数集的基数。

#### Cantor Diagonalization Argument（康托尔对角线论证）
- **定义**：一种证明实数集不可数的证明技巧。

#### Computable Function（可计算函数）
- **定义**：存在某种编程语言中的程序可以计算其值的函数。

#### Uncomputable Function（不可计算函数）
- **定义**：不存在任何编程语言中的程序可以计算其值的函数。

#### Continuum Hypothesis（连续统假设）
- **定义**：不存在基数A使得 ℵ₀ < |A| < c。

#### Matrix（矩阵）
- **定义**：数的矩形数组。

#### Matrix Addition（矩阵加法）
- **定义**：见第178页。

#### Matrix Multiplication（矩阵乘法）
- **定义**：见第179页。

#### Iₙ（n阶单位矩阵）
- **定义**：对角线元素为1，其他元素为0的n×n矩阵。

#### Aᵀ（A的转置）
- **定义**：通过交换行和列得到的矩阵。

#### Symmetric Matrix（对称矩阵）
- **定义**：如果矩阵等于其转置，则该矩阵是对称的。

#### Zero-One Matrix（零一矩阵）
- **定义**：每个元素等于0或1的矩阵。

#### A ∨ B（A和B的并）
- **定义**：见第181页。

#### A ∧ B（A和B的交）
- **定义**：见第181页。

#### A ⊗ B（A和B的布尔乘积）
- **定义**

### 算法与复杂度相关术语定义

#### Algorithm（算法）
- **定义**：用于执行计算或解决问题的有限且精确指令序列。
- **示例**：排序算法、搜索算法。

#### Searching Algorithm（搜索算法）
- **定义**：定位列表中某个元素的问题。
- **示例**：线性搜索、二分搜索。

#### Linear Search Algorithm（线性搜索算法）
- **定义**：逐个元素搜索列表的过程。
- **特点**：从列表开头逐个检查每个元素，直到找到目标元素或搜索完毕。

#### Binary Search Algorithm（二分搜索算法）
- **定义**：通过不断将有序列表分成两半进行搜索的过程。
- **特点**：列表必须是有序的，每次比较中间元素并决定搜索范围。

#### Sorting（排序）
- **定义**：将列表元素重新排列成规定顺序的过程。
- **示例**：冒泡排序、插入排序、快速排序。

#### \( f(x) \) is \( O(g(x)) \)
- **定义**：对于某些常数 \( C \) 和 \( k \)，当 \( x > k \) 时，\( |f(x)| \leq C|g(x)| \)。
- **解释**：表示 \( f(x) \) 的增长速率不超过 \( g(x) \) 的常数倍。

#### Witness to the Relationship \( f(x) \) is \( O(g(x)) \)
- **定义**：一对常数 \( C \) 和 \( k \)，使得当 \( x > k \) 时，\( |f(x)| \leq C|g(x)| \)。

#### \( f(x) \) is \( \Omega(g(x)) \)
- **定义**：对于某些正的常数 \( C \) 和 \( k \)，当 \( x > k \) 时，\( |f(x)| \geq C|g(x)| \)。
- **解释**：表示 \( f(x) \) 的增长速率至少与 \( g(x) \) 成比例。

#### \( f(x) \) is \( \Theta(g(x)) \)
- **定义**：表示 \( f(x) \) 既是 \( O(g(x)) \) 又是 \( \Omega(g(x)) \)。
- **解释**：表示 \( f(x) \) 的增长速率与 \( g(x) \) 成比例。

#### Time Complexity（时间复杂度）
- **定义**：算法解决问题所需的时间量。
- **示例**：线性搜索的时间复杂度是 \( O(n) \)。

#### Space Complexity（空间复杂度）
- **定义**：算法解决问题所需的计算机内存量。
- **示例**：合并排序的空间复杂度是 \( O(n) \)。

#### Worst-Case Time Complexity（最坏情况时间复杂度）
- **定义**：算法解决给定大小的问题所需的最大时间量。
- **示例**：二分搜索的最坏情况时间复杂度是 \( O(\log n) \)。

#### Average-Case Time Complexity（平均情况时间复杂度）
- **定义**：算法解决给定大小的问题所需的平均时间量。
- **示例**：平均情况下快速排序的时间复杂度是 \( O(n \log n) \)。

#### Algorithmic Paradigm（算法范式）
- **定义**：基于特定概念构建算法的一般方法。
- **示例**：贪心算法、分治法。

#### Brute Force（蛮力法）
- **定义**：基于问题的陈述和定义，以简单直接的方式构建算法的范式。
- **示例**：逐一尝试所有可能的解决方案。

#### Greedy Algorithm（贪心算法）
- **定义**：在每一步选择最优解的算法。
- **特点**：每次选择最优解，最终得到全局最优解。

#### Tractable Problem（可处理问题）
- **定义**：存在最坏情况下多项式时间算法可以解决的问题。
- **示例**：排序问题、最短路径问题。

#### Intractable Problem（不可处理问题）
- **定义**：不存在最坏情况下多项式时间算法的问题。
- **示例**：旅行商问题（TSP），一般情况下。

#### Solvable Problem（可解问题）
- **定义**：可以通过算法解决的问题。
- **示例**：求解线性方程组。

#### Unsolvable Problem（不可解问题）
- **定义**：无法通过算法解决的问题。
- **示例**：停机问题。

### 结果和复杂度分析

#### Linear and Binary Search Algorithms（线性搜索和二分搜索算法）
- **线性搜索**：逐个检查每个元素。
  - **时间复杂度**：\( O(n) \)。
- **二分搜索**：对有序列表，逐步折半查找。
  - **时间复杂度**：\( O(\log n) \)。

#### Bubble Sort（冒泡排序）
- **定义**：通过多次交换相邻元素，将元素按顺序排列。
  - **时间复杂度**：最坏情况下 \( O(n^2) \)。

#### Insertion Sort（插入排序）
- **定义**：在第 j 步，将第 j 个元素插入到前面已排序好的部分中。
  - **时间复杂度**：最坏情况下 \( O(n^2) \)。

#### 复杂度相关规则

- **组合复杂度**：
  - 如果 \( f1(x) \) 是 \( O(g1(x)) \) 和 \( f2(x) \) 是 \( O(g2(x)) \)，则：
    - \( (f1 + f2)(x) \) 是 \( O(\max(g1(x), g2(x))) \)。
    - \( (f1f2)(x) \) 是 \( O(g1(x)g2(x)) \)。
  
- **多项式表示**：
  - 如果 \( a0, a1,...,an \) 是实数且 \( an \neq 0 \)，则 \( anx^n + an-1x^{n-1} +...+ a1x + a0 \) 是 \( O(x^n) \)，因此也是 \( \Omega(x^n) \) 和 \( \Theta(x^n) \)。

### 这些术语和结果为理解和分析算法提供了基础工具，帮助我们设计高效的计算方法。

### 数论与密码学相关术语定义

#### \( a | b \)（a整除b）
- **定义**：存在一个整数 \( c \) 使得 \( b = ac \)。

#### a 和 b 对模 m 同余
- **定义**：当且仅当 m 整除 \( a - b \)。

#### Modular Arithmetic（模算术）
- **定义**：以一个整数为模数进行的算术运算，模数 \( m \) 满足 \( m \geq 2 \)。

#### Prime（素数）
- **定义**：大于1的整数，且只有两个正整数因子：1和自身。
- **示例**：2, 3, 5, 7。

#### Composite（合数）
- **定义**：大于1但不是素数的整数。
- **示例**：4, 6, 8, 9。

#### Mersenne Prime（梅森素数）
- **定义**：形式为 \( 2^p - 1 \) 的素数，其中 \( p \) 是素数。
- **示例**：\( 2^3 - 1 = 7 \)。

#### gcd(a, b)（最大公约数）
- **定义**：同时整除 a 和 b 的最大整数。
- **示例**：gcd(8, 12) = 4。

#### Relatively Prime Integers（互质整数）
- **定义**：a 和 b 的最大公约数为 1。
- **示例**：8 和 15 是互质的。

#### Pairwise Relatively Prime Integers（成对互质整数）
- **定义**：一个整数集合中每对整数都是互质的。

#### lcm(a, b)（最小公倍数）
- **定义**：能被 a 和 b 整除的最小正整数。
- **示例**：lcm(4, 5) = 20。

#### \( a \mod b \)（a 模 b）
- **定义**：整数 a 除以正整数 b 的余数。
- **示例**：17 mod 5 = 2。

#### \( a \equiv b \pmod{m} \)（a 与 b 对模 m 同余）
- **定义**：a - b 可被 m 整除。
- **示例**：17 ≡ 2 (mod 5)。

#### n = \( (a_k a_{k-1} ... a_1 a_0)_b \)（n 的基 b 表示）
- **定义**：n 在基数 b 下的表示法。
- **示例**：十进制 10 在二进制中表示为 (1010)_2。

#### Binary Representation（二进制表示）
- **定义**：整数的基 2 表示法。
- **示例**：十进制 5 在二进制中表示为 101。

#### Octal Representation（八进制表示）
- **定义**：整数的基 8 表示法。
- **示例**：十进制 8 在八进制中表示为 10。

#### Hexadecimal Representation（十六进制表示）
- **定义**：整数的基 16 表示法。
- **示例**：十进制 15 在十六进制中表示为 F。

#### Linear Combination of a and b with Integer Coefficients
- **定义**：形式为 sa + tb 的表达式，其中 s 和 t 是整数。

#### Bézout Coefficients of a and b（贝祖系数）
- **定义**：使得贝祖等式 sa + tb = gcd(a, b) 成立的整数 s 和 t。

#### Inverse of a Modulo m（a 的模 m 逆元）
- **定义**：整数 x 使得 \( ax \equiv 1 \pmod{m} \)。

#### Linear Congruence（线性同余式）
- **定义**：形式为 \( ax \equiv b \pmod{m} \) 的同余式，其中 x 是整数变量。

#### Pseudoprime to the Base b（基 b 的伪素数）
- **定义**：合数 n 使得 \( b^{n-1} \equiv 1 \pmod{n} \)。

#### Carmichael Number（卡迈克尔数）
- **定义**：对所有与 n 互质的正整数 b，n 都是基 b 的伪素数的合数。

#### Primitive Root of a Prime p（素数 p 的原根）
- **定义**：Z_p 中的整数 r，使得不被 p 整除的每个整数对 p 同余于 r 的某个幂。

#### Discrete Logarithm of a to the Base r Modulo p（a 对基 r 的离散对数）
- **定义**：满足 \( r^e \equiv a \pmod{p} \) 的整数 e，其中 \( 0 \leq e \leq p-1 \)。

#### Encryption（加密）
- **定义**：将消息变为密文的过程。

#### Decryption（解密）
- **定义**：将密文恢复为原始消息的过程。

#### Encryption Key（加密密钥）
- **定义**：确定使用哪个加密函数的值。

#### Shift Cipher（移位密码）
- **定义**：将明文字母 p 加密为 \( (p + k) \pmod{m} \) 的密码，其中 k 是整数。

#### Affine Cipher（仿射密码）
- **定义**：将明文字母 p 加密为 \( (ap + b) \pmod{m} \) 的密码，其中 a 和 b 是整数，且 gcd(a, 26) = 1。

#### Character Cipher（字符密码）
- **定义**：逐个字符加密的密码。

#### Block Cipher（分组密码）
- **定义**：加密固定大小字符块的密码。

#### Cryptanalysis（密码分析）
- **定义**：在不知道加密方法或密钥的情况下，从密文恢复明文的过程。

#### Cryptosystem（密码系统）
- **定义**：一个五元组 (P, C, K, E, D)，其中 P 是明文消息集合，C 是密文消息集合，K 是密钥集合，E 是加密函数集合，D 是解密函数集合。

#### Private Key Encryption（私钥加密）
- **定义**：加密密钥和解密密钥都必须保密的加密方法。

#### Public Key Encryption（公钥加密）
- **定义**：加密密钥是公开的，但解密密钥是保密的加密方法。

#### RSA Cryptosystem（RSA密码系统）
- **定义**：P 和 C 都是 Z_26，K 是一对 (n, e)，其中 n = pq，p 和 q 是大素数，e 是正整数，Ek(p) = p^e mod n，Dk(c) = c^d mod n，其中 d 是 e 对 (p - 1)(q - 1) 的模逆元。

#### Key Exchange Protocol（密钥交换协议）
- **定义**：用于两方生成共享密钥的协议。

#### Digital Signature（数字签名）
- **定义**：接收者用来确定消息发送者真实性的方法。

### 重要结果和定理

#### Division Algorithm（除法算法）
- **定义**：设 a 和 d 为整数，且 d 为正整数。那么存在唯一的整数 q 和 r 使得 \( 0 \leq r < d \) 且 \( a = dq + r \)。

#### Base b Expansion of an Integer（整数的基 b 展开）
- **定理**：设 b 是一个大于 1 的整数，n 是一个正整数。那么 n 可以唯一表示为 \( n = a_kb^k + a_{k-1}b^{k-1} + ... + a_1b + a_0 \) 的形式。

#### Base b Expansion Algorithm（基 b 展开算法）
- **描述**：用于求整数的基 b 展开的算法（见 4.2 节算法 1）。

#### Conventional Algorithms for Addition and Multiplication（加法和乘法的常规算法）
- **描述**：整数加法和乘法的常规算法（见 4.2 节）。

#### Modular Exponentiation Algorithm（模幂算法）
- **描述**：用于计算模幂的算法（见 4.2 节算法 5）。

#### Euclidean Algorithm（欧几里得算法）
- **描述**：用于通过连续使用除法算法来求最大公约数的算法（见 4.3 节算法 1）。

#### Bézout’s Theorem（贝祖定理）
- **定理**：如果 a 和 b 是正整数，那么 gcd(a, b) 是 a 和 b 的线性组合。

#### Sieve of Eratosthenes（埃拉托色尼筛法）
- **描述**：用于找出不超过指定数 n 的所有素数的程序（见 4.3 节）。

#### Fundamental Theorem of Arithmetic（算术基本定理）
- **定理**：每个正整数可以唯一地写成素数的乘积，其中素因子按递增顺序排列。

#### Relationship Between gcd and lcm（最大公约数和最小公倍数的关系）
- **定理**：如果 a 和 b 是正整数，那么 \( ab = \text{gcd}(a, b) \cdot \text{lcm}(a, b) \)。

#### Unique Inverse Modulo m（模 m 的唯一逆元）
- **定理**：如果 m 是正整数且 gcd(a, m) = 1，那么 a 在模 m 下有唯一的逆元。

#### Chinese Remainder Theorem（中国剩余定理）
- **定理**：模成对互质整数的一组线性同余方程在这些模的乘积的模下有唯一解。

#### Fermat’s Little Theorem（费马小定理）
- **定理**：如果 p 是素数且 p 不整除 a，那么 \( a^{p-1} \equiv 1 \pmod{p} \)。

### 递归与数学归纳法相关术语定义

#### Sequence（序列）
- **定义**：定义域为整数集的子集的函数。
- **示例**：\( a_n = 2^n \)。

#### Geometric Progression（等比数列）
- **定义**：形式为 \( a, ar, ar^2, \ldots \) 的序列，其中 \( a \) 和 \( r \) 是实数。
- **示例**：\( 2, 4, 8, 16, \ldots \) 是一个等比数列，其中 \( a = 2 \), \( r = 2 \)。

#### Arithmetic Progression（等差数列）
- **定义**：形式为 \( a, a + d, a + 2d, \ldots \) 的序列，其中 \( a \) 和 \( d \) 是实数。
- **示例**：\( 3, 6, 9, 12, \ldots \) 是一个等差数列，其中 \( a = 3 \), \( d = 3 \)。

#### The Principle of Mathematical Induction（数学归纳法原理）
- **定义**：命题 \( \forall n \ P(n) \) 为真，如果 \( P(1) \) 为真且 \( \forall k \ [P(k) \rightarrow P(k + 1)] \) 为真。

#### Basis Step（基步）
- **定义**：在数学归纳法中证明 \( P(1) \) 的部分。

#### Inductive Step（归纳步）
- **定义**：在数学归纳法中证明 \( P(k) \rightarrow P(k + 1) \) 的部分，适用于所有正整数 \( k \)。

#### Strong Induction（强归纳）
- **定义**：命题 \( \forall n \ P(n) \) 为真，如果 \( P(1) \) 为真且 \( \forall k \ [(P(1) \wedge \ldots \wedge P(k)) \rightarrow P(k + 1)] \) 为真。

#### Well-Ordering Property（良序性质）
- **定义**：每个非空的非负整数集合都有一个最小元素。

#### Recursive Definition of a Function（函数的递归定义）
- **定义**：通过指定初始值和从较小整数的值推导其他值的规则来定义函数。

#### Recursive Definition of a Set（集合的递归定义）
- **定义**：通过指定集合中的初始元素和从集合中已有元素推导其他元素的规则来定义集合。

#### Structural Induction（结构归纳）
- **定义**：用于证明递归定义集合结果的技术。

#### Recursive Algorithm（递归算法）
- **定义**：通过将问题递归地化简为较小输入的问题来求解问题的算法。

#### Merge Sort（归并排序）
- **定义**：一种排序算法，通过将列表分成两部分，分别排序，然后合并结果成一个排序列表。

#### Iteration（迭代）
- **定义**：基于在循环中重复使用操作的过程。

#### Program Correctness（程序正确性）
- **定义**：验证程序总是产生正确结果的过程。

#### Loop Invariant（循环不变式）
- **定义**：在循环的每次遍历期间保持为真的性质。

#### Initial Assertion（初始断言）
- **定义**：指定程序输入值性质的声明。

#### Final Assertion（最终断言）
- **定义**：指定程序输出值应具备的性质的声明，如果程序正确工作。

### 组合数学相关术语定义

#### Combinatorics（组合数学）
- **定义**：研究对象排列的学科。

#### Enumeration（枚举）
- **定义**：对对象排列进行计数。

#### Tree Diagram（树形图）
- **定义**：由一个根节点、离开根节点的分支以及从某些分支端点离开的其他分支组成的图。

#### Permutation（排列）
- **定义**：一组元素的有序排列。
- **示例**：集合 {1, 2, 3} 的排列有 {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}。

#### r-Permutation（r-排列）
- **定义**：一组元素中 r 个元素的有序排列。

#### \( P(n, r) \)
- **定义**：一个有 n 个元素的集合的 r-排列的数量。
- **公式**：\( P(n, r) = \frac{n!}{(n - r)!} \)。

#### r-Combination（r-组合）
- **定义**：一组元素中 r 个元素的无序选择。

#### \( C(n, r) \)
- **定义**：一个有 n 个元素的集合的 r-组合的数量。
- **公式**：\( C(n, r) = \binom{n}{r} = \frac{n!}{r!(n - r)!} \)。

#### Binomial Coefficient（二项式系数）
- **定义**：也是一个有 n 个元素的集合的 r-组合的数量。
- **符号**：\( \binom{n}{r} \)。

#### Combinatorial Proof（组合证明）
- **定义**：使用计数论证而不是代数操作来证明结果的证明方法。

#### Pascal’s Triangle（帕斯卡三角形）
- **定义**：二项式系数的表示方式，其中第 i 行包含 \( \binom{i}{j} \)（j = 0, 1, 2, ..., i）。

#### \( S(n, j) \)（第二类斯特林数）
- **定义**：将 n 个可区分的对象分配到 j 个不可区分的盒子中的方法数，使得每个盒子不为空。

### 组合数学定理和规则

#### Product Rule for Counting（乘积法则）
- **定理**：完成由两个任务组成的程序的方法数是完成第一个任务的方法数乘以完成第一个任务后完成第二个任务的方法数。

#### Product Rule for Sets（集合的乘积法则）
- **定理**：有限集合的笛卡尔积中的元素数是每个集合中的元素数的乘积。

#### Sum Rule for Counting（加法法则）
- **定理**：以两种方式之一完成任务的方法数是这两种方式的方法数之和，如果它们不能同时完成。

#### Sum Rule for Sets（集合的加法法则）
- **定理**：成对不相交的有限集合的并集中的元素数是这些集合中的元素数之和。

#### Subtraction Rule for Counting（计数的减法法则）
- **定理**：如果任务可以用 n1 种方法或 n2 种方法完成，那么完成任务的方法数是 n1 + n2 减去以两种不同方式完成任务的方法数。

#### Subtraction Rule for Sets（集合的减法法则）
- **定理**：两个集合的并集中的元素数是这些集合中的元素数之和减去它们的交集中的元素数。

#### Division Rule for Counting（计数的除法法则）
- **定理**：如果任务可以用 n 种方法完成，并且每种方法对应于 n 种方法中的 d 种，那么完成任务的方法数是 n/d。

#### Division Rule for Sets（集合的除法法则）
- **定理**：设有限集合 A 是 n 个每个有 d 个元素的不相交子集的并集，那么 n = |A|/d。

#### The Pigeonhole Principle（鸽巢原理）
- **定理**：当超过 k 个对象被放入 k 个盒子中时，必定有一个盒子包含多个对象。

#### The Generalized Pigeonhole Principle（广义鸽巢原理）
- **定理**：当 N 个对象被放入 k 个盒子中时，必定有一个盒子至少包含 \( \lceil \frac{N}{k} \rceil \) 个对象。

### 组合数学公式和定理

#### \( P(n, r) = \frac{n!}{(n - r)!} \)
- **定义**：一个有 n 个元素的集合的 r-排列的数量。

#### \( C(n, r) = \binom{n}{r} = \frac{n!}{r!(n - r)!} \)
- **定义**：一个有 n 个元素的集合的 r-组合的数量。

#### Pascal’s Identity（帕斯卡恒等式）
- **公式**：\( \binom{n+1}{k} = \binom{n}{k-1} + \binom{n}{k} \)

#### The Binomial Theorem（二项式定理）
- **公式**：\( (x + y)^n = \sum_{k=0}^{n} \binom{n}{k} x^{n-k} y^k \)

#### 允许重复时的 r-排列数量
- **公式**：有 n 个元素的集合允许重复的 r-排列的数量是 \( n^r \)。

#### 允许重复时的 r-组合数量
- **公式**：有 n 个元素的集合允许重复的 r-组合的数量是 \( C(n + r - 1, r) \)。

#### 不同类型对象的排列数量
- **公式**：n 个对象中有 k 种类型，其中第 i 种类型的对象数量为 \( n_i \)，排列数量为 \( \frac{n!}{n_1! n_2! \ldots n_k!} \)。

### 生成排列的算法
- **描述**：生成集合 {1, 2, ..., n} 的排列的算法。

### 概率与统计相关术语定义

#### Sample Space（样本空间）
- **定义**：实验的所有可能结果的集合。
- **示例**：掷一个骰子的样本空间是 {1, 2, 3, 4, 5, 6}。

#### Event（事件）
- **定义**：样本空间的一个子集。
- **示例**：掷一个骰子得到偶数的事件是 {2, 4, 6}。

#### Probability of an Event (Laplace’s Definition)（事件的概率，拉普拉斯定义）
- **定义**：事件成功结果的数量除以可能结果的总数。
- **公式**：\[ P(E) = \frac{\text{成功结果的数量}}{\text{可能结果的总数}} \]

#### Probability Distribution（概率分布）
- **定义**：从样本空间 \( S \) 的所有结果集合到 [0, 1] 的函数 \( p \)，其中 \( 0 \leq p(x_i) \leq 1 \) 对 \( i = 1, 2, \ldots, n \) 成立，并且 \( \sum_{i=1}^{n} p(x_i) = 1 \)，其中 \( x_1, \ldots, x_n \) 是可能的结果。

#### Probability of an Event E（事件 E 的概率）
- **定义**：事件 E 中结果的概率之和。
- **公式**：\[ P(E) = \sum_{x \in E} P(x) \]

#### \( p(E|F) \) (Conditional Probability of E Given F)（在给定 F 的情况下 E 的条件概率）
- **定义**：\( E \) 和 \( F \) 同时发生的概率除以 \( F \) 发生的概率。
- **公式**：\[ P(E|F) = \frac{P(E \cap F)}{P(F)} \]

#### Independent Events（独立事件）
- **定义**：事件 E 和 F 满足 \( P(E \cap F) = P(E)P(F) \)。
- **示例**：掷硬币和掷骰子是独立事件。

#### Pairwise Independent Events（成对独立事件）
- **定义**：事件 \( E_1, E_2, \ldots, E_n \) 满足 \( P(E_i \cap E_j) = P(E_i)P(E_j) \) 对于所有 \( i, j \) 成立，且 \( 1 \leq i < j \leq n \)。

#### Mutually Independent Events（相互独立事件）
- **定义**：事件 \( E_1, E_2, \ldots, E_n \) 满足 \( P(E_{i1} \cap E_{i2} \cap \ldots \cap E_{im}) = P(E_{i1})P(E_{i2})\ldots P(E_{im}) \) 对于所有 \( i1, i2, \ldots, im \) 成立，且 \( 1 \leq i1 < i2 < \ldots < im \leq n \) 且 \( m \geq 2 \)。

#### Random Variable（随机变量）
- **定义**：将实验的每个可能结果分配给一个实数的函数。

#### Distribution of a Random Variable X（随机变量 X 的分布）
- **定义**：由成对的 (r, P(X = r)) 组成的集合，其中 r 属于 X(S)。

#### Uniform Distribution（均匀分布）
- **定义**：将等概率分配给有限集合元素的分布。

#### Expected Value of a Random Variable（随机变量的期望值）
- **定义**：随机变量的加权平均值，随机变量的值由结果的概率加权。
- **公式**：\[ E(X) = \sum_{s \in S} P(s)X(s) \]

#### Geometric Distribution（几何分布）
- **定义**：随机变量 X 的分布，使得 \( P(X = k) = (1 - p)^{k-1}p \) 对于 k = 1, 2, ... 成立，其中 p 是实数且 \( 0 \leq p \leq 1 \)。

#### Independent Random Variables（独立随机变量）
- **定义**：随机变量 X 和 Y 满足 \( P(X = r1 \text{ and } Y = r2) = P(X = r1)P(Y = r2) \) 对于所有实数 \( r1 \) 和 \( r2 \) 成立。

#### Variance of a Random Variable X（随机变量 X 的方差）
- **定义**：随机变量 X 的值与其期望值 E(X) 的差的平方的加权平均值，权重由结果的概率给出。
- **公式**：\[ V(X) = \sum_{s \in S} (X(s) - E(X))^2 P(s) \]

#### Standard Deviation of a Random Variable X（随机变量 X 的标准差）
- **定义**：随机变量 X 的方差的平方根。
- **公式**：\[ \sigma(X) = \sqrt{V(X)} \]

#### Bernoulli Trial（伯努利试验）
- **定义**：只有两个可能结果的实验。

#### Probabilistic (or Monte Carlo) Algorithm（概率（或蒙特卡罗）算法）
- **定义**：在一个或多个步骤中做出随机选择的算法。

#### Probabilistic Method（概率方法）
- **定义**：通过给对象分配概率并证明对象具有这些性质的概率为正来证明集合中具有某些性质的对象存在的技术。

### 重要结果与定理

#### Bernoulli Trials（伯努利试验）的成功概率
- **定理**：当进行 \( n \) 次独立伯努利试验时，正好有 \( k \) 次成功的概率等于 \( C(n, k)p^kq^{n-k} \)，其中 \( p \) 是成功的概率，\( q = 1 - p \) 是失败的概率。

#### Bayes’ Theorem（贝叶斯定理）
- **定理**：如果 \( E \) 和 \( F \) 是样本空间 \( S \) 中的事件，且 \( P(E) \neq 0 \) 和 \( P(F) \neq 0 \)，那么
\[ P(F | E) = \frac{P(E | F)P(F)}{P(E | F)P(F) + P(E | F)P(F)} \]

#### Expected Value of a Random Variable（随机变量的期望值）
- **公式**：若随机变量 \( X \) 的分布为一组 \( (r, P(X = r)) \)，则其期望值为
\[ E(X) = \sum_{r \in X(S)} P(X = r)r \]

#### Linearity of Expectations（期望的线性性）
- **定理**：若 \( X_1, X_2, \ldots, X_n \) 是随机变量，则
\[ E(X_1 + X_2 + \cdots + X_n) = E(X_1) + E(X_2) + \cdots + E(X_n) \]

#### Expectation of Independent Random Variables（独立随机变量的期望）
- **定理**：若 \( X \) 和 \( Y \) 是独立随机变量，则
\[ E(XY) = E(X)E(Y) \]

#### Bienaymé’s Formula（比纳耶公式）
- **定理**：若 \( X_1, X_2, \ldots, X_n \) 是独立随机变量，则
\[ V(X_1 + X_2 + \cdots + X_n) = V(X_1) + V(X_2) + \cdots + V(X_n) \]

#### Chebyshev’s Inequality（切比雪夫不等式）
- **定理**：若 \( X \) 是具有概率函数 \( P \) 的随机变量，且 \( r \) 是正实数，则
\[ P(|X(s) - E(X)| \geq r) \leq \frac{V(X)}{r^2} \]

这些结果和定理在概率论和统计学中具有广泛应用，帮助我们分析和解决涉及随机事件和随机变量的问题。

### 递推关系与算法相关术语定义

#### Recurrence Relation（递推关系）
- **定义**：一个公式，通过前一项或多项表示一个序列中的项（除了一些初始项）。
- **示例**：Fibonacci 数列的递推关系 \( F(n) = F(n-1) + F(n-2) \)。

#### Initial Conditions for a Recurrence Relation（递推关系的初始条件）
- **定义**：满足递推关系的序列的项在递推关系生效之前的值。
- **示例**：Fibonacci 数列的初始条件 \( F(0) = 0, F(1) = 1 \)。

#### Dynamic Programming（动态规划）
- **定义**：一种算法范式，通过递归地将问题分解为重叠的子问题，并使用递推关系结合它们的解来找到优化问题的解。
- **示例**：解决最短路径问题的 Bellman-Ford 算法。

#### Linear Homogeneous Recurrence Relation with Constant Coefficients（常系数线性齐次递推关系）
- **定义**：一个递推关系，通过前几项的线性组合表示序列中的项（除初始项外）。
- **示例**：\( a_n = c_1 a_{n-1} + c_2 a_{n-2} \)。

#### Characteristic Roots of a Linear Homogeneous Recurrence Relation with Constant Coefficients（常系数线性齐次递推关系的特征根）
- **定义**：与常系数线性齐次递推关系相关联的多项式的根。

#### Linear Nonhomogeneous Recurrence Relation with Constant Coefficients（常系数线性非齐次递推关系）
- **定义**：一个递推关系，通过前几项的线性组合加上仅依赖于索引的不完全为零的函数表示序列中的项（除初始项外）。
- **示例**：\( a_n = c_1 a_{n-1} + c_2 a_{n-2} + f(n) \)。

#### Divide-and-Conquer Algorithm（分治算法）
- **定义**：一种递归地将问题分解为固定数量的较小且不重叠的同类型子问题的算法。
- **示例**：快速排序、归并排序。

#### Generating Function of a Sequence（序列的生成函数）
- **定义**：形式上的级数，其第 n 项的系数是序列的第 n 项。
- **示例**：对于序列 \( a_0, a_1, a_2, \ldots \)，生成函数是 \( G(x) = \sum_{n=0}^{\infty} a_n x^n \)。

#### Sieve of Eratosthenes（埃拉托色尼筛法）
- **定义**：用于找出不超过指定正整数的所有素数的程序。

#### Derangement（错排）
- **定义**：对象的排列，使得没有一个对象在其原始位置上。
- **示例**：对 {1, 2, 3} 的错排是 {2, 3, 1} 和 {3, 1, 2}。

### 重要结果

#### The Formula for the Number of Elements in the Union of Two Finite Sets（两个有限集合的并集中的元素数量公式）
- **公式**：\[ |A \cup B| = |A| + |B| - |A \cap B| \]
- **解释**：两个集合的并集中的元素数等于两个集合中元素数的和减去它们的交集中的元素数。

### 重要结果与定理

#### The Formula for the Number of Elements in the Union of Three Finite Sets（三个有限集合的并集中的元素数量公式）
- **公式**：\[ |A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C| \]
- **解释**：三个集合的并集中的元素数等于三个集合中元素数的和，减去每两个集合的交集中的元素数，再加上三个集合的交集中的元素数。

#### The Principle of Inclusion–Exclusion（容斥原理）
- **公式**：
\[ |A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{1 \leq i \leq n} |A_i| - \sum_{1 \leq i < j \leq n} |A_i \cap A_j| + \sum_{1 \leq i < j < k \leq n} |A_i \cap A_j \cap A_k| - \cdots + (-1)^{n+1} |A_1 \cap A_2 \cap \cdots \cap A_n| \]
- **解释**：包含 n 个集合的并集的元素数等于所有单个集合的元素数的和，减去每两个集合的交集中的元素数，再加上每三个集合的交集中的元素数，如此反复，直到最后加上或减去所有集合的交集中的元素数。

#### The Number of Onto Functions from a Set with m Elements to a Set with n Elements（从具有 m 个元素的集合到具有 n 个元素的集合的满射函数的数量）
- **公式**：
\[ n^m - C(n, 1)(n-1)^m + C(n, 2)(n-2)^m - \cdots + (-1)^{n-1} C(n, n-1) \cdot 1^m \]
- **解释**：从具有 m 个元素的集合到具有 n 个元素的集合的满射函数的数量可以用上面的公式表示，其中 \( C(n, k) \) 是二项式系数。

#### The Number of Derangements of n Objects（n 个对象的错排数量）
- **公式**：
\[ D_n = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \cdots + (-1)^n \frac{1}{n!} \right) \]
- **解释**：n 个对象的错排数量（即没有一个对象在其原始位置上的排列数量）可以用上面的公式表示。

### 关系与图论相关术语定义

#### Binary Relation from A to B（从 A 到 B 的二元关系）
- **定义**：A × B 的一个子集。
- **示例**：A = {1, 2}, B = {a, b}，二元关系 R = {(1, a), (2, b)}。

#### Relation on A（在 A 上的关系）
- **定义**：从 A 到 A 的二元关系，即 A × A 的一个子集。
- **示例**：A = {1, 2}，关系 R = {(1, 1), (1, 2)}。

#### \( S \circ R \)（R 和 S 的复合）
- **定义**：如果 (a, b) ∈ R 且 (b, c) ∈ S，那么 (a, c) ∈ \( S \circ R \)。

#### \( R^{-1} \)（R 的逆关系）
- **定义**：R 的逆关系由所有 (b, a) 组成，其中 (a, b) ∈ R。
- **示例**：如果 R = {(1, a), (2, b)}，那么 \( R^{-1} = {(a, 1), (b, 2)} \)。

#### \( R^n \)（R 的 n 次幂）
- **定义**：R 的 n 次复合关系。

#### Reflexive（自反）
- **定义**：若对 A 上的关系 R，对于所有 a ∈ A，有 (a, a) ∈ R，则 R 是自反的。

#### Symmetric（对称）
- **定义**：若对 A 上的关系 R，若 (a, b) ∈ R 则 (b, a) ∈ R，则 R 是对称的。

#### Antisymmetric（反对称）
- **定义**：若对 A 上的关系 R，若 (a, b) ∈ R 且 (b, a) ∈ R 则 a = b，则 R 是反对称的。

#### Transitive（传递）
- **定义**：若对 A 上的关系 R，若 (a, b) ∈ R 且 (b, c) ∈ R 则 (a, c) ∈ R，则 R 是传递的。

#### n-ary Relation on \( A_1, A_2, \ldots, A_n \)（在 \( A_1, A_2, \ldots, A_n \) 上的 n 元关系）
- **定义**：\( A_1 \times A_2 \times \cdots \times A_n \) 的一个子集。

#### Relational Data Model（关系数据模型）
- **定义**：一种使用 n 元关系表示数据库的模型。

#### Primary Key（主键）
- **定义**：一个 n 元关系的域，使得 n 元组可以由该域的值唯一确定。

#### Composite Key（复合键）
- **定义**：n 元关系的多个域的笛卡尔积，使得 n 元组可以由这些域的值唯一确定。

#### Selection Operator（选择操作符）
- **定义**：选择满足指定条件的 n 元关系中的 n 元组的函数。

#### Projection（投影）
- **定义**：通过删除字段从 n 元关系中产生较小度关系的函数。

#### Join（连接）
- **定义**：结合在某些字段上相同的 n 元关系的函数。

#### Directed Graph or Digraph（有向图）
- **定义**：由称为顶点的元素和这些元素的有序对（称为边）组成的集合。

#### Loop（回路）
- **定义**：形如 (a, a) 的边。

#### Closure of a Relation R with Respect to a Property P（R 关于性质 P 的闭包）
- **定义**：包含 R 且具有性质 P 的关系 S，并且 S 被包含在任何包含 R 且具有性质 P 的关系中。

#### Path in a Digraph（有向图中的路径）
- **定义**：边的序列 (a, x1), (x1, x2), ..., (xn−2, xn−1), (xn−1, b)，使得每条边的终点是下条边的起点。

#### Circuit (or Cycle) in a Digraph（有向图中的回路）
- **定义**：以相同顶点开始和结束的路径。

#### \( R^* \)（连通关系）
- **定义**：由那些存在从 a 到 b 的路径的有序对 (a, b) 组成的关系。

#### Equivalence Relation（等价关系）
- **定义**：自反、对称和传递的关系。

#### Equivalent（等价）
- **定义**：如果 R 是等价关系，且 aRb，则 a 和 b 是等价的。

#### \( [a]_R \)（a 关于 R 的等价类）
- **定义**：A 中所有与 a 等价的元素的集合。

#### \( [a]_m \)（模 m 的同余类）
- **定义**：与 a 对模 m 同余的整数集合。

#### Partition of a Set S（集合 S 的划分）
- **定义**：一组成对不相交的非空子集，它们的并集是 S。

#### Partial Ordering（偏序）
- **定义**：自反、反对称和传递的关系。

#### Poset (S, R)（偏序集）
- **定义**：集合 S 及其上的偏序关系 R。

#### Comparable（可比较）
- **定义**：在偏序集 (A, ≤) 中，如果 a ≤ b 或 b ≤ a，则元素 a 和 b 是可比较的。

#### Incomparable（不可比较）
- **定义**：在偏序集中不可比较的元素。

#### Total (or Linear) Ordering（全序或线性序）
- **定义**：每对元素都可比较的偏序关系。

#### Totally (or Linearly) Ordered Set（全序集或线性序集）
- **定义**：具有全序（或线性序）的偏序集。

#### Well-Ordered Set（良序集）
- **定义**：偏序集 (S, ≤)，其中 ≤ 是全序，且 S 的每个非空子集都有最小元素。

### 关系与排序相关术语定义

#### Lexicographic Order（字典序）
- **定义**：笛卡尔积或字符串的部分顺序。
- **示例**：在字典序中，"apple" 在 "banana" 之前。

#### Hasse Diagram（哈斯图）
- **定义**：偏序集的图形表示，其中不显示自反性和由传递性引起的所有边，并且通过顶点的位置指示边的方向。

#### Maximal Element（极大元）
- **定义**：偏序集中的一个元素，它不小于偏序集中的任何其他元素。
- **示例**：在集合 {1, 2, 3} 和关系 ≤ 上，3 是极大元。

#### Minimal Element（极小元）
- **定义**：偏序集中的一个元素，它不大于偏序集中的任何其他元素。
- **示例**：在集合 {1, 2, 3} 和关系 ≤ 上，1 是极小元。

#### Greatest Element（最大元）
- **定义**：偏序集中大于所有其他元素的一个元素。
- **示例**：在集合 {1, 2, 3} 和关系 ≤ 上，3 是最大元。

#### Least Element（最小元）
- **定义**：偏序集中小于所有其他元素的一个元素。
- **示例**：在集合 {1, 2, 3} 和关系 ≤ 上，1 是最小元。

#### Upper Bound of a Set（集合的上界）
- **定义**：偏序集中大于集合中所有其他元素的一个元素。
- **示例**：在集合 {1, 2} 和关系 ≤ 上，3 是上界。

#### Lower Bound of a Set（集合的下界）
- **定义**：偏序集中小于集合中所有其他元素的一个元素。
- **示例**：在集合 {2, 3} 和关系 ≤ 上，1 是下界。

#### Least Upper Bound of a Set（集合的最小上界）
- **定义**：集合的上界中小于所有其他上界的元素。
- **示例**：在集合 {1, 2} 和关系 ≤ 上，2 是最小上界。

#### Greatest Lower Bound of a Set（集合的最大下界）
- **定义**：集合的下界中大于所有其他下界的元素。
- **示例**：在集合 {2, 3} 和关系 ≤ 上，2 是最大下界。

#### Lattice（格）
- **定义**：每两个元素都有最大下界和最小上界的部分有序集。

#### Compatible Total Ordering for a Partial Ordering（兼容部分顺序的全序）
- **定义**：包含给定部分顺序的全序。

#### Topological Sort（拓扑排序）
- **定义**：构建与给定部分顺序兼容的全序。

### 重要结果与定理

#### The Reflexive Closure of a Relation R on the Set A（集合 A 上关系 R 的自反闭包）
- **公式**：自反闭包等于 \( R \cup \{(a, a) | a \in A\} \)。

#### The Symmetric Closure of a Relation R on the Set A（集合 A 上关系 R 的对称闭包）
- **公式**：对称闭包等于 \( R \cup R^{-1} \)，其中 \( R^{-1} = \{(b, a) | (a, b) \in R\} \)。

#### The Transitive Closure of a Relation（关系的传递闭包）
- **公式**：传递闭包等于由该关系形成的连通关系。

#### Warshall’s Algorithm for Finding the Transitive Closure of a Relation（用于查找关系的传递闭包的 Warshall 算法）
- **解释**：Warshall 算法用于计算给定关系的传递闭包。

#### Equivalence Relation Properties（等价关系的性质）
- **定理**：设 R 是一个等价关系，那么以下三个陈述是等价的：
  1. \( aRb \)
  2. \( [a]_R \cap [b]_R \neq \emptyset \)
  3. \( [a]_R = [b]_R \)

#### Equivalence Classes and Partitions（等价类和划分）
- **定理**：集合 A 上的等价关系的等价类形成 A 的一个划分。反之，从任何划分可以构造等价关系，使得等价类是划分中的子集。

#### The Principle of Well-Ordered Induction（良序归纳原理）
- **解释**：良序归纳原理是一种数学证明技术，特别适用于良序集。

#### The Topological Sorting Algorithm（拓扑排序算法）
- **解释**：拓扑排序算法用于构建与给定部分顺序兼容的全序。这在依赖关系图中非常有用，例如任务调度。

### 图论相关术语定义

#### Undirected Edge（无向边）
- **定义**：与集合 \{u, v\} 相关联的边，其中 u 和 v 是顶点。
- **示例**：在无向图中，边 \{A, B\} 表示顶点 A 和 B 之间的无向连接。

#### Directed Edge（有向边）
- **定义**：与有序对 (u, v) 相关联的边，其中 u 和 v 是顶点。
- **示例**：在有向图中，边 (A, B) 表示从顶点 A 到顶点 B 的方向连接。

#### Multiple Edges（重边）
- **定义**：连接相同顶点的不同边。
- **示例**：在图中，两个边都连接顶点 A 和 B。

#### Multiple Directed Edges（重有向边）
- **定义**：与相同有序对 (u, v) 相关联的不同有向边。
- **示例**：在有向图中，从 A 到 B 有两条不同的边。

#### Loop（自环）
- **定义**：连接顶点与自身的边。
- **示例**：在图中，边 (A, A) 表示顶点 A 自己连接自己。

#### Undirected Graph（无向图）
- **定义**：顶点集和无向边集组成的图，每条边与一个或两个顶点的集合相关联。
- **示例**：包含顶点 A, B, C 和边 \{A, B\}, \{B, C\} 的图。

#### Simple Graph（简单图）
- **定义**：无重边和自环的无向图。
- **示例**：不包含重边或自环的图。

#### Multigraph（多重图）
- **定义**：可以包含重边但不包含自环的无向图。
- **示例**：有多条边连接同一对顶点，但没有自环的图。

#### Pseudograph（伪图）
- **定义**：可以包含重边和自环的无向图。
- **示例**：既有重边也有自环的图。

#### Directed Graph（有向图）
- **定义**：顶点集和有向边集组成的图，每条边与顶点的有序对相关联。
- **示例**：包含顶点 A, B, C 和边 (A, B), (B, C) 的图。

#### Directed Multigraph（多重有向图）
- **定义**：可以包含重有向边的有向图。
- **示例**：从 A 到 B 有多条不同边的有向图。

#### Simple Directed Graph（简单有向图）
- **定义**：没有自环和重有向边的有向图。
- **示例**：不包含自环或重有向边的有向图。

#### Adjacent（相邻）
- **定义**：如果两个顶点之间有一条边，则这两个顶点相邻。
- **示例**：如果边 \{A, B\} 存在，则顶点 A 和 B 相邻。

#### Incident（关联）
- **定义**：如果一条边的一个顶点是该边的端点，则该边与该顶点关联。
- **示例**：如果边 \{A, B\} 存在，则这条边与顶点 A 和 B 关联。

#### \( \deg v \)（顶点 v 在无向图中的度）
- **定义**：与顶点 v 关联的边数，自环计作两条边。
- **示例**：如果顶点 A 与三条边 \{A, B\}, \{A, C\}, \{A, D\} 关联，则 \( \deg A = 3 \)。如果 A 有一个自环，则 \( \deg A = 4 \)。

### 图论术语定义

#### \( \deg^-(v) \)（有向图中顶点 v 的入度）
- **定义**：以 v 为终点的边数。
- **示例**：如果有三条边 (u1, v), (u2, v), (u3, v)，则 \( \deg^-(v) = 3 \)。

#### \( \deg^+(v) \)（有向图中顶点 v 的出度）
- **定义**：以 v 为起点的边数。
- **示例**：如果有三条边 (v, w1), (v, w2), (v, w3)，则 \( \deg^+(v) = 3 \)。

#### Underlying Undirected Graph（有向图的底层无向图）
- **定义**：通过忽略边的方向获得的无向图。
- **示例**：有向图中 (A, B) 和 (B, A) 的底层无向图是 \{A, B\}。

#### \( K_n \)（n 个顶点的完全图）
- **定义**：有 n 个顶点的无向图，其中每对顶点之间都有一条边。
- **示例**：\( K_3 \) 是包含三条边和三个顶点的完全图。

#### Bipartite Graph（二分图）
- **定义**：顶点集可以划分为 V1 和 V2 的子集的图，每条边连接 V1 中的一个顶点和 V2 中的一个顶点。对 (V1, V2) 称为 V 的二分。
- **示例**：顶点集 \{A, B\} 和 \{1, 2\}，边集 \{(A, 1), (A, 2), (B, 1), (B, 2)\} 是一个二分图。

#### \( K_{m,n} \)（完全二分图）
- **定义**：顶点集划分为 m 元素的子集和 n 元素的子集的图，当且仅当一个顶点在第一个子集中，另一个顶点在第二个子集中时，两顶点间有一条边。
- **示例**：\( K_{2, 3} \) 包含 2 个顶点在 V1，3 个顶点在 V2，每对顶点之间有一条边。

#### \( C_n \)（大小为 n 的环），\( n \geq 3 \)
- **定义**：有 n 个顶点 \( v1, v2, \ldots, vn \) 和边 \{v1, v2\}, \{v2, v3\}, ..., \{vn, v1\} 的图。
- **示例**：\( C_3 \) 是包含三条边和三个顶点的三角形。

#### \( W_n \)（大小为 n 的轮图），\( n \geq 3 \)
- **定义**：从 \( C_n \) 通过添加一个顶点和从此顶点到 \( C_n \) 中原顶点的边得到的图。
- **示例**：\( W_4 \) 是一个四边形加上一个中心顶点，中心顶点与四边形的每个顶点相连。

#### \( Q_n \)（n 维超立方体），\( n \geq 1 \)
- **定义**：长度为 n 的 2^n 个位串作为顶点，每对位串之间差一个位的边连接。
- **示例**：\( Q_2 \) 是一个正方形。

#### Matching in a Graph G（图 G 中的匹配）
- **定义**：没有两个边有公共端点的边集。
- **示例**：在一个三角形图中，任何一条边都是一个匹配。

#### Complete Matching from \( V1 \) to \( V2 \)（从 V1 到 V2 的完全匹配）
- **定义**：每个 \( V1 \) 中的顶点都是匹配边的一个端点的匹配。
- **示例**：在 \( K_{3,3} \) 中，每条边都属于一个完全匹配。

#### Maximum Matching（最大匹配）
- **定义**：包含最多边的匹配。
- **示例**：在一个四边形图中，两条对边构成最大匹配。

#### Isolated Vertex（孤立顶点）
- **定义**：度为零的顶点。
- **示例**：一个没有任何边连接的顶点。

#### Pendant Vertex（悬挂顶点）
- **定义**：度为一的顶点。
- **示例**：树中的叶子节点。

#### Regular Graph（正则图）
- **定义**：所有顶点度相同的图。
- **示例**：所有顶点度为 3 的图称为三正则图。

#### Subgraph of a Graph G = (V, E)（图 G 的子图）
- **定义**：图 (W, F)，其中 W 是 V 的子集，F 是 E 的子集。
- **示例**：从图中选择部分顶点和边得到的图。

#### \( G1 \cup G2 \)（G1 和 G2 的并）
- **定义**：图 (V1 ∪ V2, E1 ∪ E2)，其中 G1 = (V1, E1) 和 G2 = (V2, E2)。
- **示例**：两个图的顶点和边的并集。

#### Adjacency Matrix（邻接矩阵）
- **定义**：使用顶点邻接关系表示图的矩阵。
- **示例**：表示图中顶点间边的有无的矩阵。

#### Incidence Matrix（关联矩阵）
- **定义**：使用边和顶点的关联关系表示图的矩阵。
- **示例**：表示图中顶点和边的关联的矩阵。

#### Isomorphic Simple Graphs（同构简单图）
- **定义**：简单图 G1 = (V1, E1) 和 G2 = (V2, E2) 是同构的，如果存在从 V1 到 V2 的一一对应 f，使得 {f(v1), f(v2)} ∈ E2 当且仅当 {v1, v2} ∈ E1 对 V1 中的所有 v1 和 v2 成立。
- **示例**：两个拓扑结构相同但顶点标签不同的图。

#### Invariant for Graph Isomorphism（图同构的不变量）
- **定义**：同构图都具有或都不具有的性质。
- **示例**：顶点数、边数。

#### Path from u to v in an Undirected Graph（无向图中从 u 到 v 的路径）
- **定义**：边的序列 e1, e2, ..., en，其中 ei 与 {xi, xi+1} 相关联，对 i = 0, 1, ..., n，其中 x0 = u，xn+1 = v。
- **示例**：从 A 到 D 的路径可能是 \{(A, B), (B, C), (C, D)\}。

### 图论术语定义（续）

#### Path from \( u \) to \( v \) in a Graph with Directed Edges（有向图中从 \( u \) 到 \( v \) 的路径）
- **定义**：边的序列 \( e_1, e_2, \ldots, e_n \)，其中 \( e_i \) 与 \((x_i, x_{i+1})\) 相关联，对 \( i = 0, 1, \ldots, n \)，其中 \( x_0 = u \)，\( x_{n+1} = v \)。

#### Simple Path（简单路径）
- **定义**：不包含重复边的路径。

#### Circuit（回路）
- **定义**：长度 \( n \geq 1 \) 的路径，起点和终点是同一个顶点。

#### Connected Graph（连通图）
- **定义**：任意两个顶点之间都有路径的无向图。

#### Cut Vertex of G（G 的割点）
- **定义**：移除后使图 G 变为不连通的顶点 \( v \)。

#### Cut Edge of G（G 的割边）
- **定义**：移除后使图 G 变为不连通的边 \( e \)。

#### Nonseparable Graph（不可分图）
- **定义**：没有割点的图。

#### Vertex Cut of G（G 的顶点割集）
- **定义**：使图 G 去掉此顶点集合 \( V \) 后变为不连通的顶点子集。

#### \( \kappa(G) \)（G 的顶点连通度）
- **定义**：图 G 的最小顶点割集的大小。

#### k-Connected Graph（k-连通图）
- **定义**：顶点连通度不小于 \( k \) 的图。

#### Edge Cut of G（G 的边割集）
- **定义**：使图 G 去掉此边集合 \( E \) 后变为不连通的边子集。

#### \( \lambda(G) \)（G 的边连通度）
- **定义**：图 G 的最小边割集的大小。

#### Connected Component of a Graph G（图 G 的连通分量）
- **定义**：图 G 的极大连通子图。

#### Strongly Connected Directed Graph（强连通有向图）
- **定义**：任意两个顶点之间都有有向路径的有向图。

#### Strongly Connected Component of a Directed Graph G（有向图 G 的强连通分量）
- **定义**：图 G 的极大强连通子图。

#### Euler Path（欧拉路径）
- **定义**：包含图中每条边且仅包含一次的路径。

#### Euler Circuit（欧拉回路）
- **定义**：包含图中每条边且仅包含一次的回路。

#### Hamilton Path（哈密顿路径）
- **定义**：图中经过每个顶点且仅经过一次的路径。

#### Hamilton Circuit（哈密顿回路）
- **定义**：图中经过每个顶点且仅经过一次的回路。

#### Weighted Graph（加权图）
- **定义**：边上赋有权值的图。

#### Shortest-Path Problem（最短路径问题）
- **定义**：在加权图中，找出使路径上的边权值和最小的路径问题。

#### Traveling Salesperson Problem（旅行推销员问题）
- **定义**：在加权图中，要求找出经过每个顶点且总长度最短的回路问题。

#### Planar Graph（平面图）
- **定义**：可以在平面上绘制且无边交叉的图。

#### Regions of a Representation of a Planar Graph（平面图表示的区域）
- **定义**：由平面图表示划分的平面区域。

#### Elementary Subdivision（基本细分）
- **定义**：从无向图中移除边 \{u, v\} 并添加新顶点 \( w \) 以及边 \{u, w\} 和 \{w, v\} 的操作。

#### Homeomorphic（同胚）
- **定义**：如果两个无向图可以通过一系列基本细分从同一个图得到，则它们是同胚的。

#### Graph Coloring（图着色）
- **定义**：为图的顶点分配颜色，使得相邻顶点的颜色不同。

### 图论术语与定理

#### Chromatic Number（色数）
- **定义**：图着色中所需的最少颜色数。

### 重要结果与定理

#### The Handshaking Theorem（握手定理）
- **定理**：如果 \( G = (V, E) \) 是一张有 \( m \) 条边的无向图，那么 \( 2m = \sum_{v \in V} \deg(v) \)。
- **解释**：图中所有顶点度的总和等于边数的两倍。

#### Hall’s Marriage Theorem（霍尔婚姻定理）
- **定理**：二分图 \( G = (V, E) \) 具有二分法 \( (V1, V2) \)，当且仅当 \( V1 \) 的所有子集 \( A \) 满足 \( |N(A)| \geq |A| \) 时，存在从 \( V1 \) 到 \( V2 \) 的完全匹配。
- **解释**：每个子集 \( A \) 的邻居数不小于 \( A \) 的大小是存在完全匹配的必要和充分条件。

#### Euler Circuit（欧拉回路）
- **定理**：在一个连通多重图中，当且仅当每个顶点的度数为偶数时，存在欧拉回路。
- **解释**：欧拉回路经过每条边且仅经过一次。

#### Euler Path（欧拉路径）
- **定理**：在一个连通多重图中，当且仅当至多两个顶点的度数为奇数时，存在欧拉路径。
- **解释**：欧拉路径经过每条边且仅经过一次，但起点和终点可以不同。

#### Dijkstra’s Algorithm（迪杰斯特拉算法）
- **定义**：用于在加权图中寻找两个顶点之间最短路径的算法。
- **解释**：从源点开始，逐步找到最短路径，直至达到目标顶点。

#### Euler’s Formula（欧拉公式）
- **定理**：对于一个连通平面图，区域数 \( r \)、边数 \( e \) 和顶点数 \( v \) 之间满足关系 \( r = e - v + 2 \)。
- **解释**：平面图的区域、边和顶点之间的基本关系。

#### Kuratowski’s Theorem（库拉托夫斯基定理）
- **定理**：当且仅当一个图包含一个与 \( K3,3 \) 或 \( K5 \) 同胚的子图时，该图是非平面的。
- **解释**：这是判定图是否非平面的一个标准。

#### The Four Color Theorem（四色定理）
- **定理**：每个平面图可以用不超过四种颜色着色。
- **解释**：这是图着色中的一个经典定理，证明超出了本书的范围。

这些定理在图论中非常重要，帮助理解图的结构和性质。

### 树与森林相关术语定义

#### Tree（树）
- **定义**：无简单回路的连通无向图。
- **示例**：一个包含边 \((A, B)\), \((B, C)\), \((C, D)\) 的连通无向图，没有回路。

#### Forest（森林）
- **定义**：无简单回路的无向图（可以是不连通的）。
- **示例**：两个独立的树组成的图。

#### Rooted Tree（根树）
- **定义**：具有指定根顶点的有向图，从根顶点到每个其他顶点都有唯一路径。
- **示例**：根顶点 A，其他顶点 B, C, D，路径为 A->B, A->C, B->D。

#### Subtree（子树）
- **定义**：树的子图，且本身也是一棵树。
- **示例**：从一个更大的树中剪下的部分树结构。

#### Parent of \( v \) in a Rooted Tree（根树中顶点 \( v \) 的父节点）
- **定义**：与 \( v \) 相连的顶点 \( u \)，使得 \((u, v)\) 是根树中的一条边。
- **示例**：在路径 A->B->C 中，B 是 C 的父节点。

#### Child of a Vertex \( v \) in a Rooted Tree（根树中顶点 \( v \) 的子节点）
- **定义**：以 \( v \) 为父节点的任一顶点。
- **示例**：在路径 A->B->C 中，C 是 B 的子节点。

#### Sibling of a Vertex \( v \) in a Rooted Tree（根树中顶点 \( v \) 的兄弟节点）
- **定义**：与 \( v \) 有相同父节点的顶点。
- **示例**：在路径 A->B, A->C 中，B 和 C 是兄弟节点。

#### Ancestor of a Vertex \( v \) in a Rooted Tree（根树中顶点 \( v \) 的祖先节点）
- **定义**：从根到 \( v \) 的路径上的任一顶点。
- **示例**：在路径 A->B->C 中，A 和 B 是 C 的祖先节点。

这些术语和概念在研究树结构和算法中非常重要，特别是在数据结构和计算机科学中。
### 树与树相关术语定义（续）

#### Descendant of a Vertex \( v \) in a Rooted Tree（根树中顶点 \( v \) 的后代）
- **定义**：任何以 \( v \) 为祖先的顶点。
- **示例**：在路径 A->B->C 中，C 是 A 的后代。

#### Internal Vertex（内部顶点）
- **定义**：有子节点的顶点。
- **示例**：在树结构中，节点 B 是内部顶点，如果 B 有子节点。

#### Leaf（叶节点）
- **定义**：没有子节点的顶点。
- **示例**：在树结构中，没有子节点的顶点 D 是叶节点。

#### Level of a Vertex（顶点的层次）
- **定义**：从根到该顶点的路径长度。
- **示例**：根节点的层次为 0，它的子节点的层次为 1。

#### Height of a Tree（树的高度）
- **定义**：树中顶点的最大层次。
- **示例**：如果树的最大层次为 3，那么树的高度为 3。

#### m-ary Tree（m 叉树）
- **定义**：每个内部顶点的子节点数不超过 m 的树。
- **示例**：一个 3 叉树中，每个内部顶点最多有 3 个子节点。

#### Full m-ary Tree（满 m 叉树）
- **定义**：每个内部顶点恰好有 m 个子节点的树。
- **示例**：一个满 2 叉树（即完全二叉树）中，每个内部顶点都有 2 个子节点。

#### Binary Tree（二叉树）
- **定义**：m 叉树，其中 m = 2，每个子节点可以指定为父节点的左子节点或右子节点。
- **示例**：一个包含左子节点和右子节点的树。

#### Ordered Tree（有序树）
- **定义**：每个内部顶点的子节点线性排序的树。
- **示例**：子节点按照从左到右的顺序排列的树。

#### Balanced Tree（平衡树）
- **定义**：每个叶子节点在高度为 \( h \) 或 \( h - 1 \) 的树，其中 \( h \) 是树的高度。
- **示例**：所有叶子节点几乎在同一层次上的树。

#### Binary Search Tree（二叉搜索树）
- **定义**：二叉树，顶点上的标签使得顶点的标签大于其左子树所有顶点的标签，小于其右子树所有顶点的标签。
- **示例**：一个二叉搜索树，节点按特定顺序排列，以便快速搜索。

#### Decision Tree（决策树）
- **定义**：根树，其中每个顶点表示决策的可能结果，叶子表示问题的可能解决方案。
- **示例**：用于分类和回归的树结构。

#### Game Tree（博弈树）
- **定义**：根树，其中顶点表示游戏进展中的可能位置，边表示这些位置之间的合法移动。
- **示例**：用于描述象棋或围棋等游戏的可能走法。

#### Prefix Code（前缀码）
- **定义**：具有以下性质的编码：一个字符的编码永远不是另一个字符编码的前缀。
- **示例**：哈夫曼编码是一种前缀码。

#### Minmax Strategy（极大极小策略）
- **定义**：第一玩家和第二玩家分别移动到具有最大值和最小值的子节点位置的策略。
- **示例**：用于博弈论中的决策策略。

#### Value of a Vertex in a Game Tree（博弈树中顶点的值）
- **定义**：对于叶节点，游戏在此位置终止时第一玩家的收益；对于内部顶点，分别为偶数层或奇数层时其子节点值的最大值或最小值。
- **示例**：叶节点值为终止时的得分，内部节点值为其子节点值的最大或最小值。

#### Tree Traversal（树的遍历）
- **定义**：树顶点的列表示。

#### Preorder Traversal（前序遍历）
- **定义**：有序根树的顶点列表示，递归定义为先列出根节点，然后依次列出从左到右的子树。
- **示例**：对于树结构 A, B, C，前序遍历为 A, B, C。

#### Inorder Traversal（中序遍历）
- **定义**：有序根树的顶点列表示，递归定义为先列出第一个子树，然后列出根节点，最后依次列出其他子树。
- **示例**：对于树结构 B, A, C，中序遍历为 B, A, C。

### 树与图论术语定义（续）

#### Postorder Traversal（后序遍历）
- **定义**：有序根树顶点的列表示，递归定义为按从左到右的顺序列出子树，然后列出根。
- **示例**：对于树结构 A, B, C，后序遍历为 B, C, A。

#### Infix Notation（中缀表示法）
- **定义**：通过对表示表达式的二叉树进行中序遍历得到的表达式形式（包括一整套括号）。
- **示例**：表达式 (A + (B * C)) 的中缀表示法。

#### Prefix (or Polish) Notation（前缀表示法或波兰表示法）
- **定义**：通过对表示表达式的树进行前序遍历得到的表达式形式。
- **示例**：表达式 (+ A (* B C)) 的前缀表示法。

#### Postfix (or Reverse Polish) Notation（后缀表示法或逆波兰表示法）
- **定义**：通过对表示表达式的树进行后序遍历得到的表达式形式。
- **示例**：表达式 (A B C * +) 的后缀表示法。

#### Spanning Tree（生成树）
- **定义**：包含图中所有顶点的树。
- **示例**：从图中选取部分边使其连通且不形成回路。

#### Minimum Spanning Tree（最小生成树）
- **定义**：边权和最小的生成树。
- **示例**：在加权图中选取边权和最小的生成树。

### 重要结果与定理

#### A Graph is a Tree if and only if there is a Unique Simple Path between Every Pair of Its Vertices（图是树当且仅当任意两顶点间有唯一的简单路径）
- **定理**：图是树，当且仅当任意两顶点间有且仅有一条简单路径。
- **解释**：树结构的特征之一。

#### A Tree with \( n \) Vertices has \( n - 1 \) Edges（n 个顶点的树有 n - 1 条边）
- **定理**：一棵包含 \( n \) 个顶点的树有 \( n - 1 \) 条边。
- **解释**：树的基本性质。

#### A Full m-ary Tree with \( i \) Internal Vertices has \( mi + 1 \) Vertices（包含 \( i \) 个内部顶点的满 m 叉树有 \( mi + 1 \) 个顶点）
- **定理**：满 m 叉树中，内部顶点数为 \( i \) 时，总顶点数为 \( mi + 1 \)。
- **解释**：满 m 叉树的顶点数关系。

#### The Relationships among the Numbers of Vertices, Leaves, and Internal Vertices in a Full m-ary Tree（满 m 叉树中顶点数、叶节点数和内部顶点数之间的关系）
- **定理**：见第 11.1 节中的定理 4。
- **解释**：满 m 叉树中顶点、叶节点和内部顶点之间的关系。

#### There are at Most \( mh \) Leaves in an m-ary Tree of Height \( h \)（高度为 \( h \) 的 m 叉树中最多有 \( mh \) 个叶节点）
- **定理**：高度为 \( h \) 的 m 叉树中最多有 \( mh \) 个叶节点。
- **解释**：m 叉树的叶节点数上限。

#### If an m-ary Tree has \( l \) Leaves, its Height \( h \) is at least \( \lceil \log_m l \rceil \)（如果 m 叉树有 \( l \) 个叶节点，则其高度至少为 \( \lceil \log_m l \rceil \））
- **定理**：如果 m 叉树有 \( l \) 个叶节点，则其高度 \( h \) 至少为 \( \lceil \log_m l \rceil \)。如果树也是满的且平衡的，那么其高度为 \( \lceil \log_m l \rceil \)。
- **解释**：m 叉树的高度与叶节点数之间的关系。

#### Huffman Coding（哈夫曼编码）
- **定义**：根据符号的频率构造最优二进制编码的过程。
- **解释**：用于数据压缩的编码算法。

#### Depth-First Search, or Backtracking（深度优先搜索或回溯）
- **定义**：通过添加形成路径的边构造生成树，直到无法继续，然后沿路径回溯，直到找到新的路径。
- **解释**：用于生成树的算法。

#### Breadth-First Search（广度优先搜索）
- **定义**：逐步添加与最后添加的边相邻的所有边，除非形成简单回路。
- **解释**：用于生成树的算法。

#### Prim’s Algorithm（普里姆算法）
- **定义**：在加权图中生成最小生成树的过程，逐步添加与已在树中的顶点相邻且权值最小的边，确保不形成简单回路。
- **解释**：用于生成最小生成树的贪心算法。

#### Kruskal’s Algorithm（克鲁斯卡尔算法）
- **定义**：在加权图中生成最小生成树的过程，逐步添加权值最小且不在树中的边，确保不形成简单回路。
- **解释**：用于生成最小生成树的贪心算法。

### 计算理论与形式语言相关术语定义

#### Alphabet (or Vocabulary)（字母表或词汇表）
- **定义**：包含用于形成字符串的元素的集合。
- **示例**：二进制字母表 {0, 1}。

#### Language（语言）
- **定义**：字母表上所有字符串的一个子集。
- **示例**：二进制字母表上所有长度为偶数的字符串。

#### Phrase-Structure Grammar (V, T, S, P)（短语结构语法）
- **定义**：描述语言的四元组，包括字母表 V、终结符集合 T、开始符号 S 和产生式集合 P。
- **示例**：语法 G = ({S, A, B}, {a, b}, S, {S → aSb, S → ab})。

#### The Production \( w \rightarrow w1 \)（产生式 \( w \rightarrow w1 \)）
- **定义**：当 \( w \) 出现在语言的字符串中时，可以用 \( w1 \) 替换 \( w \)。
- **示例**：产生式 S → aSb 表示 S 可以替换为 aSb。

#### \( w1 \Rightarrow w2 \)（\( w2 \) 可直接由 \( w1 \) 派生）
- **定义**：使用产生式将 \( w1 \) 中的一个字符串替换为另一个字符串，可以得到 \( w2 \)。
- **示例**：S → aSb，应用产生式 S → ab，得到 ab。

#### \( w1 \ast \Rightarrow w2 \)（\( w2 \) 可由 \( w1 \) 派生）
- **定义**：使用一系列产生式将字符串替换为其他字符串，可以得到 \( w2 \)。
- **示例**：S ⇒ aSb ⇒ ab。

#### Type 0 Grammar（类型 0 语法）
- **定义**：任意短语结构语法。
- **示例**：无限制的产生式集合。

#### Type 1 Grammar（类型 1 语法）
- **定义**：每个产生式形式为 \( w1 \rightarrow w2 \)，其中 \( w1 = lAr \)，\( w2 = lwr \)，其中 \( A \in N \)，\( l, r, w \in (N \cup T)^\ast \) 且 \( w \neq \lambda \)，或 \( w1 = S \) 且 \( w2 = \lambda \)，只要 S 不在其他产生式的右侧。
- **示例**：上下文相关语法。

#### Type 2, or Context-Free, Grammar（类型 2 或上下文无关语法）
- **定义**：每个产生式形式为 \( A \rightarrow w1 \)，其中 A 是非终结符。
- **示例**：上下文无关语法。

#### Type 3, or Regular, Grammar（类型 3 或正则语法）
- **定义**：每个产生式形式为 \( A \rightarrow aB \)，\( A \rightarrow a \) 或 \( S \rightarrow \lambda \)，其中 A 和 B 是非终结符，S 是开始符号，a 是终结符。
- **示例**：正则语法。

#### Derivation (or Parse) Tree（派生树或解析树）
- **定义**：有序根树，根表示类型 2 语法的起始符号，内部顶点表示非终结符，叶子表示终结符，顶点的子节点从左到右依次表示产生式右侧的符号，父节点表示产生式左侧的符号。
- **示例**：解析树用于表示上下文无关语法的派生过程。

#### Backus–Naur Form（巴科斯-瑙尔范式）
- **定义**：描述上下文无关语法的一种形式，其中所有产生式具有相同的非终结符。

### 计算理论与形式语言相关术语定义（续）

#### Backus–Naur Form（巴科斯-瑙尔范式）
- **定义**：描述上下文无关语法的一种形式，其中所有产生式具有相同的非终结符在左侧，右侧的不同部分由竖线分隔，非终结符用尖括号括起来，符号“→”替换为“::=”。

#### Finite-State Machine (S, I, O, f, g, s0) (or a Mealy Machine)（有限状态机或米利机）
- **定义**：一个包含六元组 (S, I, O, f, g, s0) 的描述，S 是状态集合，I 是输入字母表，O 是输出字母表，f 是分配每对状态和输入到下一个状态的转移函数，g 是分配每对状态和输入到输出的输出函数，s0 是初始状态。
- **示例**：用于描述简单的自动机或控制系统。

#### \( AB \) (Concatenation of A and B)（A 和 B 的连接）
- **定义**：通过按顺序连接 A 中的字符串和 B 中的字符串形成的所有字符串的集合。
- **示例**：如果 A = \{a, b\}，B = \{c, d\}，则 \( AB = \{ac, ad, bc, bd\} \)。

#### \( A^* \) (Kleene Closure of A)（A 的 Kleene 闭包）
- **定义**：通过任意次连接 A 中的字符串形成的所有字符串的集合。
- **示例**：如果 A = \{a\}，则 \( A^* = \{\lambda, a, aa, aaa, \ldots\} \)。

#### Deterministic Finite-State Automaton (S, I, f, s0, F)（确定性有限状态自动机）
- **定义**：一个包含五元组 (S, I, f, s0, F) 的描述，S 是状态集合，I 是输入字母表，f 是分配每对状态和输入到下一个状态的转移函数，s0 是初始状态，F 是终态集合。
- **示例**：用于确定性自动机的描述。

#### Nondeterministic Finite-State Automaton (S, I, f, s0, F)（非确定性有限状态自动机）
- **定义**：一个包含五元组 (S, I, f, s0, F) 的描述，S 是状态集合，I 是输入字母表，f 是分配每对状态和输入到一组可能的下一个状态的转移函数，s0 是初始状态，F 是终态集合。
- **示例**：用于非确定性自动机的描述。

#### Language Recognized by an Automaton（自动机识别的语言）
- **定义**：使初始状态到达终态的输入字符串集合。
- **示例**：自动机识别的所有有效输入串。

#### Regular Expression（正则表达式）
- **定义**：通过递归定义的表达式，指定 ∅、λ 和输入字母表中的所有 x 是正则表达式，当 A 和 B 是正则表达式时，(AB)、(A ∪ B) 和 \( A^* \) 也是正则表达式。
- **示例**：用于描述模式匹配的表达式。

#### Regular Set（正则集）
- **定义**：由正则表达式定义的集合。
- **示例**：与正则表达式对应的所有字符串集合。

#### Turing Machine \( T = (S, I, f, s0) \)（图灵机）
- **定义**：一个包含四元组 (S, I, f, s0) 的描述，S 是状态集合，I 是包含空白符 B 的字母表，f 是从 S × I 到 S × I × \{R, L\} 的部分函数，s0 是初始状态。
- **示例**：用于计算理论的图灵机模型。

#### Nondeterministic Turing Machine（非确定性图灵机）
- **定义**：一种图灵机，对于每个 (状态, 带符号) 对应关系，可能有多个转移规则。
- **示例**：非确定性计算模型。

这些术语在计算理论和形式语言中起着重要作用，帮助理解自动机、语法和图灵机的基本概念和特性。

### 计算理论与复杂性相关术语定义

#### Decision Problem（判定问题）
- **定义**：询问某一类陈述是否为真的问题。
- **示例**：判定一个数是否为素数。

#### Solvable Problem（可解问题）
- **定义**：存在一种有效算法可以解决该问题的所有实例。
- **示例**：排序问题可以通过多种排序算法解决。

#### Unsolvable Problem（不可解问题）
- **定义**：不存在有效算法可以解决该问题的所有实例。
- **示例**：停机问题是不可解问题。

#### Computable Function（可计算函数）
- **定义**：可以使用图灵机计算其值的函数。
- **示例**：加法函数是可计算函数。

#### Uncomputable Function（不可计算函数）
- **定义**：不能使用图灵机计算其值的函数。
- **示例**：一些特殊的数论函数是不可计算的。

#### P, the Class of Polynomial-Time Problems（P 类多项式时间问题）
- **定义**：可以由确定性图灵机在多项式时间内解决的问题类。
- **示例**：寻找无向图中最短路径的问题属于 P 类。

#### NP, the Class of Nondeterministic Polynomial-Time Problems（NP 类非确定性多项式时间问题）
- **定义**：可以由非确定性图灵机在多项式时间内解决的问题类。
- **示例**：旅行商问题属于 NP 类。

#### NP-Complete（NP 完全）
- **定义**：NP 类中的一个子集，具有这样的性质：如果它们中的任意一个问题属于 P 类，则 NP 类中的所有问题都属于 P 类。
- **示例**：布尔可满足性问题（SAT）是 NP 完全问题。

### 重要结果与定理

#### 对于每个非确定性有限状态自动机，存在一个确定性有限状态自动机识别相同的集合。
- **解释**：这意味着非确定性自动机和确定性自动机在识别能力上是等价的。

#### Kleene’s Theorem（克莱尼定理）
- **定理**：一个集合是正则的当且仅当存在一个有限状态自动机识别它。
- **解释**：正则集可以由有限状态自动机识别，反之亦然。

#### A Set is Regular if and only if it is Generated by a Regular Grammar（一个集合是正则的当且仅当它由正则文法生成）
- **解释**：正则集可以由正则文法生成，反之亦然。

#### The Halting Problem is Unsolvable（停机问题不可解）
- **解释**：停机问题是一个著名的不可解问题，表明不存在一种算法可以判定任意给定的程序和输入是否会停机。

这些术语和结果在计算理论和复杂性理论中起着关键作用，帮助理解可计算性和问题的复杂性分类。

