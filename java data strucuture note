https://people.cs.vt.edu/~shaffer/Book/JAVA3elatest.pdf

bodying the mathematical concepts of a sequence, as defined in Section 2.1. We define a list to be a finite, ordered sequence of data items known as elements. “Ordered” in this definition means that each element has a position in the list. (We will not use “ordered” in this context to mean that the list elements are sorted by value.) Each list element has a data type. In the simple list implementations discussed in this chapter, all elements of the list have the same data type, although there is no conceptual objection to lists whose elements have differing data types if the application requires it (see Section 12.1). The operations defined as part of the list ADT do not depend on the elemental data type. For example, the list ADT can be used for lists of integers, lists of characters, lists of payroll records, even lists of lists. A list is said to be empty when it contains no elements. The number of elements currently stored is called the length of the list. The beginning of the list is called the head, the end of the list is called the tail. There might or might not be some relationship between the value of an element and its position in the list. For example, sorted lists have their elements positioned in ascending order of value, while unsorted lists have no particular relationship between element values and positions. This section will consider only unsorted lists. Chapters 7 and 9 treat the problems of how to create and search sorted lists efficiently.

Figure 4.1 presents our list ADT. Class List is a generic of one parameter, named E for “element”. E serves as a placeholder for whatever element type the user would like to store in a list. The comments given in Figure 4.1 describe precisely what each member function is intended to do. However, some explanation of the basic design is in order. Given that we wish to support the concept of a sequence, with access to any position in the list, the need for many of the member functions such as insert and moveToPos is clear. The key design decision embodied in this ADT is support for the concept of a current position. For example, member moveToStart sets the current position to be the first element on the list, while methods next and prev move the current position to the next and previous elements, respectively. The intention is that any implementation for this ADT support the concept of a current position. The current position is where any action such as insertion or deletion will take place.

/** List ADT */ public interface List { /** Remove all contents from the list, so it is once again empty. Client is responsible for reclaiming storage used by the list elements. */ public void clear(); /** Insert an element at the current location. The client must ensure that the list’s capacity is not exceeded. @param item The element to be inserted. */ public void insert(E item); /** Append an element at the end of the list. The client must ensure that the list’s capacity is not exceeded. @param item The element to be appended. */ public void append(E item); /** Remove and return the current element. @return The element that was removed. */ public E remove(); /** Set the current position to the start of the list */ public void moveToStart(); /** Set the current position to the end of the list */ public void moveToEnd(); /** Move the current position one step left. No change if already at beginning. */ public void prev(); /** Move the current position one step right. No change if already at end. */ public void next(); /** @return The number of elements in the list. */ public int length(); /** @return The position of the current element. */ public int currPos(); /** Set current position. @param pos The position to make current. */ public void moveToPos(int pos); /** @return The current element. */ public E getValue(); } Figure 4.1 The ADT for a list. Sec. 4.1 Lists 97 for (L.moveToStart(); L.currPos()<L.length(); L.next()) { it = L.getValue(); doSomething(it); } In

Figure 4.4 shows the implementation for list nodes, called the Link class. Objects in the Link class contain an element field to store the element value, and a next field to store a pointer to the next node on the list. The list built from such nodes is called a singly linked list, or a one-way list, because each list node has a single pointer to the next node on the list. The Link class is quite simple. There are two forms for its constructor, one with an initial element value and one without. Member functions allow the link user to get or set the element and link fields. Figure 4.5(a) shows a graphical depiction for a linked list storing four integers. The value stored in a pointer variable is indicated by an arrow “pointing” to something. Java uses the special symbol null for a pointer value that points nowhere, such as for the last list node’s next field. A null pointer is indicated graphically by a diagonal slash through a pointer variable’s box. The vertical line between the nodes labeled 23 and 12 in Figure 4.5(a) indicates the current position (immediately to the right of this line). The list’s first node is accessed from a pointer named head. To speed access to the end of the list, and to allow the append method to be performed in constant time, a pointer named tail is also kept to the last link of the list. The position of the current element is indicated by another pointer, named curr. Finally, because there is no simple way to compute the length of the list simply from these three pointers, the list length must be stored explicitly, and updated by every operation that modifies the list size. The value cnt stores the length of the list. Note that LList’s constructor maintains the optional parameter for minimum list size introduced for Class AList. This is done simply to keep the calls to the
Like our singly linked list implementation, the doubly linked list implementation makes use of a header node. We also add a tailer node to the end of the list. The tailer is similar to the header, in that it is a node that contains no value, and it always exists. When the doubly linked list is initialized, the header and tailer nodes are created. Data member head points to the header node, and tail points to the tailer node. The purpose of these nodes is to simplify the insert, append, and remove methods by eliminating all need for special-case code when the list is empty, or when we insert at the head or tail of the list. For singly linked lists we set curr to point to the node preceding the node that contained the actual current element, due to lack of access to the previous node during insertion and deletion. Since we do have access to the previous node in a doubly linked list, this is no longer necessary. We could set curr to point directly to the node containing the current element. However, I have chosen to keep the same convention for the curr pointer as we set up for singly linked lists, purely for the sake of consistency. Figure 4.14 shows the complete implementation for a Link class to be used with doubly linked lists. This code is a little longer than that for the singly linked list node implementation since the doubly linked list nodes have an extra data member. Figure 4.15 shows the implementation for the insert, append, remove, and prev doubly linked list methods. The class declaration and the remaining member functions for the doubly linked list class are nearly identical to the singly linked list version. The insert method is especially simple for our doubly linked list implementation, because most of the work is done by the node’s constructor. Figure 4.16 shows the list before and after insertion of a node with value 10. The three parameters to the new operator allow the list node class constructor to set the element, prev, and next fields, respectively, for the new link node. The new operator returns a pointer to the newly created node. The nodes to either side have their pointers updated to point to the newly created node. The existence

4.2 Stacks The stack is a list-like structure in which elements may be inserted or removed from only one end. While this restriction makes stacks less flexible than lists, it also makes stacks both efficient (for those operations they can do) and easy to implement. Many applications require only the limited form of insert and remove operations that stacks provide. In such cases, it is more efficient to use the simpler stack data structure rather than the generic list. For example, the freelist of Section 4.1.2 is really a stack. Despite their restrictions, stacks have many uses. Thus, a special vocabulary for stacks has developed. Accountants used stacks long before the invention of the computer. They called the stack a “LIFO” list, which stands for “Last-In, FirstOut.” Note that one implication of the LIFO policy is that stacks remove elements in reverse order of their arrival. The accessible element of the stack is called the top element. Elements are not said to be inserted, they are pushed onto the stack. When removed, an element is said to be popped from the stack. Figure 4.18 shows a sample stack ADT. As with lists, there are many variations on stack implementation. The two approaches presented here are array-based and linked stacks, which are analogous to array-based and linked lists, respectively. 4.2.1 Array-Based Stacks Figure 4.19 shows a complete implementation for the array-based stack class. As with the array-based list implementation, listArray must be declared of fixed size when the stack is created. In the stack constructor, size serves to indicate this size. Method top acts somewhat like a current position value (because the “current” position is always at the top of the stack), as well as indicating the number of elements currently in the stack.

A binary tree is made up of a finite set of elements called nodes. This set either is empty or consists of a node called the root together with two binary trees, called the left and right subtrees, which are disjoint from each other and from the root. (Disjoint means that they have no nodes in common.) The roots of these subtrees are children of the root. There is an edge from a node to each of its children, and a node is said to be the parent of its children. If n1, n2, ..., nk is a sequence of nodes in the tree such that ni is the parent of ni+1 for 1 ≤ i < k, then this sequence is called a path from n1 to nk. The length of the path is k − 1. If there is a path from node R to node M, then R is an ancestor of M, and M is a descendant of R. Thus, all nodes in the tree are descendants of the
