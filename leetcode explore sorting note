https://leetcode.com/explore/learn/card/sorting/696/summary-and-conclusion/4440/

An ordering relation has two key properties: 1. Given two elements a and b, exactly one of the following must be true: 𝑎<𝑏a<b, 𝑎=𝑏a=b, or 𝑎>𝑏a>b ( Law of Trichotomy ) 2. If 𝑎<𝑏a<b and 𝑏<𝑐b<c, then 𝑎<𝑐a<c ( Law of Transitivity )
A sort is formally defined as a rearrangement of a sequence of elements that puts all elements into a non-decreasing order based on the ordering relation.
Suppose you were given a list of strings [“hello”, “world”, “we”, “are”, “learning, “sorting”][“hello”, “world”, “we”, “are”, “learning, “sorting”]. One way to define an ordering relation might be based on the length of the string. One valid sort based on this ordering relation is [“we”, “are”, “hello”, “world”, “sorting”, “learning”][“we”, “are”, “hello”, “world”, “sorting”, “learning”]. For every pair of adjacent elements in the list, the length of the preceding string is always less than or equal to the length of the following string. Another ordering relation we could define is the number of vowels in the string. That would lead to the following sort: [“we”, “world”, “are”, “hello”, “sorting”, “learning”][“we”, “world”, “are”, “hello”, “sorting”, “learning”].
class Solution:
    def sort_by_length(self, lst: List[str]) -> None:
        """
        Sorts a list of strings by the length of each string
        """        
        lst.sort(key=lambda x: len(x)) # Note we can also do lst.sort(key=len)

An important concept in sorting is inversions. An inversion in a sequence is defined as a pair of elements that are out of order with respect to the ordering relation. To understand this idea better, let's consider our earlier string example, where the ordering relation was defined by the length of the string:
[“are”, “we”, “sorting”, “hello”, “world”, “learning”][“are”, “we”, “sorting”, “hello”, “world”, “learning”]
Clearly, the above list is not sorted according to the lengths of strings, but what if you had to define a metric for how “out of sort” it was? Inversions provide a way to define that. In the above unsorted list, we have the following inversions:
(“are”, “we”)(“are”, “we”), (“sorting”, “hello”)(“sorting”, “hello”), and (“sorting”, “world”)(“sorting”, “world”)
The more inversions present, the more out of order the list is. In fact, the concept of inversions introduces an alternative definition of sorting: Given a sequence of elements with n inversions, a sorting algorithm is a sequence of operations that reduces inversions to 0.
The next important concept in sorting that we will refer back to is the stability of sorting algorithms. The key feature of a stable sorting algorithm is that it will preserve the order of equal elements. In our earlier string example with the string length ordering comparison, our original sequence was [“hello”, “world”, “we”, “are”, “learning, “sorting”][“hello”, “world”, “we”, “are”, “learning, “sorting”]
There are two valid sorts for this sequence:
1.[“we”, “are”, “hello”, “world”, “sorting”, “learning”][“we”, “are”, “hello”, “world”, “sorting”, “learning”]
2.[“we”, “are”, “world”, “hello”, “sorting”, “learning”][“we”, “are”, “world”, “hello”, “sorting”, “learning”]
We consider (1) to be a stable sort since the equal elements “hello” and “world” are kept in the same relative order as the original sequence.
In terms of simplicity, it is a highly intuitive algorithm and not too difficult to write. Unfortunately, it is pretty slow, requiring 𝑂(𝑛2)O(n2) time to sort the list in the worst case. In the worst case, we have to search the entire array to find the minimum element, meaning we can have up to 𝑛+(𝑛−1)+(𝑛−2)+…+1n+(n−1)+(n−2)+…+1 total operations, which is 𝑂(𝑛2)O(n2). The space complexity of selection sort is 𝑂(1)O(1) since we do not use any additional space during the algorithm (all operations are in-place).
It also is not a stable sorting algorithm. For example consider the collection [4, 2, 3, 4, 1]. After the first round of selection sort, we get the array [1, 2, 3, 4, 4]. This array is sorted, but it does not preserve the ordering of equal elements.
class Solution:
    def selection_sort(self, lst: List[int]) -> None:
        """
        Mutates lst so that it is sorted via selecting the minimum element and
        swapping it with the corresponding index
        """
        for i in range(len(lst)):
            min_index = i
            for j in range(i + 1, len(lst)):
                # Update minimum index
                if lst[j] < lst[min_index]:
                    min_index = j

            # Swap current index with minimum element in rest of list
            lst[min_index], lst[i] = lst[i], lst[min_index]

### Selection Sort

**Selection Sort** is a simple comparison-based sorting algorithm. Despite its simplicity and ease of implementation, it is not suitable for large datasets due to its quadratic time complexity. However, it is useful for educational purposes and small datasets.

#### How It Works

The selection sort algorithm divides the input list into two parts: the sorted part at the beginning and the unsorted part at the end. Initially, the sorted part is empty, and the unsorted part contains all the elements.

**Steps**:
1. **Find the Minimum**: Search the entire list to find the smallest element.
2. **Swap**: Swap the smallest element found with the first element of the unsorted part.
3. **Move the Boundary**: Move the boundary between the sorted and unsorted parts one element to the right.
4. **Repeat**: Repeat the above steps for the remaining unsorted part of the list.

#### Pseudocode

```text
selectionSort(array, size)
  for step from 0 to size-1 do
    min_idx = step
    for i from step+1 to size do
      if array[i] < array[min_idx] then
        min_idx = i
    swap array[min_idx] and array[step]
end selectionSort
```

#### Example

Consider the array: `[64, 25, 12, 22, 11]`

1. **First Iteration**:
   - Find the minimum: 11
   - Swap 11 with 64
   - Result: `[11, 25, 12, 22, 64]`

2. **Second Iteration**:
   - Find the minimum: 12
   - Swap 12 with 25
   - Result: `[11, 12, 25, 22, 64]`

3. **Third Iteration**:
   - Find the minimum: 22
   - Swap 22 with 25
   - Result: `[11, 12, 22, 25, 64]`

4. **Fourth Iteration**:
   - No swaps needed as the remaining elements are in order.
   - Result: `[11, 12, 22, 25, 64]`

#### Time Complexity

- **Best Case**: \(O(n^2)\)
- **Average Case**: \(O(n^2)\)
- **Worst Case**: \(O(n^2)\)

#### Space Complexity

- **Auxiliary Space**: \(O(1)\) (In-place sorting)

#### Characteristics

- **Stable**: No (It does not preserve the relative order of equal elements)
- **In-Place**: Yes (It does not require extra space for sorting)

#### Use Cases

- Suitable for small datasets.
- Useful for scenarios where memory usage is critical due to its \(O(1)\) space complexity.
- Often used as an educational tool to teach sorting algorithm basics.

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Selection Sort](https://www.geeksforgeeks.org/selection-sort/)
- [Khan Academy - Selection Sort](https://www.khanacademy.org/computing/computer-science/algorithms/selection-sort/a/selection-sort)

To sort an array containing 0s, 1s, and 2s in-place, we can use the Dutch National Flag algorithm proposed by Edsger W. Dijkstra. This algorithm ensures that the array is sorted in linear time, \(O(n)\), and uses constant space, \(O(1)\). 

Here's how you can implement it in Python:

### Dutch National Flag Algorithm

1. **Initialize pointers**: 
   - `low` pointer starting at the beginning of the array.
   - `mid` pointer also starting at the beginning.
   - `high` pointer starting at the end of the array.

2. **Process elements**:
   - If the element at `mid` is `0`, swap it with the element at `low`, and move both pointers `low` and `mid` to the right.
   - If the element at `mid` is `1`, just move the `mid` pointer to the right.
   - If the element at `mid` is `2`, swap it with the element at `high`, and move the `high` pointer to the left.

3. **Stop when `mid` exceeds `high`**: The array will be sorted in-place with all `0`s at the beginning, followed by all `1`s, and all `2`s at the end.

### Implementation in Python

```python
def sortColors(nums):
    low, mid, high = 0, 0, len(nums) - 1
    
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[high], nums[mid] = nums[mid], nums[high]
            high -= 1

# Example usage:
nums = [2, 0, 2, 1, 1, 0]
sortColors(nums)
print(nums)  # Output: [0, 0, 1, 1, 2, 2]
```

### Explanation

1. **Initialization**:
   - `low` is set to `0`, pointing to the beginning of the array.
   - `mid` is also set to `0`, acting as the current element under consideration.
   - `high` is set to the last index of the array.

2. **Processing**:
   - The loop runs until `mid` exceeds `high`.
   - If the current element (`nums[mid]`) is `0`, it is swapped with the element at the `low` pointer, and both `low` and `mid` are incremented.
   - If the current element is `1`, `mid` is incremented as `1` is already in the correct position.
   - If the current element is `2`, it is swapped with the element at the `high` pointer, and `high` is decremented.

3. **Termination**:
   - The loop stops when `mid` exceeds `high`, ensuring the array is sorted as required.

This approach is efficient and ensures that the problem is solved in a single pass through the array, making it both time and space efficient.

class Solution:
    def bubble_sort(self, lst: List[int]) -> None:
        """
        Mutates lst so that it is sorted via swapping adjacent elements until
        the entire lst is sorted.
        """
        has_swapped = True
        # if no swap occurred, lst is sorted
        while has_swapped:
            has_swapped = False
            for i in range(len(lst) - 1):
                if lst[i] > lst[i + 1]:
                    # Swap adjacent elements
                    lst[i], lst[i + 1] = lst[i + 1], lst[i]
                    has_swapped = True          

### Bubble Sort

**Bubble Sort** is a straightforward comparison-based sorting algorithm. It is named for the way smaller elements "bubble" to the top (beginning) of the list while larger elements sink to the bottom (end). Although it is simple to implement, it is not efficient for large datasets due to its quadratic time complexity.

#### How It Works

1. **Compare Adjacent Elements**: Starting from the beginning of the list, compare each pair of adjacent elements.
2. **Swap if Necessary**: If the elements are in the wrong order (i.e., the first element is greater than the second), swap them.
3. **Repeat**: Move to the next pair of adjacent elements and repeat the comparison and swap if necessary.
4. **Pass Through List**: After each pass through the list, the largest element will have "bubbled" to its correct position at the end of the list.
5. **Reduce Scope**: Repeat the process for the remaining elements, excluding the last sorted elements, until the entire list is sorted.

#### Pseudocode

```text
bubbleSort(array, size)
  for i from 0 to size-1 do
    for j from 0 to size-i-2 do
      if array[j] > array[j+1] then
        swap array[j] and array[j+1]
end bubbleSort
```

#### Example

Consider the array: `[64, 34, 25, 12, 22, 11, 90]`

1. **First Pass**:
   - Compare 64 and 34, swap → `[34, 64, 25, 12, 22, 11, 90]`
   - Compare 64 and 25, swap → `[34, 25, 64, 12, 22, 11, 90]`
   - Continue until the largest element 90 "bubbles" to the end.

2. **Subsequent Passes**:
   - Repeat the process for the remaining elements, each time excluding the last sorted elements.
   - The array gradually becomes sorted: `[11, 12, 22, 25, 34, 64, 90]`

#### Time Complexity

- **Best Case**: \(O(n)\) when the array is already sorted (optimized version with a flag).
- **Average Case**: \(O(n^2)\)
- **Worst Case**: \(O(n^2)\)

#### Space Complexity

- **Auxiliary Space**: \(O(1)\) (In-place sorting)

#### Characteristics

- **Stable**: Yes (It preserves the relative order of equal elements)
- **In-Place**: Yes (It does not require extra space for sorting)

### Implementation in Python

```python
def bubbleSort(arr):
    n = len(arr)
    for i in range(n):
        # Track if any swap is made in this pass
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # If no elements were swapped, the array is already sorted
        if not swapped:
            break

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
bubbleSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [11, 12, 22, 25, 34, 64, 90]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Bubble Sort](https://www.geeksforgeeks.org/bubble-sort/)
- [Khan Academy - Bubble Sort](https://www.khanacademy.org/computing/computer-science/algorithms/bubble-sort/a/bubble-sort)

class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # Function to perform bubble sort on the input array.
        def bubble_sort():
            n = len(sorted_heights)
            # Loop through the array for bubble sort passes.
            for i in range(n - 1):
                # Inner loop to compare and swap elements.
                for j in range(n - i - 1):
                    # Compare and swap if elements are in the wrong order.
                    if sorted_heights[j] > sorted_heights[j + 1]:
                        sorted_heights[j], sorted_heights[j + 1] = (
                            sorted_heights[j + 1],
                            sorted_heights[j],
                        )

        # Sort the array using bubble sort.
        sorted_heights = heights[:]
        bubble_sort()

        count = 0
        # Loop through the original and sorted arrays.
        for i in range(len(sorted_heights)):
            # Increment count if elements at the same index differ.
            if heights[i] != sorted_heights[i]:
                count += 1
        # Return the total count of differing elements.
        return count

class Solution:
    def insertion_sort(self, lst: List[int]) -> None:
        """
        Mutates elements in lst by inserting out of place elements into appropriate
        index repeatedly until lst is sorted
        """
        for i in range(1, len(lst)):
            current_index = i

            while current_index > 0 and lst[current_index - 1] > lst[current_index]:
                # Swap elements that are out of order
                lst[current_index], lst[current_index - 1] = lst[current_index - 1], lst[current_index]
                current_index -= 1

class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode()
        curr = head

        while curr:
            # At each iteration, we insert an element into the resulting list.
            prev = dummy

            # find the position to insert the current node
            while prev.next and prev.next.val <= curr.val:
                prev = prev.next

            next = curr.next
            # insert the current node to the new list
            curr.next = prev.next
            prev.next = curr

            # moving on to the next iteration
            curr = next

        return dummy.next

### Insertion Sort

**Insertion Sort** is a simple and intuitive comparison-based sorting algorithm. It builds the final sorted array one item at a time. It is much like sorting playing cards in your hands: you take one card at a time and place it in its correct position relative to the cards already in hand.

#### How It Works

1. **Start from the Second Element**: The first element is considered sorted. Begin with the second element and compare it to the elements before it.
2. **Compare and Shift**: If the current element is smaller than the previous elements, shift the previous elements one position to the right to make space.
3. **Insert**: Insert the current element into its correct position.
4. **Repeat**: Continue this process with the next element until the entire array is sorted.

#### Pseudocode

```text
insertionSort(array, size)
  for i from 1 to size-1 do
    key = array[i]
    j = i - 1
    while j >= 0 and array[j] > key do
      array[j + 1] = array[j]
      j = j - 1
    array[j + 1] = key
end insertionSort
```

#### Example

Consider the array: `[12, 11, 13, 5, 6]`

1. **First Iteration**:
   - Key = 11, Compare 11 with 12
   - Move 12 to the right
   - Insert 11 at position 0
   - Result: `[11, 12, 13, 5, 6]`

2. **Second Iteration**:
   - Key = 13, No changes needed
   - Result: `[11, 12, 13, 5, 6]`

3. **Third Iteration**:
   - Key = 5, Compare 5 with 13, 12, 11
   - Move 13, 12, and 11 to the right
   - Insert 5 at position 0
   - Result: `[5, 11, 12, 13, 6]`

4. **Fourth Iteration**:
   - Key = 6, Compare 6 with 13, 12, 11
   - Move 13, 12, and 11 to the right
   - Insert 6 at position 1
   - Result: `[5, 6, 11, 12, 13]`

#### Time Complexity

- **Best Case**: \(O(n)\) when the array is already sorted.
- **Average Case**: \(O(n^2)\)
- **Worst Case**: \(O(n^2)\)

#### Space Complexity

- **Auxiliary Space**: \(O(1)\) (In-place sorting)

#### Characteristics

- **Stable**: Yes (It preserves the relative order of equal elements)
- **In-Place**: Yes (It does not require extra space for sorting)

### Implementation in Python

```python
def insertionSort(arr):
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are greater than key, to one position ahead
        # of their current position
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example usage:
arr = [12, 11, 13, 5, 6]
insertionSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [5, 6, 11, 12, 13]
```

### Use Cases

- **Small Datasets**: Ideal for small arrays where the overhead of more complex algorithms is not justified.
- **Nearly Sorted Data**: Works well for data that is already mostly sorted, as it has a best-case linear time complexity.
- **Online Sorting**: Suitable for scenarios where elements are received one at a time and need to be sorted dynamically.

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Insertion Sort](https://www.geeksforgeeks.org/insertion-sort/)
- [Khan Academy - Insertion Sort](https://www.khanacademy.org/computing/computer-science/algorithms/insertion-sort/a/insertion-sort)

class Solution:
    def heap_sort(self, lst: List[int]) -> None:
        """
        Mutates elements in lst by utilizing the heap data structure
        """
        def max_heapify(heap_size, index):
            left, right = 2 * index + 1, 2 * index + 2
            largest = index
            if left < heap_size and lst[left] > lst[largest]:
                largest = left
            if right < heap_size and lst[right] > lst[largest]:
                largest = right
            if largest != index:
                lst[index], lst[largest] = lst[largest], lst[index]
                max_heapify(heap_size, largest)

        # heapify original lst
        for i in range(len(lst) // 2 - 1, -1, -1):
            max_heapify(len(lst), i)

        # use heap to sort elements
        for i in range(len(lst) - 1, 0, -1):
            # swap last element with first element
            lst[i], lst[0] = lst[0], lst[i]
            # note that we reduce the heap size by 1 every iteration
            max_heapify(i, 0)

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # Function to heapify a subtree (in top-down order) rooted at index i.
        def heapify(n: int, i: int):
            # Initialize largest as root 'i'.
            largest = i;
            left = 2 * i + 1
            right = 2 * i + 2
            # If left child is larger than root.
            if left < n and nums[left] > nums[largest]:
                largest = left
            # If right child is larger than largest so far.
            if right < n and nums[right] > nums[largest]:
                largest = right
            # If largest is not root swap root with largest element
            # Recursively heapify the affected sub-tree (i.e. move down).
            if largest != i:
                nums[i], nums[largest] =  nums[largest], nums[i]
                heapify(n, largest)

        def heap_sort():
            n = len(nums)
            # Build heap; heapify (top-down) all elements except leaf nodes.
            for i in range(n // 2 - 1, -1, -1):
                heapify(n, i)
            # Traverse elements one by one, to move current root to end, and
            for i in range(n - 1, -1, -1):
                nums[0], nums[i] = nums[i], nums[0]
                # call max heapify on the reduced heap.
                heapify(i, 0)

        heap_sort()
        return nums

### Heap Sort

**Heap Sort** is a comparison-based sorting algorithm that leverages a binary heap data structure. It is an in-place, non-recursive sorting technique that offers \(O(n \log n)\) time complexity. Heap sort can be thought of as an improved selection sort that uses the heap data structure to find the maximum element efficiently.

#### How It Works

Heap sort involves two main steps:
1. **Building a Heap**: Convert the input array into a binary heap.
2. **Sorting the Array**: Repeatedly remove the maximum element from the heap and rebuild the heap until all elements are sorted.

### Steps to Implement Heap Sort

1. **Build a Max Heap**:
   - Transform the array into a max heap, where each parent node is greater than or equal to its children.
   - This process is done using a heapify procedure, starting from the last non-leaf node and moving up to the root.

2. **Extract Elements from the Heap**:
   - Swap the root (maximum value) of the heap with the last element of the heap.
   - Reduce the size of the heap by one and heapify the root.
   - Repeat this process until the heap is empty.

#### Pseudocode

```text
heapSort(array, size)
  buildMaxHeap(array, size)
  for i from size-1 to 1 do
    swap array[0] with array[i]
    size = size - 1
    heapify(array, 0, size)
end heapSort

buildMaxHeap(array, size)
  for i from floor(size/2)-1 to 0 do
    heapify(array, i, size)
end buildMaxHeap

heapify(array, i, size)
  largest = i
  left = 2*i + 1
  right = 2*i + 2
  if left < size and array[left] > array[largest] then
    largest = left
  if right < size and array[right] > array[largest] then
    largest = right
  if largest != i then
    swap array[i] with array[largest]
    heapify(array, largest, size)
end heapify
```

#### Example

Consider the array: `[12, 11, 13, 5, 6, 7]`

1. **Build a Max Heap**:
   - Initial array: `[12, 11, 13, 5, 6, 7]`
   - Transform into a max heap: `[13, 11, 12, 5, 6, 7]`

2. **Extract Elements**:
   - Swap the first and last element: `[7, 11, 12, 5, 6, 13]`
   - Heapify the root: `[12, 11, 7, 5, 6, 13]`
   - Repeat until the array is sorted: `[5, 6, 7, 11, 12, 13]`

### Time Complexity

- **Best Case**: \(O(n \log n)\)
- **Average Case**: \(O(n \log n)\)
- **Worst Case**: \(O(n \log n)\)

### Space Complexity

- **Auxiliary Space**: \(O(1)\) (In-place sorting)

### Characteristics

- **Stable**: No (It does not preserve the relative order of equal elements)
- **In-Place**: Yes (It does not require extra space for sorting)

### Implementation in Python

```python
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1  # left = 2*i + 1
    r = 2 * i + 2  # right = 2*i + 2

    # See if left child of root exists and is greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)  # Heapify the root.

def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)

# Example usage
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [5, 6, 7, 11, 12, 13]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Heap Sort](https://www.geeksforgeeks.org/heap-sort/)
- [Khan Academy - Heap Sort](https://www.khanacademy.org/computing/computer-science/algorithms/heap-sort/a/heap-sort)

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_value = min(nums)
        max_value = max(nums)
        count = [0] * (max_value - min_value + 1)

        for num in nums:
            count[num - min_value] += 1
        
        remain = k
        for num in range(len(count) -1, -1, -1):
            remain -= count[num]
            if remain <= 0:
                return num + min_value

        return -1

class Solution:
    def counting_sort(self, lst) -> None:
        """
        Sorts a list of integers where minimum value is 0 and maximum value is K
        """
        K = max(lst)
        counts = [0] * (K + 1)
        for elem in lst:
            counts[elem] += 1

        # we now overwrite our original counts with the starting index
        # of each element in the final sorted array

        starting_index = 0
        for i, count in enumerate(counts):
            counts[i] = starting_index
            starting_index += count

        sorted_lst = [0] * len(lst)

        for elem in lst:
            sorted_lst[counts[elem]] = elem
            # since we have placed an item in index counts[elem], we need to
            # increment counts[elem] index by 1 so the next duplicate element
            # is placed in appropriate index
            counts[elem] += 1

        # common practice to copy over sorted list into original lst
        # it's fine to just return the sorted_lst at this point as well
        for i in range(len(lst)):
            lst[i] = sorted_lst[i]

### Counting Sort

**Counting Sort** is a non-comparison-based sorting algorithm that works well when the range of the input data (i.e., the difference between the maximum and minimum values) is not significantly greater than the number of elements. It is particularly useful for sorting integers.

#### How It Works

1. **Count the Occurrences**: Create a count array to store the count of each unique value in the input array.
2. **Calculate Cumulative Counts**: Transform the count array so that each element at each index contains the sum of the previous counts. This cumulative count helps to place elements directly into their correct position.
3. **Place the Elements**: Output the elements into the sorted array using the cumulative counts to determine the position of each element.

#### Steps

1. **Find the Range of the Input**:
   - Determine the minimum and maximum values in the input array to know the range of elements.

2. **Initialize the Count Array**:
   - Create a count array of size equal to the range of the input values, initialized to zero.

3. **Store the Counts**:
   - Iterate over the input array and increase the corresponding index in the count array for each element.

4. **Compute Cumulative Counts**:
   - Modify the count array by adding the previous count to the current count. This gives the position of each element in the sorted array.

5. **Build the Output Array**:
   - Iterate over the input array in reverse order, place each element at its correct position in the output array, and decrease the count by one.

#### Pseudocode

```text
countingSort(array, size)
  find the maximum value (max) and minimum value (min) in array
  range = max - min + 1
  initialize count array of size range with all zeros
  for i from 0 to size-1 do
    count[array[i] - min] += 1
  for i from 1 to range-1 do
    count[i] += count[i - 1]
  initialize output array of size size
  for i from size-1 to 0 do
    output[count[array[i] - min] - 1] = array[i]
    count[array[i] - min] -= 1
  copy output array to array
end countingSort
```

#### Example

Consider the array: `[4, 2, 2, 8, 3, 3, 1]`

1. **Find Range**:
   - Minimum value = 1
   - Maximum value = 8
   - Range = 8 - 1 + 1 = 8

2. **Count Occurrences**:
   - Count array: `[0, 1, 2, 2, 1, 0, 0, 1]` for values `[1, 2, 3, 4, 5, 6, 7, 8]`

3. **Cumulative Counts**:
   - Cumulative count array: `[0, 1, 3, 5, 6, 6, 6, 7]`

4. **Place Elements**:
   - Place elements in output array: `[1, 2, 2, 3, 3, 4, 8]`

### Time Complexity

- **Best Case**: \(O(n + k)\)
- **Average Case**: \(O(n + k)\)
- **Worst Case**: \(O(n + k)\)
  - \(n\) is the number of elements in the input array.
  - \(k\) is the range of the input values.

### Space Complexity

- **Auxiliary Space**: \(O(n + k)\)

### Characteristics

- **Stable**: Yes (preserves the relative order of equal elements)
- **In-Place**: No (requires additional storage for the count and output arrays)

### Implementation in Python

```python
def countingSort(arr):
    max_val = max(arr)
    min_val = min(arr)
    range_of_elements = max_val - min_val + 1

    # Create count array and initialize to 0
    count_arr = [0] * range_of_elements
    output_arr = [0] * len(arr)

    # Store the count of each element
    for num in arr:
        count_arr[num - min_val] += 1

    # Change count_arr to cumulative count array
    for i in range(1, len(count_arr)):
        count_arr[i] += count_arr[i - 1]

    # Build the output array
    for i in range(len(arr) - 1, -1, -1):
        output_arr[count_arr[arr[i] - min_val] - 1] = arr[i]
        count_arr[arr[i] - min_val] -= 1

    # Copy the sorted elements into the original array
    for i in range(len(arr)):
        arr[i] = output_arr[i]

# Example usage
arr = [4, 2, 2, 8, 3, 3, 1]
countingSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [1, 2, 2, 3, 3, 4, 8]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Counting Sort](https://www.geeksforgeeks.org/counting-sort/)
- [Khan Academy - Counting Sort](https://www.khanacademy.org/computing/computer-science/algorithms/counting-sort/a/counting-sort)

class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        # Initialize the auxiliary array `line`.
        # Keep a record of the minimum element and the maximum element.
        min_element = min(arr)
        max_element = max(arr)
        shift = -min_element
        line = [0] * (max_element - min_element + 1)
        answer = []
        
        # For each integer `num` in `arr`, we increment line[num + shift] by 1.
        for num in arr:
            line[num + shift] = 1
        
        # Start from the index representing the minimum integer, initialize the 
        # absolute difference `min_pair_diff` as a huge value such as
        # `max_element - min_element` in order not to miss the absolute 
        # difference of the first pair.
        min_pair_diff = max_element - min_element
        prev = 0
        
        # Iterate over the array `line` and check if line[curr] 
        # holds the occurrence of an input integer.
        for curr in range(1, max_element + shift + 1):
            # If line[curr] == 0, meaning there is no occurrence of the integer (curr - shift) 
            # held by this index, we will move on to the next index.
            if line[curr] == 0:
                continue
                
            # If the difference (curr - prev) equals `min_pair_diff`, we add this pair 
            # {prev - shift, curr - shift} to the answer list. 
            if curr - prev == min_pair_diff:
                answer.append([prev - shift, curr - shift])
            elif curr - prev < min_pair_diff:
                # If the difference (curr - prev) is smaller than `min_pair_diff`, 
                # we empty the answer list and add the pair {curr - shift, prev - shift} 
                # to the answer list and update the `min_pair_diff`
                answer = [[prev - shift, curr - shift]]
                min_pair_diff = curr - prev
            
            # Update prev as curr.     
            prev = curr
            
        return answer

### Counting Sort

**Counting Sort** is a non-comparison-based sorting algorithm that works well when the range of the input data (i.e., the difference between the maximum and minimum values) is not significantly greater than the number of elements. It is particularly useful for sorting integers.

#### How It Works

1. **Count the Occurrences**: Create a count array to store the count of each unique value in the input array.
2. **Calculate Cumulative Counts**: Transform the count array so that each element at each index contains the sum of the previous counts. This cumulative count helps to place elements directly into their correct position.
3. **Place the Elements**: Output the elements into the sorted array using the cumulative counts to determine the position of each element.

#### Steps

1. **Find the Range of the Input**:
   - Determine the minimum and maximum values in the input array to know the range of elements.

2. **Initialize the Count Array**:
   - Create a count array of size equal to the range of the input values, initialized to zero.

3. **Store the Counts**:
   - Iterate over the input array and increase the corresponding index in the count array for each element.

4. **Compute Cumulative Counts**:
   - Modify the count array by adding the previous count to the current count. This gives the position of each element in the sorted array.

5. **Build the Output Array**:
   - Iterate over the input array in reverse order, place each element at its correct position in the output array, and decrease the count by one.

#### Pseudocode

```text
countingSort(array, size)
  find the maximum value (max) and minimum value (min) in array
  range = max - min + 1
  initialize count array of size range with all zeros
  for i from 0 to size-1 do
    count[array[i] - min] += 1
  for i from 1 to range-1 do
    count[i] += count[i - 1]
  initialize output array of size size
  for i from size-1 to 0 do
    output[count[array[i] - min] - 1] = array[i]
    count[array[i] - min] -= 1
  copy output array to array
end countingSort
```

#### Example

Consider the array: `[4, 2, 2, 8, 3, 3, 1]`

1. **Find Range**:
   - Minimum value = 1
   - Maximum value = 8
   - Range = 8 - 1 + 1 = 8

2. **Count Occurrences**:
   - Count array: `[0, 1, 2, 2, 1, 0, 0, 1]` for values `[1, 2, 3, 4, 5, 6, 7, 8]`

3. **Cumulative Counts**:
   - Cumulative count array: `[0, 1, 3, 5, 6, 6, 6, 7]`

4. **Place Elements**:
   - Place elements in output array: `[1, 2, 2, 3, 3, 4, 8]`

### Time Complexity

- **Best Case**: \(O(n + k)\)
- **Average Case**: \(O(n + k)\)
- **Worst Case**: \(O(n + k)\)
  - \(n\) is the number of elements in the input array.
  - \(k\) is the range of the input values.

### Space Complexity

- **Auxiliary Space**: \(O(n + k)\)

### Characteristics

- **Stable**: Yes (preserves the relative order of equal elements)
- **In-Place**: No (requires additional storage for the count and output arrays)

### Implementation in Python

```python
def countingSort(arr):
    max_val = max(arr)
    min_val = min(arr)
    range_of_elements = max_val - min_val + 1

    # Create count array and initialize to 0
    count_arr = [0] * range_of_elements
    output_arr = [0] * len(arr)

    # Store the count of each element
    for num in arr:
        count_arr[num - min_val] += 1

    # Change count_arr to cumulative count array
    for i in range(1, len(count_arr)):
        count_arr[i] += count_arr[i - 1]

    # Build the output array
    for i in range(len(arr) - 1, -1, -1):
        output_arr[count_arr[arr[i] - min_val] - 1] = arr[i]
        count_arr[arr[i] - min_val] -= 1

    # Copy the sorted elements into the original array
    for i in range(len(arr)):
        arr[i] = output_arr[i]

# Example usage
arr = [4, 2, 2, 8, 3, 3, 1]
countingSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [1, 2, 2, 3, 3, 4, 8]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Counting Sort](https://www.geeksforgeeks.org/counting-sort/)
- [Khan Academy - Counting Sort](https://www.khanacademy.org/computing/computer-science/algorithms/counting-sort/a/counting-sort)

class Solution:
    def counting_sort(self, lst: List[int], place_val: int, K: int = 10) -> None:
        """
        Sorts a list of integers where minimum value is 0 and maximum value is K
        """
        # intitialize count array of size K
        counts = [0] * K

        for elem in lst:
            digit = (elem // place_val) % 10
            counts[digit] += 1

        # we now overwrite our original counts with the starting index
        # of each digit over our group of digits
        starting_index = 0
        for i, count in enumerate(counts):
            counts[i] = starting_index
            starting_index += count

        sorted_lst = [0] * len(lst)
        for elem in lst:
            digit = (elem // place_val) % 10
            sorted_lst[counts[digit]] = elem
            # since we have placed an item in index counts[digit],
            # we need to increment counts[digit] index by 1 so the
            # next duplicate digit is placed in appropriate index
            counts[digit] += 1

        # common practice to copy over sorted list into original lst
        # it's fine to just return the sorted_lst at this point as well
        for i in range(len(lst)):
            lst[i] = sorted_lst[i]

    def radix_sort(self, lst: List[int]) -> None:
        # shift the minimum value in lst to be 0
        shift = min(lst)
        lst[:] = [num - shift for num in lst]
        max_elem = max(lst)

        # apply the radix sort algorithm
        place_val = 1
        while place_val <= max_elem:
            self.counting_sort(lst, place_val)
            place_val *= 10

        # undo the original shift
        lst[:] = [num + shift for num in lst]

### Radix Sort

**Radix Sort** is a non-comparison-based sorting algorithm that sorts integers by processing individual digits. It processes each digit from the least significant to the most significant (LSD) or vice versa (MSD). Radix Sort is efficient for sorting numbers and can also be adapted for strings and other data types with a fixed length.

#### How It Works

Radix Sort works by distributing numbers into buckets based on each digit and then collecting them in a specific order. This process is repeated for each digit place.

### Steps

1. **Determine the Maximum Number of Digits**:
   - Identify the number with the most digits (or characters) in the dataset.

2. **Sort by Each Digit**:
   - Starting with the least significant digit (LSD) or the most significant digit (MSD), distribute the elements into buckets based on the current digit.
   - Collect the elements from the buckets in order.
   - Repeat the process for the next digit place until all digits are processed.

### LSD Radix Sort Pseudocode

```text
radixSort(array, d)
  for i from 1 to d do
    countSort(array, i)
end radixSort

countSort(array, digit)
  n = length(array)
  output = array of size n
  count = array of size 10 initialized to 0

  for j from 0 to n-1 do
    index = (array[j] / 10^(digit-1)) % 10
    count[index] += 1

  for j from 1 to 9 do
    count[j] += count[j - 1]

  for j from n-1 to 0 do
    index = (array[j] / 10^(digit-1)) % 10
    output[count[index] - 1] = array[j]
    count[index] -= 1

  for j from 0 to n-1 do
    array[j] = output[j]
end countSort
```

### Example

Consider the array: `[170, 45, 75, 90, 802, 24, 2, 66]`

1. **First Pass (Units Place)**:
   - Buckets: `0: [170, 90, 802], 2: [2], 4: [24], 5: [45, 75], 6: [66]`
   - Collect: `[170, 90, 802, 2, 24, 45, 75, 66]`

2. **Second Pass (Tens Place)**:
   - Buckets: `0: [802, 2], 2: [24], 4: [45], 5: [75], 6: [66], 7: [170], 9: [90]`
   - Collect: `[802, 2, 24, 45, 66, 75, 170, 90]`

3. **Third Pass (Hundreds Place)**:
   - Buckets: `0: [2, 24, 45, 66, 75, 90], 1: [170], 8: [802]`
   - Collect: `[2, 24, 45, 66, 75, 90, 170, 802]`

### Time Complexity

- **Best Case**: \(O(nk)\)
- **Average Case**: \(O(nk)\)
- **Worst Case**: \(O(nk)\)
  - \(n\) is the number of elements.
  - \(k\) is the number of digits in the largest number.

### Space Complexity

- **Auxiliary Space**: \(O(n + k)\)

### Characteristics

- **Stable**: Yes (preserves the relative order of equal elements)
- **In-Place**: No (requires additional storage for buckets)

### Implementation in Python

```python
def countingSort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # Store count of occurrences in count[]
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    # Change count[i] so that it contains the actual position of this digit in output[]
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    for i in range(n - 1, -1, -1):
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1

    # Copy the output array to arr[], so that arr now contains sorted numbers according to the current digit
    for i in range(n):
        arr[i] = output[i]

def radixSort(arr):
    max1 = max(arr)
    exp = 1
    while max1 // exp > 0:
        countingSort(arr, exp)
        exp *= 10

# Example usage
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radixSort(arr)
print("Sorted array is:", arr)  # Output: Sorted array is: [2, 24, 45, 66, 75, 90, 170, 802]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Radix Sort](https://www.geeksforgeeks.org/radix-sort/)
- [Khan Academy - Radix Sort](https://www.khanacademy.org/computing/computer-science/algorithms/radix-sort/a/radix-sort)

To solve the problem of finding the k-th smallest trimmed number, we need to follow these steps for each query:

1. **Trim each number**: Extract the rightmost `trimi` digits from each number in the array `nums`.
2. **Sort the trimmed numbers**: Sort the trimmed numbers, maintaining the original indices to resolve ties.
3. **Find the k-th smallest trimmed number**: Determine the k-th smallest trimmed number based on the sorted list.

Here is a Python function to implement this approach:

```python
def kthSmallestTrimmedNumber(nums, queries):
    results = []

    for k, trim in queries:
        # Create a list of tuples containing trimmed number and original index
        trimmed_nums = [(num[-trim:], i) for i, num in enumerate(nums)]
        
        # Sort based on the trimmed number, and use the index to break ties
        trimmed_nums.sort()
        
        # Find the k-th smallest trimmed number
        results.append(trimmed_nums[k-1][1])
    
    return results

# Example usage:
nums = ["102","473","251","814"]
queries = [[1,1],[2,3],[4,2],[1,2]]
print(kthSmallestTrimmedNumber(nums, queries))  # Output: [2, 2, 1, 0]
```

### Explanation

1. **Trimming Numbers**:
   - For each query `[k, trim]`, extract the last `trim` digits of each number.
   - For example, if `nums = ["102","473","251","814"]` and `trim = 1`, the trimmed numbers would be `["2", "3", "1", "4"]`.

2. **Sorting Trimmed Numbers**:
   - Sort these trimmed numbers lexicographically (as strings) along with their original indices.
   - This helps maintain the order of elements with the same trimmed value based on their original position.

3. **Finding k-th Smallest**:
   - After sorting, the k-th smallest element can be directly accessed.
   - The result for each query is the original index of this k-th smallest trimmed number.

### Example Walkthrough

Let's go through the example in detail:

1. **First Query `[1, 1]`**:
   - Trimmed numbers: `["2", "3", "1", "4"]`
   - Sorted trimmed numbers with original indices: `[("1", 2), ("2", 0), ("3", 1), ("4", 3)]`
   - 1st smallest trimmed number: `("1", 2)`, so the answer is `2`.

2. **Second Query `[2, 3]`**:
   - Trimmed numbers: `["102", "473", "251", "814"]`
   - Sorted trimmed numbers with original indices: `[("102", 0), ("251", 2), ("473", 1), ("814", 3)]`
   - 2nd smallest trimmed number: `("251", 2)`, so the answer is `2`.

3. **Third Query `[4, 2]`**:
   - Trimmed numbers: `["02", "73", "51", "14"]`
   - Sorted trimmed numbers with original indices: `[("02", 0), ("14", 3), ("51", 2), ("73", 1)]`
   - 4th smallest trimmed number: `("73", 1)`, so the answer is `1`.

4. **Fourth Query `[1, 2]`**:
   - Trimmed numbers: `["02", "73", "51", "14"]`
   - Sorted trimmed numbers with original indices: `[("02", 0), ("14", 3), ("51", 2), ("73", 1)]`
   - 1st smallest trimmed number: `("02", 0)`, so the answer is `0`.

The result array `results` for the queries `[[1, 1], [2, 3], [4, 2], [1, 2]]` is `[2, 2, 1, 0]`.

### Complexity
- **Time Complexity**: For each query, trimming takes \(O(n)\), sorting takes \(O(n \log n)\), making the total complexity \(O(q \cdot n \log n)\), where \(q\) is the number of queries.
- **Space Complexity**: The space complexity is \(O(n)\) for storing the trimmed numbers and their indices.

class Solution:
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        maxVal = max(nums)
        exp = 1
        radix = 10
        aux = [0] * len(nums)

        while maxVal // exp > 0:
            count = [0] * radix
            for num in nums:
                count[(num // exp) % 10] += 1
            for i in range(1, radix):
                count[i] += count[i - 1]
            i = len(nums) - 1
            while i >= 0:
                aux[count[(nums[i] // exp) % 10] - 1] = nums[i]
                count[(nums[i] // exp) % 10] -= 1
                i -= 1
            for i in range(len(nums)):
                nums[i] = aux[i]
            exp *= 10

        maxGap = 0
        for i in range(len(nums) - 1):
            maxGap = max(nums[i + 1] - nums[i], maxGap)
        return maxGap

class Bucket:
    def __init__(self):
        self.used = False
        self.minval = float("inf")
        self.maxval = float("-inf")


class Solution:
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        mini, maxi = min(nums), max(nums)

        bucketSize = max(1, (maxi - mini) // (len(nums) - 1))
        bucketNum = (maxi - mini) // bucketSize + 1
        buckets = [Bucket() for _ in range(bucketNum)]

        for num in nums:
            idx = (num - mini) // bucketSize
            buckets[idx].used = True
            buckets[idx].minval = min(num, buckets[idx].minval)
            buckets[idx].maxval = max(num, buckets[idx].maxval)

        prevBucketMax = mini
        maxGap = 0
        for bucket in buckets:
            if not bucket.used:
                continue

            maxGap = max(maxGap, bucket.minval - prevBucketMax)
            prevBucketMax = bucket.maxval

        return maxGap

class Solution:
    def bucket_sort(self, lst: List[int], K) -> None:
        """
        Sorts a list of integers using K buckets
        """
        buckets = [[] for _ in range(K)]

        # place elements into buckets
        shift = min(lst)
        max_val = max(lst) - shift
        bucket_size = max(1, max_val / K)
        for i, elem in enumerate(lst):
            # same as K * lst[i] / max(lst)
            index = (elem - shift) // bucket_size
            # edge case for max value
            if index == K:
                # put the max value in the last bucket
                buckets[K - 1].append(elem)
            else:
                buckets[index].append(elem)

        # sort individual buckets
        for bucket in buckets:
            bucket.sort()

        # convert sorted buckets into final output
        sorted_array = []
        for bucket in buckets:
            sorted_array.extend(bucket)

        # common practice to mutate original array with sorted elements
        # perfectly fine to just return sorted_array instead
        for i in range(len(lst)):
            lst[i] = sorted_array[i]

### Bucket Sort

**Bucket Sort** is a comparison-based sorting algorithm that distributes elements into several "buckets". Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sort algorithm. Finally, the sorted buckets are concatenated to form the final sorted array.

#### How It Works

1. **Create Buckets**: Divide the elements into a number of buckets.
2. **Distribute Elements**: Go through the array and distribute each element into the appropriate bucket.
3. **Sort Buckets**: Sort each bucket individually. This can be done using any efficient sorting algorithm.
4. **Concatenate Buckets**: Concatenate the sorted buckets to get the final sorted array.

### Steps

1. **Determine the Range**: Find the minimum and maximum values in the array to determine the range.
2. **Initialize Buckets**: Create an array of empty buckets.
3. **Distribute Elements**: Distribute the elements from the original array into the appropriate buckets based on their value.
4. **Sort Individual Buckets**: Sort each bucket using a suitable sorting algorithm.
5. **Concatenate Buckets**: Concatenate the contents of all buckets in order to obtain the sorted array.

### Pseudocode

```text
bucketSort(array, n)
  create n empty buckets (lists)

  for i from 0 to n-1 do
    insert array[i] into appropriate bucket

  for i from 0 to n-1 do
    sort each bucket

  concatenate all sorted buckets into array
end bucketSort
```

### Example

Consider the array: `[0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]`

1. **Create Buckets**:
   - Create an array of 10 buckets (each bucket corresponds to a range of 0.1).

2. **Distribute Elements**:
   - Bucket 0: `[0.12]`
   - Bucket 1: `[0.17, 0.12]`
   - Bucket 2: `[0.21, 0.23, 0.26]`
   - Bucket 3: `[0.39]`
   - Bucket 4: `[]`
   - Bucket 5: `[]`
   - Bucket 6: `[0.68]`
   - Bucket 7: `[0.78, 0.72]`
   - Bucket 8: `[]`
   - Bucket 9: `[0.94]`

3. **Sort Buckets**:
   - Bucket 0: `[0.12]`
   - Bucket 1: `[0.12, 0.17]`
   - Bucket 2: `[0.21, 0.23, 0.26]`
   - Bucket 3: `[0.39]`
   - Bucket 4: `[]`
   - Bucket 5: `[]`
   - Bucket 6: `[0.68]`
   - Bucket 7: `[0.72, 0.78]`
   - Bucket 8: `[]`
   - Bucket 9: `[0.94]`

4. **Concatenate Buckets**:
   - Final sorted array: `[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]`

### Time Complexity

- **Best Case**: \(O(n + k)\)
- **Average Case**: \(O(n + k)\)
- **Worst Case**: \(O(n^2)\) (when all elements are placed in one bucket)
  - \(n\) is the number of elements.
  - \(k\) is the number of buckets.

### Space Complexity

- **Auxiliary Space**: \(O(n + k)\)

### Characteristics

- **Stable**: Yes (if the underlying sort is stable)
- **In-Place**: No (requires additional space for buckets)

### Implementation in Python

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def bucketSort(arr):
    n = len(arr)
    if n <= 0:
        return arr

    # Create empty buckets
    buckets = [[] for _ in range(n)]

    # Insert elements into their respective buckets
    for i in range(n):
        index = int(arr[i] * n)
        buckets[index].append(arr[i])

    # Sort individual buckets
    for bucket in buckets:
        insertionSort(bucket)

    # Concatenate all buckets into arr
    sorted_array = []
    for bucket in buckets:
        sorted_array.extend(bucket)

    return sorted_array

# Example usage
arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]
sorted_arr = bucketSort(arr)
print("Sorted array is:", sorted_arr)  # Output: Sorted array is: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

### References
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
- Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson.
- [GeeksforGeeks - Bucket Sort](https://www.geeksforgeeks.org/bucket-sort/)
- [Khan Academy - Bucket Sort](https://www.khanacademy.org/computing/computer-science/algorithms/bucket-sort/a/bucket-sort)

from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = Counter(nums)
        unique = list(count.keys())
        
        def partition(left, right, pivot_index) -> int:
            pivot_frequency = count[unique[pivot_index]]
            # 1. Move the pivot to end
            unique[pivot_index], unique[right] = unique[right], unique[pivot_index]  
            
            # 2. Move all less frequent elements to the left
            store_index = left
            for i in range(left, right):
                if count[unique[i]] < pivot_frequency:
                    unique[store_index], unique[i] = unique[i], unique[store_index]
                    store_index += 1

            # 3. Move the pivot to its final place
            unique[right], unique[store_index] = unique[store_index], unique[right]  
            
            return store_index
        
        def quickselect(left, right, k_smallest) -> None:
            """
            Sort a list within left..right till kth less frequent element
            takes its place. 
            """
            # base case: the list contains only one element
            if left == right: 
                return
            
            # Select a random pivot_index
            pivot_index = random.randint(left, right)     
                            
            # Find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # If the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return 
            # go left
            elif k_smallest < pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            # go right
            else:
                quickselect(pivot_index + 1, right, k_smallest)
         
        n = len(unique) 
        # kth top frequent element is (n - k)th less frequent.
        # Do a partial sort: from less frequent to the most frequent, till
        # (n - k)th less frequent element takes its place (n - k) in a sorted array. 
        # All elements on the left are less frequent.
        # All the elements on the right are more frequent.  
        quickselect(0, n - 1, n - k)
        # Return top k frequent elements
        return unique[n - k:]

