https://leetcode.com/explore/learn/card/heap/646/practices/4092/


Definition and Classification of HeapReport Issue

Priority Queues
Before introducing a Heap, let's first talk about a Priority Queue.
Wikipedia: a priority queue is an abstract data type similar to a regular queue or stack data structure in which each element additionally has a "priority" associated with it. In a priority queue, an element with high priority is served before an element with low priority.
In daily life, we would assign different priorities to tasks, start working on the task with the highest priority and then proceed to the task with the second highest priority. This is an example of a Priority Queue.
A common misconception is that a Heap is the same as a Priority Queue, which is not true. A priority queue is an abstract data type, while a Heap is a data structure. Therefore, a Heap is not a Priority Queue, but a way to implement a Priority Queue.
There are multiple ways to implement a Priority Queue, such as array and linked list. However, these implementations only guarantee 𝑂(1)O(1) time complexity for either insertion or deletion, while the other operation will have a time complexity of 𝑂(𝑁)O(N). On the other hand, implementing the priority queue with Heap will allow both insertion and deletion to have a time complexity of 𝑂(log⁡𝑁)O(logN). So, what is a Heap?
In this chapter, we will learn to:
1.Understand the Heap data structure.
2.Understand Max Heap and Min Heap.
3.Understand the insertion and deletion of a Heap.
4.Implement a Heap.

Definition of Heap
According to Wikipedia, a Heap is a special type of binary tree. A heap is a binary tree that meets the following criteria:
Is a complete binary tree;
The value of each node must be no greater than (or no less than) the value of its child nodes.
A Heap has the following properties:
Insertion of an element into the Heap has a time complexity of 𝑂(log⁡𝑁)O(logN);
Deletion of an element from the Heap has a time complexity of 𝑂(log⁡𝑁)O(logN);
The maximum/minimum value in the Heap can be obtained with 𝑂(1)O(1) time complexity.

Classification of Heap
There are two kinds of heaps: Max Heap and Min Heap.

Max Heap: Each node in the Heap has a value no less than its child nodes. Therefore, the top element (root node) has the largest value in the Heap.


Min Heap: Each node in the Heap has a value no larger than its child nodes. Therefore, the top element (root node) has the smallest value in the Heap.



Heap insertion is a process of adding a new element to a heap while maintaining the heap property. Heaps can be either max-heaps or min-heaps. In a max-heap, the key at a parent node is always greater than or equal to the keys of its children, and in a min-heap, the key at a parent node is always less than or equal to the keys of its children. Below is the step-by-step process of inserting a new element into a heap.

### Steps for Heap Insertion:

#### 1. Add the new element to the end of the heap:
- Insert the new element at the last position in the heap (the next available leaf position).

#### 2. Restore the heap property (heapify-up or bubble-up):
- Compare the newly added element with its parent.
- If the new element violates the heap property (is greater than its parent in a max-heap, or smaller than its parent in a min-heap), swap it with its parent.
- Repeat this process until the heap property is restored or the element becomes the root of the heap.

### Example:

Let's illustrate heap insertion with an example using a max-heap.

#### Initial Max-Heap:
```
         10
       /    \
      9      8
     / \    /
    7   6  5
```

#### Insert a new element, say 11:
1. Add 11 to the end of the heap:
```
         10
       /    \
      9      8
     / \    / \
    7   6  5  11
```

2. Restore the heap property:
   - Compare 11 with its parent (8).
   - Since 11 > 8, swap them.
```
         10
       /    \
      9     11
     / \    / \
    7   6  5   8
```

   - Compare 11 with its new parent (10).
   - Since 11 > 10, swap them.
```
         11
       /    \
      9     10
     / \    / \
    7   6  5   8
```

Now the heap property is restored.

### Pseudocode for Heap Insertion in a Max-Heap:

```python
def heap_insert(heap, element):
    # Add the new element to the end of the heap
    heap.append(element)
    index = len(heap) - 1
    
    # Heapify-up process
    while index > 0:
        parent_index = (index - 1) // 2
        if heap[index] > heap[parent_index]:
            # Swap the current element with its parent
            heap[index], heap[parent_index] = heap[parent_index], heap[index]
            # Move up to the parent index
            index = parent_index
        else:
            break
```

### Complexity:
- The time complexity of heap insertion is \(O(\log n)\), where \(n\) is the number of elements in the heap. This is because in the worst case, we may need to traverse from the leaf to the root, which is proportional to the height of the heap, and the height of a complete binary tree (heap) is \(\log n\).

Heap insertion ensures that the heap structure remains valid, preserving the heap property with each new element added.

Heap insertion is a process of adding a new element to a heap while maintaining the heap property. Heaps can be either max-heaps or min-heaps. In a max-heap, the key at a parent node is always greater than or equal to the keys of its children, and in a min-heap, the key at a parent node is always less than or equal to the keys of its children. Below is the step-by-step process of inserting a new element into a heap.

### Steps for Heap Insertion:

#### 1. Add the new element to the end of the heap:
- Insert the new element at the last position in the heap (the next available leaf position).

#### 2. Restore the heap property (heapify-up or bubble-up):
- Compare the newly added element with its parent.
- If the new element violates the heap property (is greater than its parent in a max-heap, or smaller than its parent in a min-heap), swap it with its parent.
- Repeat this process until the heap property is restored or the element becomes the root of the heap.

### Example:

Let's illustrate heap insertion with an example using a max-heap.

#### Initial Max-Heap:
```
         10
       /    \
      9      8
     / \    /
    7   6  5
```

#### Insert a new element, say 11:
1. Add 11 to the end of the heap:
```
         10
       /    \
      9      8
     / \    / \
    7   6  5  11
```

2. Restore the heap property:
   - Compare 11 with its parent (8).
   - Since 11 > 8, swap them.
```
         10
       /    \
      9     11
     / \    / \
    7   6  5   8
```

   - Compare 11 with its new parent (10).
   - Since 11 > 10, swap them.
```
         11
       /    \
      9     10
     / \    / \
    7   6  5   8
```

Now the heap property is restored.

### Pseudocode for Heap Insertion in a Max-Heap:

```python
def heap_insert(heap, element):
    # Add the new element to the end of the heap
    heap.append(element)
    index = len(heap) - 1
    
    # Heapify-up process
    while index > 0:
        parent_index = (index - 1) // 2
        if heap[index] > heap[parent_index]:
            # Swap the current element with its parent
            heap[index], heap[parent_index] = heap[parent_index], heap[index]
            # Move up to the parent index
            index = parent_index
        else:
            break
```

### Complexity:
- The time complexity of heap insertion is \(O(\log n)\), where \(n\) is the number of elements in the heap. This is because in the worst case, we may need to traverse from the leaf to the root, which is proportional to the height of the heap, and the height of a complete binary tree (heap) is \(\log n\).

Heap insertion ensures that the heap structure remains valid, preserving the heap property with each new element added.

下面是实现一个最小堆（Min Heap）的代码，并附有中文解释：

```python
class MinHeap:
    def __init__(self, heapSize):
        # 创建一个使用数组表示的完全二叉树
        # 然后使用二叉树构建一个堆
        self.heapSize = heapSize
        # 在实例化数组时需要记录元素数量
        # heapSize 记录数组的大小
        self.minheap = [0] * (heapSize + 1)
        # realSize 记录堆中元素的实际数量
        self.realSize = 0

    # 添加元素的方法
    def add(self, element):
        self.realSize += 1
        # 如果堆中的元素数量超过了预设的堆大小
        # 打印“添加了太多元素”并返回
        if self.realSize > self.heapSize:
            print("Added too many elements!")
            self.realSize -= 1
            return
        # 将元素添加到数组中
        self.minheap[self.realSize] = element
        # 新添加元素的索引
        index = self.realSize
        # 新添加元素的父节点
        # 如果我们用数组表示完全二叉树，并将根节点存储在索引 1 处
        # 任何节点的父节点的索引为 [节点索引 / 2]
        # 左子节点的索引为 [节点索引 * 2]
        # 右子节点的索引为 [节点索引 * 2 + 1]
        parent = index // 2
        # 如果新添加的元素小于其父节点的值，
        # 则其值将与父节点的值交换
        while (self.minheap[index] < self.minheap[parent] and index > 1):
            self.minheap[parent], self.minheap[index] = self.minheap[index], self.minheap[parent]
            index = parent
            parent = index // 2
    
    # 获取堆顶元素
    def peek(self):
        return self.minheap[1]
    
    # 删除堆顶元素
    def pop(self):
        # 如果当前堆中的元素数量为 0，
        # 打印“没有任何元素”并返回默认值
        if self.realSize < 1:
            print("Don't have any element!")
            return sys.maxsize
        else:
            # 当堆中还有元素时
            # self.realSize >= 1
            removeElement = self.minheap[1]
            # 将堆中的最后一个元素放到堆顶
            self.minheap[1] = self.minheap[self.realSize]
            self.realSize -= 1
            index = 1
            # 当删除的元素不是叶子节点时
            while (index <= self.realSize // 2):
                # 删除元素的左子节点
                left = index * 2
                # 删除元素的右子节点
                right = (index * 2) + 1
                # 如果删除的元素大于左子节点或右子节点
                # 则其值需要与左子节点和右子节点中较小的值交换
                if (self.minheap[index] > self.minheap[left] or self.minheap[index] > self.minheap[right]):
                    if self.minheap[left] < self.minheap[right]:
                        self.minheap[left], self.minheap[index] = self.minheap[index], self.minheap[left]
                        index = left
                    else:
                        self.minheap[right], self.minheap[index] = self.minheap[index], self.minheap[right]
                        index = right
                else:
                    break
            return removeElement
    
    # 返回堆中的元素数量
    def size(self):
        return self.realSize
    
    def __str__(self):
        return str(self.minheap[1 : self.realSize + 1])
        

if __name__ == "__main__":
    # 测试用例
    minHeap = MinHeap(5)
    minHeap.add(3)
    minHeap.add(1)
    minHeap.add(2)
    # 输出 [1,3,2]
    print(minHeap)
    # 输出 1
    print(minHeap.peek())
    # 输出 1
    print(minHeap.pop())
    # 输出 2
    print(minHeap.pop())
    # 输出 3
    print(minHeap.pop())
    minHeap.add(4)
    minHeap.add(5)
    # 输出 [4,5]
    print(minHeap)
```

### 代码解释
- **类初始化 (`__init__`)**：初始化堆的大小、存储堆元素的数组以及实际元素数量。
- **添加元素 (`add`)**：向堆中添加元素，并确保堆的性质不变。如果添加的元素数量超过了堆的容量，会给出警告信息。
- **获取堆顶元素 (`peek`)**：返回堆顶元素（即最小元素）。
- **删除堆顶元素 (`pop`)**：删除并返回堆顶元素，然后调整堆以维持最小堆性质。
- **获取堆中元素数量 (`size`)**：返回堆中的实际元素数量。
- **字符串表示 (`__str__`)**：返回堆的字符串表示，仅显示实际存在的元素。

### 测试用例
通过几个测试用例，可以验证最小堆的功能是否正确，如添加元素、获取堆顶元素、删除堆顶元素等操作。

下面是一个最大堆（Max Heap）的实现代码，并附有中文解释：

```python
class MaxHeap:
    def __init__(self, heapSize):
        # 创建一个使用数组表示的完全二叉树
        # 然后使用二叉树构建一个堆
        self.heapSize = heapSize
        # 在实例化数组时需要记录元素数量
        # heapSize 记录数组的大小
        self.maxheap = [0] * (heapSize + 1)
        # realSize 记录堆中元素的实际数量
        self.realSize = 0

    # 添加元素的方法
    def add(self, element):
        self.realSize += 1
        # 如果堆中的元素数量超过了预设的堆大小
        # 打印“添加了太多元素”并返回
        if self.realSize > self.heapSize:
            print("Added too many elements!")
            self.realSize -= 1
            return
        # 将元素添加到数组中
        self.maxheap[self.realSize] = element
        # 新添加元素的索引
        index = self.realSize
        # 新添加元素的父节点
        # 如果我们用数组表示完全二叉树，并将根节点存储在索引 1 处
        # 任何节点的父节点的索引为 [节点索引 / 2]
        # 左子节点的索引为 [节点索引 * 2]
        # 右子节点的索引为 [节点索引 * 2 + 1]
        parent = index // 2
        
        # 如果新添加的元素大于其父节点的值，
        # 则其值将与父节点的值交换
        while (self.maxheap[index] > self.maxheap[parent] and index > 1):
            self.maxheap[parent], self.maxheap[index] = self.maxheap[index], self.maxheap[parent]
            index = parent
            parent = index // 2
            
    # 获取堆顶元素
    def peek(self):
        return self.maxheap[1]
    
    # 删除堆顶元素
    def pop(self):
        # 如果当前堆中的元素数量为 0，
        # 打印“没有任何元素”并返回默认值
        if self.realSize < 1:
            print("Don't have any element!")
            return -sys.maxsize
        else:
            # 当堆中还有元素时
            # self.realSize >= 1
            removeElement = self.maxheap[1]
            # 将堆中的最后一个元素放到堆顶
            self.maxheap[1] = self.maxheap[self.realSize]
            self.realSize -= 1
            index = 1
            # 当删除的元素不是叶子节点时
            while (index <= self.realSize // 2):
                # 删除元素的左子节点
                left = index * 2
                # 删除元素的右子节点
                right = (index * 2) + 1
                # 如果删除的元素小于左子节点或右子节点
                # 则其值需要与左子节点和右子节点中较大的值交换
                if (self.maxheap[index] < self.maxheap[left] or self.maxheap[index] < self.maxheap[right]):
                    if self.maxheap[left] > self.maxheap[right]:
                        self.maxheap[left], self.maxheap[index] = self.maxheap[index], self.maxheap[left]
                        index = left
                    else:
                        self.maxheap[right], self.maxheap[index] = self.maxheap[index], self.maxheap[right]
                        index = right
                else:
                    break
            return removeElement
    
    # 返回堆中的元素数量
    def size(self):
        return self.realSize
    
    def __str__(self):
        return str(self.maxheap[1 : self.realSize + 1])
        

if __name__ == "__main__":
    # 测试用例
    maxHeap = MaxHeap(5)
    maxHeap.add(1)
    maxHeap.add(2)
    maxHeap.add(3)
    # 输出 [3,1,2]
    print(maxHeap)
    # 输出 3
    print(maxHeap.peek())
    # 输出 3
    print(maxHeap.pop())
    # 输出 2
    print(maxHeap.pop())
    # 输出 1
    print(maxHeap.pop())
    maxHeap.add(4)
    maxHeap.add(5)
    # 输出 [5,4]
    print(maxHeap)
```

### 代码解释
- **类初始化 (`__init__`)**：初始化堆的大小、存储堆元素的数组以及实际元素数量。
- **添加元素 (`add`)**：向堆中添加元素，并确保堆的性质不变。如果添加的元素数量超过了堆的容量，会给出警告信息。
- **获取堆顶元素 (`peek`)**：返回堆顶元素（即最大元素）。
- **删除堆顶元素 (`pop`)**：删除并返回堆顶元素，然后调整堆以维持最大堆性质。
- **获取堆中元素数量 (`size`)**：返回堆中的实际元素数量。
- **字符串表示 (`__str__`)**：返回堆的字符串表示，仅显示实际存在的元素。

### 测试用例
通过几个测试用例，可以验证最大堆的功能是否正确，如添加元素、获取堆顶元素、删除堆顶元素等操作。

使用 Python 内置的 `heapq` 模块可以很方便地构建和操作最小堆（Min Heap）。由于 Python 的 `heapq` 模块没有直接支持最大堆（Max Heap）的功能，我们可以通过对元素进行取反来间接实现最大堆。以下是详细的代码解释和示例：

### 构建一个空的最小堆

```python
import heapq

# 构建一个空的最小堆
minHeap = []
heapq.heapify(minHeap)
```

### 构建一个空的最大堆

由于 Python 没有直接支持最大堆的内部函数，我们可以通过对每个元素取反来间接实现最大堆：

```python
# 构建一个空的最大堆
# 因为 Python 没有直接支持最大堆的内部函数，所以我们不直接构建最大堆
```

### 使用初始值构建堆（Heapify）

我们可以通过 `heapify` 函数将一个列表转换为一个最小堆：

```python
# 使用初始值构建堆，这个过程称为 "Heapify"
# 这个堆是一个最小堆
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
```

### 构建一个最大堆的技巧

由于没有直接构建最大堆的内部函数，我们可以通过将每个元素乘以 -1，然后对这些修改后的元素进行 heapify 操作。堆顶元素将是修改后的集合中的最小元素，但可以转换为原始数据集中的最大值：

```python
# 构建最大堆的技巧
# 由于没有直接构建最大堆的内部函数
# 我们可以将每个元素乘以 -1，然后对这些修改后的元素进行 heapify 操作
# 堆顶元素将是修改后的集合中的最小元素，但可以转换为原始数据集中的最大值

maxHeap = [1, 2, 3]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
# maxHeap 的堆顶元素是 -3
# 转换 -3 为 3，这是原始 maxHeap 中的最大值
```

### 代码示例

完整的代码示例如下：

```python
import heapq

# 构建一个空的最小堆
minHeap = []
heapq.heapify(minHeap)

# 使用初始值构建最小堆
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("最小堆：", heapWithValues)  # 输出: [1, 3, 2]

# 构建最大堆的技巧
maxHeap = [1, 2, 3]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("最大堆（反转后）：", maxHeap)  # 输出: [-3, -2, -1]

# 获取最大堆的堆顶元素，并将其转换回正数
max_value = -heapq.heappop(maxHeap)
print("最大堆的堆顶元素：", max_value)  # 输出: 3
```

通过上述方法，我们可以使用 Python 的 `heapq` 模块有效地实现最小堆和最大堆的操作。

下面是一个详细的例子，展示如何使用 Python 的 `heapq` 模块来构建和操作最小堆和最大堆。

### 最小堆

#### 构建一个空的最小堆并添加元素

```python
import heapq

# 构建一个空的最小堆
minHeap = []
heapq.heapify(minHeap)

# 向最小堆中添加元素
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)

# 输出最小堆的元素
print("最小堆：", minHeap)  # 输出: [1, 3, 2]

# 获取并移除最小堆的堆顶元素
min_value = heapq.heappop(minHeap)
print("最小堆的堆顶元素：", min_value)  # 输出: 1

# 输出最小堆剩余的元素
print("最小堆剩余的元素：", minHeap)  # 输出: [2, 3]
```

### 最大堆

#### 构建一个空的最大堆并添加元素

由于 Python 没有直接支持最大堆的内部函数，我们可以通过对每个元素取反来间接实现最大堆：

```python
# 构建一个空的最大堆
maxHeap = []
heapq.heapify(maxHeap)

# 向最大堆中添加元素（取反后添加）
heapq.heappush(maxHeap, -3)
heapq.heappush(maxHeap, -1)
heapq.heappush(maxHeap, -2)

# 输出最大堆的元素（取反前的值）
print("最大堆：", [-x for x in maxHeap])  # 输出: [3, 1, 2]

# 获取并移除最大堆的堆顶元素（取反后）
max_value = -heapq.heappop(maxHeap)
print("最大堆的堆顶元素：", max_value)  # 输出: 3

# 输出最大堆剩余的元素（取反前的值）
print("最大堆剩余的元素：", [-x for x in maxHeap])  # 输出: [2, 1]
```

### 使用初始值构建堆（Heapify）

#### 使用初始值构建最小堆

```python
# 使用初始值构建最小堆
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("使用初始值构建的最小堆：", heapWithValues)  # 输出: [1, 3, 2]
```

#### 使用初始值构建最大堆

```python
# 使用初始值构建最大堆
maxHeap = [3, 1, 2]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("使用初始值构建的最大堆（反转后）：", maxHeap)  # 输出: [-3, -1, -2]

# 获取最大堆的堆顶元素，并将其转换回正数
max_value = -heapq.heappop(maxHeap)
print("使用初始值构建的最大堆的堆顶元素：", max_value)  # 输出: 3
```

### 完整代码示例

```python
import heapq

# 最小堆示例
minHeap = []
heapq.heapify(minHeap)
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)
print("最小堆：", minHeap)  # 输出: [1, 3, 2]
min_value = heapq.heappop(minHeap)
print("最小堆的堆顶元素：", min_value)  # 输出: 1
print("最小堆剩余的元素：", minHeap)  # 输出: [2, 3]

# 最大堆示例
maxHeap = []
heapq.heapify(maxHeap)
heapq.heappush(maxHeap, -3)
heapq.heappush(maxHeap, -1)
heapq.heappush(maxHeap, -2)
print("最大堆：", [-x for x in maxHeap])  # 输出: [3, 1, 2]
max_value = -heapq.heappop(maxHeap)
print("最大堆的堆顶元素：", max_value)  # 输出: 3
print("最大堆剩余的元素：", [-x for x in maxHeap])  # 输出: [2, 1]

# 使用初始值构建最小堆
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("使用初始值构建的最小堆：", heapWithValues)  # 输出: [1, 3, 2]

# 使用初始值构建最大堆
maxHeap = [3, 1, 2]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("使用初始值构建的最大堆（反转后）：", maxHeap)  # 输出: [-3, -1, -2]
max_value = -heapq.heappop(maxHeap)
print("使用初始值构建的最大堆的堆顶元素：", max_value)  # 输出: 3
```

通过上述方法，我们可以使用 Python 的 `heapq` 模块有效地实现和操作最小堆和最大堆。

在最小堆和最大堆中插入元素时，都需要确保堆的性质保持不变。以下是如何在最小堆和最大堆中插入元素的详细步骤和示例代码。

### 在最小堆中插入元素

#### 步骤：
1. 将新元素添加到堆的末尾。
2. 将新元素与其父节点进行比较，如果新元素小于其父节点，则交换它们。
3. 重复步骤2，直到新元素不再小于其父节点，或者新元素成为根节点。

### 在最大堆中插入元素

由于Python的 `heapq` 模块默认只支持最小堆，插入最大堆的元素需要将元素取反，然后进行插入操作。

#### 步骤：
1. 将新元素取反后添加到堆的末尾。
2. 将新元素与其父节点进行比较，如果新元素大于其父节点，则交换它们。
3. 重复步骤2，直到新元素不再大于其父节点，或者新元素成为根节点。

### 示例代码

```python
import heapq

# 最小堆示例
minHeap = []
heapq.heapify(minHeap)

# 插入元素到最小堆
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"插入 {element} 后的最小堆: {heap}")

# 插入操作
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# 获取并移除最小堆的堆顶元素
min_value = heapq.heappop(minHeap)
print(f"最小堆的堆顶元素：{min_value}")
print(f"移除堆顶元素后的最小堆：{minHeap}")

# 最大堆示例
maxHeap = []
heapq.heapify(maxHeap)

# 插入元素到最大堆
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"插入 {element} 后的最大堆: {[-x for x in heap]}")

# 插入操作
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# 获取并移除最大堆的堆顶元素
max_value = -heapq.heappop(maxHeap)
print(f"最大堆的堆顶元素：{max_value}")
print(f"移除堆顶元素后的最大堆：{[-x for x in maxHeap]}")

```

### 解释
1. **最小堆的插入**：
   - 使用 `heapq.heappush` 将元素插入到最小堆中。
   - 每次插入后，输出堆的状态。

2. **最大堆的插入**：
   - 由于 `heapq` 只支持最小堆，首先将元素取反，然后插入堆中。
   - 每次插入后，输出堆的状态（注意输出时将元素取反以显示原始值）。

通过上述方法，我们可以在最小堆和最大堆中插入元素，并确保堆的性质保持不变。

# Get top element from the Min Heap
# i.e. the smallest element
minHeap[0]
# Get top element from the Max Heap
# i.e. the largest element
# When inserting an element, we multiplied it by -1
# Therefore, we need to multiply the element by -1 to revert it back
-1 * maxHeap[0]

要获取堆顶元素，我们需要根据堆的类型来处理最小堆和最大堆。以下是如何在最小堆和最大堆中获取堆顶元素的详细步骤和示例代码。

### 最小堆

在最小堆中，堆顶元素是最小的元素。使用 Python 的 `heapq` 模块，可以很方便地获取堆顶元素。

### 最大堆

由于Python的 `heapq` 模块默认只支持最小堆，我们可以通过对堆顶元素取反来获取最大堆的堆顶元素。

### 示例代码

```python
import heapq

# 最小堆示例
minHeap = []
heapq.heapify(minHeap)

# 插入元素到最小堆
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"插入 {element} 后的最小堆: {heap}")

# 获取最小堆的堆顶元素
def get_min_heap_top(heap):
    if heap:
        return heap[0]
    return None

# 插入操作
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# 获取最小堆的堆顶元素
min_top = get_min_heap_top(minHeap)
print(f"最小堆的堆顶元素：{min_top}")

# 最大堆示例
maxHeap = []
heapq.heapify(maxHeap)

# 插入元素到最大堆
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"插入 {element} 后的最大堆: {[-x for x in heap]}")

# 获取最大堆的堆顶元素
def get_max_heap_top(heap):
    if heap:
        return -heap[0]
    return None

# 插入操作
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# 获取最大堆的堆顶元素
max_top = get_max_heap_top(maxHeap)
print(f"最大堆的堆顶元素：{max_top}")
```

### 解释
1. **最小堆的堆顶元素**：
   - `get_min_heap_top` 函数返回最小堆的堆顶元素（即堆数组的第一个元素）。
   - 如果堆为空，返回 `None`。

2. **最大堆的堆顶元素**：
   - `get_max_heap_top` 函数通过对堆顶元素取反来获取最大堆的堆顶元素。
   - 如果堆为空，返回 `None`。

通过上述方法，我们可以在最小堆和最大堆中获取堆顶元素，并确保堆的性质保持不变。

# Delete top element from the Min Heap
heapq.heappop(minHeap)

# Delete top element from the Max Heap
heapq.heappop(maxHeap)

# Length of the Min Heap
len(minHeap)

# Length of the Max Heap
len(maxHeap)

在最小堆和最大堆中删除堆顶元素时，需要确保删除堆顶元素后堆的性质保持不变。以下是如何在最小堆和最大堆中删除堆顶元素的详细步骤和示例代码。

### 在最小堆中删除堆顶元素

#### 步骤：
1. 将堆顶元素与堆的最后一个元素交换。
2. 删除最后一个元素（现在是堆顶元素）。
3. 从堆顶开始，对堆进行调整，以重新满足最小堆的性质。

### 在最大堆中删除堆顶元素

由于Python的 `heapq` 模块默认只支持最小堆，删除最大堆的堆顶元素需要将堆顶元素取反，然后进行删除操作。

#### 步骤：
1. 将堆顶元素与堆的最后一个元素交换。
2. 删除最后一个元素（现在是堆顶元素）。
3. 从堆顶开始，对堆进行调整，以重新满足最大堆的性质。

### 示例代码

```python
import heapq

# 最小堆示例
minHeap = []
heapq.heapify(minHeap)

# 插入元素到最小堆
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"插入 {element} 后的最小堆: {heap}")

# 删除最小堆的堆顶元素
def delete_min_heap_top(heap):
    if heap:
        removed_element = heapq.heappop(heap)
        print(f"删除的最小堆堆顶元素：{removed_element}")
    else:
        print("最小堆为空，无法删除堆顶元素")

# 插入操作
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# 删除最小堆的堆顶元素
delete_min_heap_top(minHeap)
print(f"删除堆顶元素后的最小堆：{minHeap}")

# 最大堆示例
maxHeap = []
heapq.heapify(maxHeap)

# 插入元素到最大堆
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"插入 {element} 后的最大堆: {[-x for x in heap]}")

# 删除最大堆的堆顶元素
def delete_max_heap_top(heap):
    if heap:
        removed_element = -heapq.heappop(heap)
        print(f"删除的最大堆堆顶元素：{removed_element}")
    else:
        print("最大堆为空，无法删除堆顶元素")

# 插入操作
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# 删除最大堆的堆顶元素
delete_max_heap_top(maxHeap)
print(f"删除堆顶元素后的最大堆：{[-x for x in maxHeap]}")

```

### 解释
1. **最小堆的堆顶元素删除**：
   - `delete_min_heap_top` 函数通过 `heapq.heappop` 删除最小堆的堆顶元素。
   - 删除后，输出堆的状态。

2. **最大堆的堆顶元素删除**：
   - `delete_max_heap_top` 函数通过对堆顶元素取反后使用 `heapq.heappop` 删除最大堆的堆顶元素。
   - 删除后，输出堆的状态（注意输出时将元素取反以显示原始值）。

通过上述方法，我们可以在最小堆和最大堆中删除堆顶元素，并确保堆的性质保持不变。

# Code for Min Heap
import heapq

# Create an array
minHeap = []

# Heapify the array into a Min Heap
heapq.heapify(minHeap)

# Add 3，1，2 respectively to the Min Heap
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)

# Check all elements in the Min Heap, the result is [1, 3, 2]
print("minHeap: ", minHeap)

# Get the top element of the Min Heap
peekNum = minHeap[0]

# The result is 1
print("peek number: ", peekNum)

# Delete the top element in the Min Heap
popNum = heapq.heappop(minHeap)

# The result is 1
print("pop number: ", popNum)

# Check the top element after deleting 1, the result is 2
print("peek number: ", minHeap[0])

# Check all elements in the Min Heap, the result is [2,3]
print("minHeap: ", minHeap)

# Check the number of elements in the Min Heap
# Which is also the length of the Min Heap
size = len(minHeap)

# The result is 2
print("minHeap size: ", size)

# Code for Max Heap
import heapq

# Create an array
maxHeap = []

# Heapify the array into a Min Heap
# we need to negate each element to convert the Min Heap to a Max Heap
heapq.heapify(maxHeap)

# Add 1，3，2 respectively to the Max Heap
# Note we are actually adding -1, -3 and -2 after negating the elements
# The Min Heap is now converted to a Max Heap
heapq.heappush(maxHeap, -1 * 1)
heapq.heappush(maxHeap, -1 * 3)
heapq.heappush(maxHeap, -1 * 2)

# Check all elements in the Max Heap, the result is [-3, -1, -2]
print("maxHeap: ", maxHeap)

# Check the largest element in the Heap, which is min value in the -1 * Heap
peekNum = maxHeap[0]

# The result is 3
print("peek number: ", -1 * peekNum)

# Delete the largest element in the Max Heap
# Which is the smallest value in the current Heap
popNum = heapq.heappop(maxHeap)

# The result is 3
print("pop number: ", -1 *  popNum)

# Check the largest element after deleting 3, the result is 2
print("peek number: ", -1 * maxHeap[0])

# Check all elements in the Max Heap, the result is [-2,-1]
print("maxHeap: ", maxHeap)

# Check the number of elements in the Max Heap
# Which is also the length of the Min Heap
size = len(maxHeap)

# The result is 2
print("maxHeap size: ", size)

在堆操作中，理解空间和时间复杂度是非常重要的。以下是关于最小堆和最大堆在插入、获取堆顶元素和删除堆顶元素操作的空间和时间复杂度的详细解释。

### 空间复杂度

对于最小堆和最大堆，空间复杂度主要取决于存储元素所需的空间。假设堆中有 \( n \) 个元素。

- **空间复杂度**：O(n)

### 时间复杂度

#### 插入元素（Insert）

在堆中插入一个元素需要将新元素添加到堆的末尾，然后调整堆以保持堆的性质。

- **时间复杂度**：O(log n)
  - 调整堆的过程中，可能需要沿着树的高度向上交换元素。对于完全二叉树，高度为 \( O(log n) \)。

#### 获取堆顶元素（Peek）

获取堆顶元素不涉及任何调整操作，只是简单地访问数组中的第一个元素。

- **时间复杂度**：O(1)

#### 删除堆顶元素（Delete）

删除堆顶元素需要将堆的最后一个元素移到堆顶，然后调整堆以保持堆的性质。

- **时间复杂度**：O(log n)
  - 调整堆的过程中，可能需要沿着树的高度向下交换元素。对于完全二叉树，高度为 \( O(log n) \)。

### 代码示例

以下是插入、获取堆顶元素和删除堆顶元素操作的代码示例，包括时间和空间复杂度的注释。

```python
import heapq

# 最小堆示例
minHeap = []
heapq.heapify(minHeap)

# 插入元素到最小堆
def insert_min_heap(heap, element):
    # 时间复杂度：O(log n)
    heapq.heappush(heap, element)
    print(f"插入 {element} 后的最小堆: {heap}")

# 获取最小堆的堆顶元素
def get_min_heap_top(heap):
    # 时间复杂度：O(1)
    if heap:
        return heap[0]
    return None

# 删除最小堆的堆顶元素
def delete_min_heap_top(heap):
    # 时间复杂度：O(log n)
    if heap:
        removed_element = heapq.heappop(heap)
        print(f"删除的最小堆堆顶元素：{removed_element}")
    else:
        print("最小堆为空，无法删除堆顶元素")

# 插入操作
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# 获取最小堆的堆顶元素
min_top = get_min_heap_top(minHeap)
print(f"最小堆的堆顶元素：{min_top}")

# 删除最小堆的堆顶元素
delete_min_heap_top(minHeap)
print(f"删除堆顶元素后的最小堆：{minHeap}")

# 最大堆示例
maxHeap = []
heapq.heapify(maxHeap)

# 插入元素到最大堆
def insert_max_heap(heap, element):
    # 时间复杂度：O(log n)
    heapq.heappush(heap, -element)
    print(f"插入 {element} 后的最大堆: {[-x for x in heap]}")

# 获取最大堆的堆顶元素
def get_max_heap_top(heap):
    # 时间复杂度：O(1)
    if heap:
        return -heap[0]
    return None

# 删除最大堆的堆顶元素
def delete_max_heap_top(heap):
    # 时间复杂度：O(log n)
    if heap:
        removed_element = -heapq.heappop(heap)
        print(f"删除的最大堆堆顶元素：{removed_element}")
    else:
        print("最大堆为空，无法删除堆顶元素")

# 插入操作
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# 获取最大堆的堆顶元素
max_top = get_max_heap_top(maxHeap)
print(f"最大堆的堆顶元素：{max_top}")

# 删除最大堆的堆顶元素
delete_max_heap_top(maxHeap)
print(f"删除堆顶元素后的最大堆：{[-x for x in maxHeap]}")

```

### 总结

- **空间复杂度**：O(n)，因为堆需要存储所有元素。
- **时间复杂度**：
  - 插入操作：O(log n)
  - 获取堆顶元素：O(1)
  - 删除堆顶元素：O(log n)

这些复杂度反映了堆在处理元素时的效率和性能。

### 堆排序的实现和解释

以下是一个堆排序（Heap Sort）的实现，使用了最大堆的构建和调整。堆排序通过构建一个最大堆，然后逐步将最大元素移到数组末尾来实现排序。这里是详细的代码和解释：

```python
from typing import List

class Solution:
    def heap_sort(self, lst: List[int]) -> None:
        """
        Mutates elements in lst by utilizing the heap data structure
        """
        def max_heapify(heap_size, index):
            left, right = 2 * index + 1, 2 * index + 2
            largest = index
            if left < heap_size and lst[left] > lst[largest]:
                largest = left
            if right < heap_size and lst[right] > lst[largest]:
                largest = right
            if largest != index:
                lst[index], lst[largest] = lst[largest], lst[index]
                max_heapify(heap_size, largest)

        # 构建最大堆
        for i in range(len(lst) // 2 - 1, -1, -1):
            max_heapify(len(lst), i)

        # 利用堆排序
        for i in range(len(lst) - 1, 0, -1):
            # 将最后一个元素与堆顶元素交换
            lst[i], lst[0] = lst[0], lst[i]
            # 每次迭代将堆的大小减1
            max_heapify(i, 0)

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    lst = [3, 1, 5, 2, 4]
    solution.heap_sort(lst)
    print(lst)  # 输出: [1, 2, 3, 4, 5]
```

### 解释

1. **最大堆调整（max_heapify）**：
   - `max_heapify` 函数用于调整堆，使其满足最大堆的性质。对于给定的索引 `index`，函数会比较该节点与其左、右子节点的值，如果子节点的值较大，则交换它们，并递归地调整受影响的子节点。

2. **构建最大堆**：
   - 从最后一个非叶子节点开始，自下而上地调用 `max_heapify` 来构建最大堆。对于长度为 `n` 的列表，从 `n//2 - 1` 到 `0` 进行最大堆调整。

3. **堆排序**：
   - 通过交换堆顶元素和当前堆的最后一个元素，将最大元素移到数组末尾。
   - 然后，减小堆的大小，并对堆顶元素进行最大堆调整，以恢复最大堆性质。
   - 重复上述步骤，直到堆的大小为1。

### 时间和空间复杂度

- **时间复杂度**：
  - 构建最大堆：O(n)
  - 每次调整堆：O(log n)
  - 总时间复杂度：O(n log n)

- **空间复杂度**：
  - 使用了原地排序，没有使用额外的空间，因此空间复杂度为 O(1)。

这种实现方式高效且适用于需要原地排序的场景。

解决 "Top K" 问题的一种有效方法是使用堆数据结构。具体来说，可以使用一个最小堆来存储当前的前 K 个最大元素。以下是一个示例代码，展示了如何使用最小堆来解决 "Top K" 问题。

### 问题描述

给定一个数组和一个整数 K，找出数组中前 K 个最大的元素。

### 解决方案

1. 构建一个最小堆，大小为 K。
2. 遍历数组中的元素：
   - 如果堆的大小小于 K，将元素添加到堆中。
   - 否则，如果元素大于堆顶元素，替换堆顶元素，并调整堆。
3. 遍历结束后，堆中的元素即为数组中前 K 个最大的元素。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def top_k_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # 使用一个最小堆来存储前 K 个最大的元素
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap 现在包含前 K 个最大的元素
        return minHeap

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_elements(nums, k)
    print(result)  # 输出: [4, 5, 6]，顺序可能不同
```

### 解释

1. **初始化最小堆**：
   - `minHeap = []`：使用 Python 的 `heapq` 模块初始化一个空的最小堆。

2. **遍历数组中的元素**：
   - `if len(minHeap) < k`：如果堆的大小小于 K，将当前元素添加到堆中。
   - `else if num > minHeap[0]`：如果当前元素大于堆顶元素，使用 `heapreplace` 替换堆顶元素，并调整堆。

3. **返回结果**：
   - `return minHeap`：堆中的元素即为前 K 个最大的元素。

### 时间和空间复杂度

- **时间复杂度**：
  - 插入元素和调整堆的时间复杂度为 O(log K)。
  - 遍历所有元素的时间复杂度为 O(N)，其中 N 是数组的长度。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的最小堆，空间复杂度为 O(K)。

这种方法高效且适用于需要找出前 K 个最大的元素的问题。

使用堆数据结构来解决 "Top K" 问题的另一种方法是构建最大堆以获得前 K 个最小元素，或构建最小堆以获得前 K 个最大元素。以下是详细的步骤和示例代码展示如何实现这种方法。

### 问题描述

给定一个数组和一个整数 K，找出数组中前 K 个最大的元素或最小的元素。

### 解决方案

使用堆数据结构，可以通过以下步骤实现：

1. 对于找出前 K 个最大的元素，使用最小堆：
   - 构建一个大小为 K 的最小堆。
   - 遍历数组中的元素，如果堆的大小小于 K，直接添加到堆中。
   - 否则，如果元素大于堆顶元素，替换堆顶元素，并调整堆。
   
2. 对于找出前 K 个最小的元素，使用最大堆：
   - 构建一个大小为 K 的最大堆。
   - 遍历数组中的元素，如果堆的大小小于 K，直接添加到堆中。
   - 否则，如果元素小于堆顶元素，替换堆顶元素，并调整堆。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def top_k_largest_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # 使用一个最小堆来存储前 K 个最大的元素
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap 现在包含前 K 个最大的元素
        return minHeap

    def top_k_smallest_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # 使用一个最大堆来存储前 K 个最小的元素
        maxHeap = []
        
        for num in nums:
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, -num)
            else:
                if -num > maxHeap[0]:
                    heapq.heapreplace(maxHeap, -num)
        
        # maxHeap 现在包含前 K 个最小的元素（取负数后）
        return [-x for x in maxHeap]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    # 找出前 K 个最大的元素
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_largest_elements(nums, k)
    print(f"前 {k} 个最大的元素: {result}")  # 输出: [4, 5, 6]，顺序可能不同

    # 找出前 K 个最小的元素
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_smallest_elements(nums, k)
    print(f"前 {k} 个最小的元素: {result}")  # 输出: [1, 2, 3]，顺序可能不同
```

### 解释

1. **最小堆用于找出前 K 个最大的元素**：
   - `top_k_largest_elements` 方法使用最小堆来存储前 K 个最大的元素。
   - 如果堆的大小小于 K，直接将元素添加到堆中。
   - 如果堆的大小等于 K，且当前元素大于堆顶元素，则替换堆顶元素，并调整堆。
   
2. **最大堆用于找出前 K 个最小的元素**：
   - `top_k_smallest_elements` 方法使用最大堆来存储前 K 个最小的元素。
   - 注意，由于 Python 的 `heapq` 模块只支持最小堆，所以我们将元素取反以模拟最大堆。
   - 如果堆的大小小于 K，直接将元素（取反后）添加到堆中。
   - 如果堆的大小等于 K，且当前元素（取反后）大于堆顶元素，则替换堆顶元素，并调整堆。

### 时间和空间复杂度

- **时间复杂度**：
  - 插入元素和调整堆的时间复杂度为 O(log K)。
  - 遍历所有元素的时间复杂度为 O(N)，其中 N 是数组的长度。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的堆，空间复杂度为 O(K)。

这种方法高效且适用于需要找出前 K 个最大或最小元素的问题。

使用堆数据结构来获取第 K 大或第 K 小的元素是一种高效的方法。下面是详细的步骤和代码示例，展示如何使用堆来解决这个问题。

### 问题描述

给定一个数组和一个整数 K，找出数组中第 K 大或第 K 小的元素。

### 解决方案

1. **找出第 K 大的元素**：
   - 使用一个最小堆来存储前 K 个最大的元素。
   - 遍历数组中的元素，如果堆的大小小于 K，直接添加到堆中。
   - 否则，如果元素大于堆顶元素，替换堆顶元素，并调整堆。
   - 遍历结束后，堆顶元素即为第 K 大的元素。

2. **找出第 K 小的元素**：
   - 使用一个最大堆来存储前 K 个最小的元素。
   - 遍历数组中的元素，如果堆的大小小于 K，直接添加到堆中。
   - 否则，如果元素小于堆顶元素，替换堆顶元素，并调整堆。
   - 遍历结束后，堆顶元素即为第 K 小的元素。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def kth_largest_element(self, nums: List[int], k: int) -> int:
        if k == 0:
            return None
        
        # 使用一个最小堆来存储前 K 个最大的元素
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap 的堆顶元素即为第 K 大的元素
        return minHeap[0]

    def kth_smallest_element(self, nums: List[int], k: int) -> int:
        if k == 0:
            return None
        
        # 使用一个最大堆来存储前 K 个最小的元素
        maxHeap = []
        
        for num in nums:
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, -num)
            else:
                if -num > maxHeap[0]:
                    heapq.heapreplace(maxHeap, -num)
        
        # maxHeap 的堆顶元素即为第 K 小的元素（取负数后）
        return -maxHeap[0]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    # 找出第 K 大的元素
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.kth_largest_element(nums, k)
    print(f"第 {k} 大的元素: {result}")  # 输出: 5

    # 找出第 K 小的元素
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.kth_smallest_element(nums, k)
    print(f"第 {k} 小的元素: {result}")  # 输出: 2
```

### 解释

1. **找出第 K 大的元素**：
   - `kth_largest_element` 方法使用最小堆来存储前 K 个最大的元素。
   - 如果堆的大小小于 K，直接将元素添加到堆中。
   - 如果堆的大小等于 K，且当前元素大于堆顶元素，则替换堆顶元素，并调整堆。
   - 最终，堆顶元素即为第 K 大的元素。

2. **找出第 K 小的元素**：
   - `kth_smallest_element` 方法使用最大堆来存储前 K 个最小的元素。
   - 注意，由于 Python 的 `heapq` 模块只支持最小堆，所以我们将元素取反以模拟最大堆。
   - 如果堆的大小小于 K，直接将元素（取反后）添加到堆中。
   - 如果堆的大小等于 K，且当前元素（取反后）大于堆顶元素，则替换堆顶元素，并调整堆。
   - 最终，堆顶元素（取反后）即为第 K 小的元素。

### 时间和空间复杂度

- **时间复杂度**：
  - 插入元素和调整堆的时间复杂度为 O(log K)。
  - 遍历所有元素的时间复杂度为 O(N)，其中 N 是数组的长度。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的堆，空间复杂度为 O(K)。

通过上述方法，我们可以高效地找出数组中的第 K 大或第 K 小的元素。

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_value = min(nums)
        max_value = max(nums)
        count = [0] * (max_value - min_value + 1)

        for num in nums:
            count[num - min_value] += 1
        
        remain = k
        for num in range(len(count) -1, -1, -1):
            remain -= count[num]
            if remain <= 0:
                return num + min_value

        return -1

可以通过使用最小堆来解决这个问题，以避免直接对数组进行排序。以下是一个详细的解决方案，展示如何使用最小堆来找出数组中的第 K 大的元素。

### 解决方案

1. 使用一个大小为 K 的最小堆来存储当前找到的最大的 K 个元素。
2. 遍历数组中的每个元素：
   - 如果堆的大小小于 K，将当前元素添加到堆中。
   - 否则，如果当前元素大于堆顶元素，则替换堆顶元素，并调整堆。
3. 遍历结束后，堆顶元素即为数组中第 K 大的元素。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 使用一个最小堆来存储前 K 个最大的元素
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap 的堆顶元素即为第 K 大的元素
        return minHeap[0]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.findKthLargest(nums, k)
    print(f"数组中的第 {k} 大的元素是: {result}")  # 输出: 5
```

### 解释

1. **初始化最小堆**：
   - 使用 `heapq` 模块初始化一个空的最小堆 `minHeap`。

2. **遍历数组中的每个元素**：
   - 如果堆的大小小于 K，直接将元素添加到堆中。
   - 如果堆的大小等于 K，且当前元素大于堆顶元素，则使用 `heapreplace` 替换堆顶元素，并调整堆。

3. **返回结果**：
   - 遍历结束后，堆顶元素即为数组中第 K 大的元素。

### 时间和空间复杂度

- **时间复杂度**：
  - 插入元素和调整堆的时间复杂度为 O(log K)。
  - 遍历所有元素的时间复杂度为 O(N)，其中 N 是数组的长度。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的最小堆，空间复杂度为 O(K)。

这种方法高效且避免了对整个数组进行排序，通过维护一个大小为 K 的最小堆，我们可以快速找出数组中的第 K 大的元素。

要找到数组中出现频率最高的 K 个元素，可以使用堆数据结构来实现。具体步骤如下：

1. **统计每个元素的频率**：使用哈希表（字典）来统计每个元素出现的频率。
2. **使用最小堆来维护频率最高的 K 个元素**：通过将频率作为关键字构建一个大小为 K 的最小堆。
3. **返回结果**：遍历完所有元素后，堆中的元素即为频率最高的 K 个元素。

### 示例代码

```python
import heapq
from typing import List, Tuple
from collections import Counter

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 统计每个元素的频率
        frequency_map = Counter(nums)
        
        # 使用一个最小堆来存储频率最高的 K 个元素
        minHeap: List[Tuple[int, int]] = []
        
        for num, freq in frequency_map.items():
            if len(minHeap) < k:
                heapq.heappush(minHeap, (freq, num))
            else:
                if freq > minHeap[0][0]:
                    heapq.heapreplace(minHeap, (freq, num))
        
        # 提取堆中的元素
        return [num for freq, num in minHeap]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    nums = [1, 1, 1, 2, 2, 3]
    k = 2
    result = solution.topKFrequent(nums, k)
    print(f"数组中出现频率最高的 {k} 个元素是: {result}")  # 输出: [1, 2]

    nums = [4, 1, -1, 2, -1, 2, 3]
    k = 2
    result = solution.topKFrequent(nums, k)
    print(f"数组中出现频率最高的 {k} 个元素是: {result}")  # 输出: [-1, 2]，顺序可能不同
```

### 解释

1. **统计频率**：
   - 使用 `collections.Counter` 来统计数组中每个元素出现的频率，得到一个频率字典 `frequency_map`。

2. **使用最小堆维护频率最高的 K 个元素**：
   - 初始化一个空的最小堆 `minHeap`。
   - 遍历频率字典中的每个元素及其频率，如果堆的大小小于 K，则将元素及其频率推入堆中。
   - 如果堆的大小等于 K，且当前元素的频率大于堆顶元素的频率，则替换堆顶元素，并调整堆。

3. **返回结果**：
   - 遍历结束后，堆中的元素即为频率最高的 K 个元素。
   - 通过列表推导式提取堆中的元素，返回结果。

### 时间和空间复杂度

- **时间复杂度**：
  - 统计频率的时间复杂度为 O(N)，其中 N 是数组的长度。
  - 插入和调整堆的时间复杂度为 O(log K)。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的最小堆，空间复杂度为 O(K)。
  - 使用了频率字典，其空间复杂度为 O(N)（在最坏情况下，每个元素都是唯一的）。

通过上述方法，我们可以高效地找出数组中出现频率最高的 K 个元素。

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        
        while len(self.heap) > k:
            heapq.heappop(self.heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:

        def remove_largest():
            index_of_largest = stones.index(max(stones))
            # Remove largest stone
            return stones.pop(index_of_largest)

        while len(stones) > 1:
            stone_1 = remove_largest()
            stone_2 = remove_largest()
            if stone_1 != stone_2:
                stones.append(stone_1 - stone_2)

        return stones[0] if stones else 0

要解决这个问题，可以使用最大堆（Max Heap）。但是，由于Python的`heapq`模块默认只支持最小堆（Min Heap），我们可以通过对元素取反来模拟最大堆。

以下是详细的步骤和示例代码，展示如何使用堆来解决这个问题：

### 解决方案

1. **构建最大堆**：
   - 将所有石头的重量取反后放入最小堆中，这样我们就可以使用最小堆来模拟最大堆的行为。

2. **模拟石头碰撞**：
   - 反复从堆中取出两个最大元素（实际上是取反后的最小元素），模拟石头碰撞。
   - 根据碰撞结果更新石头重量，并将结果重新放入堆中。
   
3. **返回结果**：
   - 当堆中只剩一个或零个元素时，返回最后一个元素的重量（取反后的值），如果没有剩余元素，返回0。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        # 创建一个最大堆
        maxHeap = [-stone for stone in stones]
        heapq.heapify(maxHeap)

        # 模拟石头碰撞
        while len(maxHeap) > 1:
            # 取出两块最重的石头
            first = -heapq.heappop(maxHeap)
            second = -heapq.heappop(maxHeap)
            
            if first != second:
                # 如果两块石头重量不同，计算剩余重量并放回堆中
                heapq.heappush(maxHeap, -(first - second))
        
        # 如果堆中还有石头，返回其重量；否则返回0
        return -maxHeap[0] if maxHeap else 0

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    stones = [2, 7, 4, 1, 8, 1]
    result = solution.lastStoneWeight(stones)
    print(f"最后剩下的石头重量是: {result}")  # 输出: 1
```

### 解释

1. **构建最大堆**：
   - 将所有石头的重量取反后放入列表 `maxHeap` 中，然后使用 `heapq.heapify` 将列表转换为最小堆，这样我们就可以模拟最大堆的行为。

2. **模拟石头碰撞**：
   - 使用 `heapq.heappop` 从堆中取出两个最重的石头（实际上是取反后的最小元素），然后模拟碰撞。
   - 如果两块石头重量相同，则两块石头都被摧毁。
   - 如果两块石头重量不同，则计算剩余重量并将其重新放入堆中（取反后）。

3. **返回结果**：
   - 当堆中只剩一个或零个元素时，返回最后一个元素的重量（取反后的值），如果没有剩余元素，返回0。

### 时间和空间复杂度

- **时间复杂度**：
  - 构建堆的时间复杂度为 O(N)，其中 N 是石头的数量。
  - 每次碰撞操作的时间复杂度为 O(log N)。
  - 最坏情况下需要进行 N-1 次碰撞操作，因此总时间复杂度为 O(N log N)。

- **空间复杂度**：
  - 使用了一个大小为 N 的堆，空间复杂度为 O(N)。

通过上述方法，我们可以高效地解决这个问题，并找出最后剩下的石头重量。

要找到矩阵中最弱的 K 行，可以按照以下步骤进行：

1. **计算每行的士兵数量**：对于每一行，计算其中 `1` 的数量，这表示士兵的数量。
2. **将行索引和士兵数量结合起来**：将每一行的索引和对应的士兵数量存储在一个列表中。
3. **排序**：首先按照士兵数量排序，如果士兵数量相同则按行索引排序。
4. **返回前 K 个最弱的行索引**：从排序后的列表中提取前 K 个最弱的行的索引。

### 示例代码

```python
from typing import List

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # 计算每行的士兵数量并存储索引
        soldier_count = []
        for index, row in enumerate(mat):
            count = sum(row)
            soldier_count.append((count, index))
        
        # 根据士兵数量和行索引排序
        soldier_count.sort(key=lambda x: (x[0], x[1]))
        
        # 提取前 k 个最弱的行索引
        return [x[1] for x in soldier_count[:k]]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    mat = [
        [1, 1, 0, 0, 0],
        [1, 1, 1, 1, 0],
        [1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0],
        [1, 1, 1, 1, 1]
    ]
    k = 3
    result = solution.kWeakestRows(mat, k)
    print(f"矩阵中最弱的 {k} 行的索引是: {result}")  # 输出: [2, 0, 3]
```

### 解释

1. **计算每行的士兵数量**：
   - 遍历矩阵中的每一行，计算该行中 `1` 的数量。
   - 将每行的士兵数量和行索引存储在一个元组列表中，例如 `[(2, 0), (4, 1), (1, 2)]`，其中第一个元素是士兵数量，第二个元素是行索引。

2. **排序**：
   - 使用 `sort` 方法对元组列表进行排序。排序的主键是士兵数量，如果士兵数量相同，则按行索引排序。

3. **提取前 K 个最弱的行索引**：
   - 从排序后的列表中提取前 K 个最弱的行的索引，返回这些索引作为结果。

### 时间和空间复杂度

- **时间复杂度**：
  - 计算士兵数量的时间复杂度为 O(m * n)，其中 m 是矩阵的行数，n 是列数。
  - 排序的时间复杂度为 O(m log m)。
  - 总时间复杂度为 O(m * n + m log m)。

- **空间复杂度**：
  - 使用了额外的空间来存储士兵数量和行索引，空间复杂度为 O(m)。

这种方法高效且易于理解，可以用来快速找到矩阵中最弱的 K 行。

要在一个按行和列排序的 n x n 矩阵中找到第 k 小的元素，可以使用以下方法：

1. **使用最小堆**：将每行的第一个元素放入最小堆中。每次从堆中取出最小元素，然后将该元素所在行的下一个元素加入堆中。重复这一过程 k 次，堆顶元素即为第 k 小的元素。

2. **二分查找**：由于矩阵中的每一行和每一列都是排序的，我们可以使用二分查找的方法来定位第 k 小的元素。

### 方法一：使用最小堆

#### 详细步骤：
1. 创建一个大小为 k 的最小堆。
2. 将每行的第一个元素添加到最小堆中。
3. 重复 k 次从堆中取出最小元素，并将该元素所在行的下一个元素加入堆中。
4. 第 k 次取出的元素即为第 k 小的元素。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        # 最小堆，存储元素和元素的位置（row, col）
        minHeap = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(minHeap)
        
        # 进行 k 次取堆顶元素的操作
        for _ in range(k - 1):
            element, row, col = heapq.heappop(minHeap)
            if col + 1 < n:
                heapq.heappush(minHeap, (matrix[row][col + 1], row, col + 1))
        
        # 第 k 次取出的堆顶元素即为第 k 小的元素
        return heapq.heappop(minHeap)[0]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    matrix = [
        [1, 5, 9],
        [10, 11, 13],
        [12, 13, 15]
    ]
    k = 8
    result = solution.kthSmallest(matrix, k)
    print(f"矩阵中第 {k} 小的元素是: {result}")  # 输出: 13
```

### 方法二：二分查找

#### 详细步骤：
1. 使用矩阵的最小值和最大值来定义二分查找的范围。
2. 在范围内进行二分查找，每次猜一个中间值 mid，然后统计矩阵中小于等于 mid 的元素个数。
3. 根据统计结果调整查找范围，直到找到第 k 小的元素。

### 示例代码

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        
        def countLessEqual(mid):
            count = 0
            row, col = n - 1, 0
            while row >= 0 and col < n:
                if matrix[row][col] <= mid:
                    count += row + 1
                    col += 1
                else:
                    row -= 1
            return count
        
        left, right = matrix[0][0], matrix[n - 1][n - 1]
        while left < right:
            mid = (left + right) // 2
            if countLessEqual(mid) < k:
                left = mid + 1
            else:
                right = mid
        
        return left

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    matrix = [
        [1, 5, 9],
        [10, 11, 13],
        [12, 13, 15]
    ]
    k = 8
    result = solution.kthSmallest(matrix, k)
    print(f"矩阵中第 {k} 小的元素是: {result}")  # 输出: 13
```

### 解释

1. **使用最小堆的方法**：
   - 初始时将每行的第一个元素放入最小堆。
   - 每次从堆中取出最小元素，将该元素所在行的下一个元素加入堆。
   - 重复这一过程 k 次，第 k 次取出的元素即为第 k 小的元素。

2. **使用二分查找的方法**：
   - 在矩阵的最小值和最大值范围内进行二分查找。
   - 每次猜一个中间值 mid，统计矩阵中小于等于 mid 的元素个数。
   - 根据统计结果调整查找范围，直到找到第 k 小的元素。

### 时间和空间复杂度

1. **最小堆方法**：
   - 时间复杂度：O(k log n)
   - 空间复杂度：O(n)

2. **二分查找方法**：
   - 时间复杂度：O(n log(max - min))
   - 空间复杂度：O(1)

这两种方法都可以有效地解决这个问题，其中二分查找方法的空间复杂度更优。

要解决这个问题，可以使用基于最小堆的贪心算法。核心思想是保持跟踪所有正在进行的会议，并在需要时分配新的会议室。具体步骤如下：

1. **将会议时间区间按开始时间排序**。
2. **使用最小堆追踪当前会议的结束时间**。
3. **遍历所有会议时间区间**：
   - 如果最小堆中的最早结束时间小于或等于当前会议的开始时间，说明当前会议可以复用该会议室，因此将最小堆中的最早结束时间弹出。
   - 将当前会议的结束时间加入最小堆。
4. **最小堆的大小即为所需的最少会议室数量**。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        # 按照会议的开始时间进行排序
        intervals.sort(key=lambda x: x[0])
        
        # 初始化一个最小堆
        minHeap = []
        
        # 将第一个会议的结束时间加入最小堆
        heapq.heappush(minHeap, intervals[0][1])
        
        # 遍历剩余的会议时间区间
        for i in range(1, len(intervals)):
            # 如果最早的结束时间小于或等于当前会议的开始时间，弹出最早的结束时间
            if minHeap[0] <= intervals[i][0]:
                heapq.heappop(minHeap)
            
            # 将当前会议的结束时间加入最小堆
            heapq.heappush(minHeap, intervals[i][1])
        
        # 最小堆的大小即为所需的会议室数量
        return len(minHeap)

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    intervals = [[0, 30], [5, 10], [15, 20]]
    result = solution.minMeetingRooms(intervals)
    print(f"所需的最少会议室数量是: {result}")  # 输出: 2
    
    intervals = [[7, 10], [2, 4]]
    result = solution.minMeetingRooms(intervals)
    print(f"所需的最少会议室数量是: {result}")  # 输出: 1
```

### 解释

1. **排序会议时间区间**：
   - 使用 `sort` 函数按会议的开始时间对所有会议时间区间进行排序。

2. **使用最小堆追踪会议结束时间**：
   - 初始化一个空的最小堆。
   - 将第一个会议的结束时间加入最小堆。

3. **遍历所有会议时间区间**：
   - 对于每个会议，如果当前会议的开始时间大于或等于最小堆中的最早结束时间，说明当前会议可以使用同一个会议室。因此，将最小堆中的最早结束时间弹出。
   - 将当前会议的结束时间加入最小堆。

4. **返回最小堆的大小**：
   - 最小堆的大小即为所需的最少会议室数量，因为堆中存储了所有当前正在进行的会议的结束时间。

### 时间和空间复杂度

- **时间复杂度**：
  - 排序时间复杂度为 O(N log N)，其中 N 是会议时间区间的数量。
  - 遍历所有会议时间区间并维护最小堆的时间复杂度为 O(N log N)。
  - 总时间复杂度为 O(N log N)。

- **空间复杂度**：
  - 最小堆的空间复杂度为 O(N)，因为在最坏情况下，所有会议都可能需要独立的会议室。

这种方法高效且易于实现，可以用来解决需要找到最少会议室数量的问题。

要找到距离原点最近的 K 个点，可以使用最大堆（Max Heap）来高效地解决这个问题。核心思想是使用一个大小为 K 的最大堆来维护当前找到的距离原点最近的 K 个点。

### 解决方案

1. **计算每个点到原点的距离**：
   - 使用欧几里得距离，但由于我们只关心相对距离，可以忽略平方根，直接比较平方的距离。

2. **使用最大堆维护 K 个最近的点**：
   - 如果堆的大小小于 K，将当前点加入堆中。
   - 如果堆的大小等于 K，且当前点距离小于堆顶点的距离，则替换堆顶点，并调整堆。

3. **返回结果**：
   - 堆中的点即为距离原点最近的 K 个点。

### 示例代码

```python
import heapq
from typing import List, Tuple

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        # 定义一个最大堆
        maxHeap: List[Tuple[int, int, int]] = []
        
        for (x, y) in points:
            dist = -(x * x + y * y)  # 计算距离的平方并取负数，以便使用最小堆模拟最大堆
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, (dist, x, y))
            else:
                if dist > maxHeap[0][0]:
                    heapq.heappop(maxHeap)
                    heapq.heappush(maxHeap, (dist, x, y))
        
        # 从堆中取出 k 个最近的点
        return [(x, y) for (dist, x, y) in maxHeap]

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    points = [[1, 3], [-2, 2], [5, 8], [0, 1]]
    k = 2
    result = solution.kClosest(points, k)
    print(f"距离原点最近的 {k} 个点是: {result}")  # 输出: [[-2, 2], [0, 1]]，顺序可能不同
    
    points = [[3, 3], [5, -1], [-2, 4]]
    k = 2
    result = solution.kClosest(points, k)
    print(f"距离原点最近的 {k} 个点是: {result}")  # 输出: [[3, 3], [-2, 4]]，顺序可能不同
```

### 解释

1. **计算每个点到原点的距离**：
   - 计算点 (x, y) 到原点的距离平方 `x*x + y*y`。为了方便使用最小堆来模拟最大堆，取负数存储距离平方。

2. **使用最大堆维护 K 个最近的点**：
   - 初始化一个空的最大堆 `maxHeap`。
   - 遍历所有点，对于每个点，如果堆的大小小于 K，直接将点加入堆中。
   - 如果堆的大小等于 K，且当前点的距离小于堆顶点的距离，则弹出堆顶点，并将当前点加入堆中。

3. **返回结果**：
   - 堆中的点即为距离原点最近的 K 个点。通过列表推导式从堆中提取点并返回结果。

### 时间和空间复杂度

- **时间复杂度**：
  - 插入和调整堆的时间复杂度为 O(log K)。
  - 遍历所有点的时间复杂度为 O(N)，其中 N 是点的数量。
  - 总时间复杂度为 O(N log K)。

- **空间复杂度**：
  - 使用了大小为 K 的最大堆，空间复杂度为 O(K)。

这种方法高效且适用于需要找到距离原点最近的 K 个点的问题。

要解决这个问题，可以使用贪心算法和最小堆（Min Heap）来高效地找到最小的合并成本。每次总是选择最短的两根木棍进行合并，以确保每次合并的成本最小。

### 解决方案

1. **初始化最小堆**：将所有木棍的长度放入最小堆中。
2. **合并木棍**：重复以下步骤直到堆中只剩一根木棍：
   - 从堆中取出两根最短的木棍。
   - 计算合并这两根木棍的成本，并将成本加入总成本中。
   - 将合并后的新木棍放回堆中。
3. **返回总成本**：当堆中只剩一根木棍时，总成本即为最小合并成本。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def connectSticks(self, sticks: List[int]) -> int:
        if len(sticks) == 1:
            return 0
        
        # 初始化最小堆
        heapq.heapify(sticks)
        
        total_cost = 0
        
        while len(sticks) > 1:
            # 取出两根最短的木棍
            first = heapq.heappop(sticks)
            second = heapq.heappop(sticks)
            
            # 计算合并成本
            cost = first + second
            total_cost += cost
            
            # 将合并后的新木棍放回堆中
            heapq.heappush(sticks, cost)
        
        return total_cost

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    sticks = [2, 4, 3]
    result = solution.connectSticks(sticks)
    print(f"合并所有木棍的最小成本是: {result}")  # 输出: 14
    
    sticks = [1, 8, 3, 5]
    result = solution.connectSticks(sticks)
    print(f"合并所有木棍的最小成本是: {result}")  # 输出: 30
```

### 解释

1. **初始化最小堆**：
   - 使用 `heapq.heapify` 将木棍数组转换为最小堆。

2. **合并木棍**：
   - 使用 `heapq.heappop` 从堆中取出两根最短的木棍。
   - 计算合并这两根木棍的成本，并将其加入总成本。
   - 使用 `heapq.heappush` 将合并后的新木棍放回堆中。
   - 重复以上步骤直到堆中只剩一根木棍。

3. **返回总成本**：
   - 当堆中只剩一根木棍时，总成本即为最小合并成本。

### 时间和空间复杂度

- **时间复杂度**：
  - 构建最小堆的时间复杂度为 O(N)，其中 N 是木棍的数量。
  - 每次合并操作的时间复杂度为 O(log N)。
  - 最多需要进行 N-1 次合并操作，因此总时间复杂度为 O(N log N)。

- **空间复杂度**：
  - 最小堆的空间复杂度为 O(N)。

通过上述方法，我们可以高效地找到合并所有木棍的最小成本。

要解决这个问题，可以使用贪心算法结合最小堆来高效地决定何时使用梯子和砖块。具体步骤如下：

1. **优先使用梯子**：对于每次高度的增加，优先使用梯子。这样可以在高度增加较大的时候灵活使用砖块。
2. **记录所有高度增加值**：使用最小堆记录所有的高度增加值。
3. **当梯子用完时，考虑使用砖块**：如果梯子不够用了，则用最小的高度增加值来替代一个梯子，用砖块填补这个高度差。
4. **判断是否能继续前进**：如果砖块也不够用了，则返回当前能到达的最远建筑索引。

### 示例代码

```python
import heapq
from typing import List

class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        # 最小堆，用于记录使用梯子的高度差
        heap = []
        
        for i in range(len(heights) - 1):
            diff = heights[i + 1] - heights[i]
            
            # 如果当前建筑的高度不高于下一个建筑，则不需要梯子或砖块
            if diff > 0:
                heapq.heappush(heap, diff)
            
            # 如果梯子不够用，使用砖块填补最小的高度差
            if len(heap) > ladders:
                bricks -= heapq.heappop(heap)
            
            # 如果砖块也不够用，返回当前能到达的最远建筑索引
            if bricks < 0:
                return i
        
        # 如果砖块足够用，返回最后一个建筑索引
        return len(heights) - 1

# 示例用法
if __name__ == "__main__":
    solution = Solution()
    
    heights = [4, 2, 7, 6, 9, 14, 12]
    bricks = 5
    ladders = 1
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"能到达的最远建筑索引是: {result}")  # 输出: 4
    
    heights = [4, 12, 2, 7, 3, 18, 20, 3, 19]
    bricks = 10
    ladders = 2
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"能到达的最远建筑索引是: {result}")  # 输出: 7
    
    heights = [14, 3, 19, 3]
    bricks = 17
    ladders = 0
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"能到达的最远建筑索引是: {result}")  # 输出: 3
```

### 解释

1. **优先使用梯子**：
   - 使用 `heapq.heappush(heap, diff)` 将每次高度增加值加入最小堆。

2. **考虑使用砖块**：
   - 当梯子的数量不足以覆盖所有高度增加时，使用最小堆中的最小高度差值，用砖块来填补这个差值。
   - `bricks -= heapq.heappop(heap)` 从最小堆中取出最小的高度差值并用砖块填补。

3. **判断是否能继续前进**：
   - 如果砖块数量不足以填补最小的高度差，则返回当前能到达的最远建筑索引。
   - 如果砖块足够用，继续前进，直到最后一个建筑。

### 时间和空间复杂度

- **时间复杂度**：
  - 遍历建筑的时间复杂度为 O(N)，其中 N 是建筑的数量。
  - 维护最小堆的时间复杂度为 O(log L)，其中 L 是梯子的数量。
  - 总时间复杂度为 O(N log L)。

- **空间复杂度**：
  - 使用了大小为 L 的最小堆，空间复杂度为 O(L)。

通过上述方法，我们可以高效地决定何时使用梯子和砖块，并找到能到达的最远建筑索引。

要实现一个能够从数据流中找到中位数的类 `MedianFinder`，我们可以使用两个堆：一个最大堆和一个最小堆。这样我们可以高效地维护数据流中的中位数。

具体思路是：
- 使用最大堆来存储较小的一半数据。
- 使用最小堆来存储较大的一半数据。
- 通过平衡两个堆的大小，我们可以很容易地找到中位数。

### 具体步骤：
1. **初始化**：创建两个堆，最大堆用于存储较小的一半数据，最小堆用于存储较大的一半数据。
2. **添加数据**：
   - 将新的数字添加到最大堆。
   - 如果最大堆的最大元素大于最小堆的最小元素，将最大堆的最大元素移动到最小堆。
   - 如果最大堆的大小超过最小堆，则将最大堆的最大元素移动到最小堆，以保持平衡。
3. **查找中位数**：
   - 如果两个堆的大小相等，中位数就是两个堆顶元素的平均值。
   - 如果最大堆的大小大于最小堆，中位数就是最大堆的堆顶元素。

### 示例代码：

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.maxHeap = []  # 最大堆，存储较小的一半数据
        self.minHeap = []  # 最小堆，存储较大的一半数据

    def addNum(self, num: int) -> None:
        # 将新数字添加到最大堆
        heapq.heappush(self.maxHeap, -num)
        
        # 如果最大堆的最大元素大于最小堆的最小元素，则需要调整
        if self.maxHeap and self.minHeap and (-self.maxHeap[0] > self.minHeap[0]):
            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))
        
        # 平衡两个堆的大小
        if len(self.maxHeap) > len(self.minHeap) + 1:
            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))
        elif len(self.minHeap) > len(self.maxHeap):
            heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))

    def findMedian(self) -> float:
        # 如果两个堆的大小相等，中位数是两个堆顶元素的平均值
        if len(self.maxHeap) == len(self.minHeap):
            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0
        # 如果最大堆的大小大于最小堆，中位数是最大堆的堆顶元素
        return -self.maxHeap[0]

# 示例用法
if __name__ == "__main__":
    medianFinder = MedianFinder()
    medianFinder.addNum(1)
    medianFinder.addNum(2)
    print(f"中位数是: {medianFinder.findMedian()}")  # 输出: 1.5
    medianFinder.addNum(3)
    print(f"中位数是: {medianFinder.findMedian()}")  # 输出: 2
```

### 解释
1. **初始化**：创建两个堆，一个最大堆 `maxHeap` 用于存储较小的一半数据，一个最小堆 `minHeap` 用于存储较大的一半数据。
2. **添加数据**：
   - 首先将新数字添加到最大堆。
   - 如果最大堆的最大元素大于最小堆的最小元素，调整两个堆以保持平衡。
   - 如果最大堆的大小超过最小堆一个以上，将最大堆的最大元素移动到最小堆。
3. **查找中位数**：
   - 如果两个堆的大小相等，中位数是两个堆顶元素的平均值。
   - 如果最大堆的大小大于最小堆，中位数是最大堆的堆顶元素。

### 时间和空间复杂度
- **时间复杂度**：
  - 添加数据的时间复杂度为 O(log N)。
  - 查找中位数的时间复杂度为 O(1)。
- **空间复杂度**：
  - 空间复杂度为 O(N)，用于存储数据流中的所有元素。

这种方法高效且适用于实时数据流中查找中位数的问题。

