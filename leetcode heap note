https://leetcode.com/explore/learn/card/heap/646/practices/4092/


Definition and Classification of HeapReport Issue

Priority Queues
Before introducing a Heap, let's first talk about a Priority Queue.
Wikipedia: a priority queue is anÂ abstract data typeÂ similar to a regularÂ queueÂ orÂ stackÂ data structure in which each element additionally has a "priority" associated with it. In a priority queue, an element with high priority is served before an element with low priority.
In daily life, we would assign different priorities to tasks, start working on the task with the highest priority and then proceed to the task with the second highest priority. This is an example of a Priority Queue.
A common misconception is that a Heap is the same as a Priority Queue, which is not true. A priority queue is an abstract data type, while a Heap is a data structure. Therefore, a Heap is not a Priority Queue, but a way to implement a Priority Queue.
There are multiple ways to implement a Priority Queue, such as array and linked list. However, these implementations only guaranteeÂ ğ‘‚(1)O(1)Â time complexity for either insertion or deletion, while the other operation will have a time complexity ofÂ ğ‘‚(ğ‘)O(N). On the other hand, implementing the priority queue with Heap will allow both insertion and deletion to have a time complexity ofÂ ğ‘‚(logâ¡ğ‘)O(logN). So, what is a Heap?
In this chapter, we will learn to:
1.Understand the Heap data structure.
2.Understand Max Heap and Min Heap.
3.Understand the insertion and deletion of a Heap.
4.Implement a Heap.

Definition of Heap
According to Wikipedia, aÂ HeapÂ is a special type of binary tree. A heap is a binary tree that meets the following criteria:
ï‚·Is aÂ complete binary tree;
ï‚·The value of each node must beÂ no greater than (or no less than)Â the value of its child nodes.
A Heap has the following properties:
ï‚·Insertion of an element into the Heap has a time complexity ofÂ ğ‘‚(logâ¡ğ‘)O(logN);
ï‚·Deletion of an element from the Heap has a time complexity ofÂ ğ‘‚(logâ¡ğ‘)O(logN);
ï‚·The maximum/minimum value in the Heap can be obtained withÂ ğ‘‚(1)O(1)Â time complexity.

Classification of Heap
There are two kinds of heaps:Â Max HeapÂ andÂ Min Heap.
ï‚·
Max Heap: Each node in the Heap has a valueÂ no less thanÂ its child nodes. Therefore, the top element (root node) has theÂ largestÂ value in the Heap.
ï‚·
ï‚·
Min Heap: Each node in the Heap has a valueÂ no larger thanÂ its child nodes. Therefore, the top element (root node) has theÂ smallestÂ value in the Heap.
ï‚·


Heap insertion is a process of adding a new element to a heap while maintaining the heap property. Heaps can be either max-heaps or min-heaps. In a max-heap, the key at a parent node is always greater than or equal to the keys of its children, and in a min-heap, the key at a parent node is always less than or equal to the keys of its children. Below is the step-by-step process of inserting a new element into a heap.

### Steps for Heap Insertion:

#### 1. Add the new element to the end of the heap:
- Insert the new element at the last position in the heap (the next available leaf position).

#### 2. Restore the heap property (heapify-up or bubble-up):
- Compare the newly added element with its parent.
- If the new element violates the heap property (is greater than its parent in a max-heap, or smaller than its parent in a min-heap), swap it with its parent.
- Repeat this process until the heap property is restored or the element becomes the root of the heap.

### Example:

Let's illustrate heap insertion with an example using a max-heap.

#### Initial Max-Heap:
```
         10
       /    \
      9      8
     / \    /
    7   6  5
```

#### Insert a new element, say 11:
1. Add 11 to the end of the heap:
```
         10
       /    \
      9      8
     / \    / \
    7   6  5  11
```

2. Restore the heap property:
   - Compare 11 with its parent (8).
   - Since 11 > 8, swap them.
```
         10
       /    \
      9     11
     / \    / \
    7   6  5   8
```

   - Compare 11 with its new parent (10).
   - Since 11 > 10, swap them.
```
         11
       /    \
      9     10
     / \    / \
    7   6  5   8
```

Now the heap property is restored.

### Pseudocode for Heap Insertion in a Max-Heap:

```python
def heap_insert(heap, element):
    # Add the new element to the end of the heap
    heap.append(element)
    index = len(heap) - 1
    
    # Heapify-up process
    while index > 0:
        parent_index = (index - 1) // 2
        if heap[index] > heap[parent_index]:
            # Swap the current element with its parent
            heap[index], heap[parent_index] = heap[parent_index], heap[index]
            # Move up to the parent index
            index = parent_index
        else:
            break
```

### Complexity:
- The time complexity of heap insertion is \(O(\log n)\), where \(n\) is the number of elements in the heap. This is because in the worst case, we may need to traverse from the leaf to the root, which is proportional to the height of the heap, and the height of a complete binary tree (heap) is \(\log n\).

Heap insertion ensures that the heap structure remains valid, preserving the heap property with each new element added.

Heap insertion is a process of adding a new element to a heap while maintaining the heap property. Heaps can be either max-heaps or min-heaps. In a max-heap, the key at a parent node is always greater than or equal to the keys of its children, and in a min-heap, the key at a parent node is always less than or equal to the keys of its children. Below is the step-by-step process of inserting a new element into a heap.

### Steps for Heap Insertion:

#### 1. Add the new element to the end of the heap:
- Insert the new element at the last position in the heap (the next available leaf position).

#### 2. Restore the heap property (heapify-up or bubble-up):
- Compare the newly added element with its parent.
- If the new element violates the heap property (is greater than its parent in a max-heap, or smaller than its parent in a min-heap), swap it with its parent.
- Repeat this process until the heap property is restored or the element becomes the root of the heap.

### Example:

Let's illustrate heap insertion with an example using a max-heap.

#### Initial Max-Heap:
```
         10
       /    \
      9      8
     / \    /
    7   6  5
```

#### Insert a new element, say 11:
1. Add 11 to the end of the heap:
```
         10
       /    \
      9      8
     / \    / \
    7   6  5  11
```

2. Restore the heap property:
   - Compare 11 with its parent (8).
   - Since 11 > 8, swap them.
```
         10
       /    \
      9     11
     / \    / \
    7   6  5   8
```

   - Compare 11 with its new parent (10).
   - Since 11 > 10, swap them.
```
         11
       /    \
      9     10
     / \    / \
    7   6  5   8
```

Now the heap property is restored.

### Pseudocode for Heap Insertion in a Max-Heap:

```python
def heap_insert(heap, element):
    # Add the new element to the end of the heap
    heap.append(element)
    index = len(heap) - 1
    
    # Heapify-up process
    while index > 0:
        parent_index = (index - 1) // 2
        if heap[index] > heap[parent_index]:
            # Swap the current element with its parent
            heap[index], heap[parent_index] = heap[parent_index], heap[index]
            # Move up to the parent index
            index = parent_index
        else:
            break
```

### Complexity:
- The time complexity of heap insertion is \(O(\log n)\), where \(n\) is the number of elements in the heap. This is because in the worst case, we may need to traverse from the leaf to the root, which is proportional to the height of the heap, and the height of a complete binary tree (heap) is \(\log n\).

Heap insertion ensures that the heap structure remains valid, preserving the heap property with each new element added.

ä¸‹é¢æ˜¯å®ç°ä¸€ä¸ªæœ€å°å †ï¼ˆMin Heapï¼‰çš„ä»£ç ï¼Œå¹¶é™„æœ‰ä¸­æ–‡è§£é‡Šï¼š

```python
class MinHeap:
    def __init__(self, heapSize):
        # åˆ›å»ºä¸€ä¸ªä½¿ç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘
        # ç„¶åä½¿ç”¨äºŒå‰æ ‘æ„å»ºä¸€ä¸ªå †
        self.heapSize = heapSize
        # åœ¨å®ä¾‹åŒ–æ•°ç»„æ—¶éœ€è¦è®°å½•å…ƒç´ æ•°é‡
        # heapSize è®°å½•æ•°ç»„çš„å¤§å°
        self.minheap = [0] * (heapSize + 1)
        # realSize è®°å½•å †ä¸­å…ƒç´ çš„å®é™…æ•°é‡
        self.realSize = 0

    # æ·»åŠ å…ƒç´ çš„æ–¹æ³•
    def add(self, element):
        self.realSize += 1
        # å¦‚æœå †ä¸­çš„å…ƒç´ æ•°é‡è¶…è¿‡äº†é¢„è®¾çš„å †å¤§å°
        # æ‰“å°â€œæ·»åŠ äº†å¤ªå¤šå…ƒç´ â€å¹¶è¿”å›
        if self.realSize > self.heapSize:
            print("Added too many elements!")
            self.realSize -= 1
            return
        # å°†å…ƒç´ æ·»åŠ åˆ°æ•°ç»„ä¸­
        self.minheap[self.realSize] = element
        # æ–°æ·»åŠ å…ƒç´ çš„ç´¢å¼•
        index = self.realSize
        # æ–°æ·»åŠ å…ƒç´ çš„çˆ¶èŠ‚ç‚¹
        # å¦‚æœæˆ‘ä»¬ç”¨æ•°ç»„è¡¨ç¤ºå®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶å°†æ ¹èŠ‚ç‚¹å­˜å‚¨åœ¨ç´¢å¼• 1 å¤„
        # ä»»ä½•èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• / 2]
        # å·¦å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• * 2]
        # å³å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• * 2 + 1]
        parent = index // 2
        # å¦‚æœæ–°æ·»åŠ çš„å…ƒç´ å°äºå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œ
        # åˆ™å…¶å€¼å°†ä¸çˆ¶èŠ‚ç‚¹çš„å€¼äº¤æ¢
        while (self.minheap[index] < self.minheap[parent] and index > 1):
            self.minheap[parent], self.minheap[index] = self.minheap[index], self.minheap[parent]
            index = parent
            parent = index // 2
    
    # è·å–å †é¡¶å…ƒç´ 
    def peek(self):
        return self.minheap[1]
    
    # åˆ é™¤å †é¡¶å…ƒç´ 
    def pop(self):
        # å¦‚æœå½“å‰å †ä¸­çš„å…ƒç´ æ•°é‡ä¸º 0ï¼Œ
        # æ‰“å°â€œæ²¡æœ‰ä»»ä½•å…ƒç´ â€å¹¶è¿”å›é»˜è®¤å€¼
        if self.realSize < 1:
            print("Don't have any element!")
            return sys.maxsize
        else:
            # å½“å †ä¸­è¿˜æœ‰å…ƒç´ æ—¶
            # self.realSize >= 1
            removeElement = self.minheap[1]
            # å°†å †ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ æ”¾åˆ°å †é¡¶
            self.minheap[1] = self.minheap[self.realSize]
            self.realSize -= 1
            index = 1
            # å½“åˆ é™¤çš„å…ƒç´ ä¸æ˜¯å¶å­èŠ‚ç‚¹æ—¶
            while (index <= self.realSize // 2):
                # åˆ é™¤å…ƒç´ çš„å·¦å­èŠ‚ç‚¹
                left = index * 2
                # åˆ é™¤å…ƒç´ çš„å³å­èŠ‚ç‚¹
                right = (index * 2) + 1
                # å¦‚æœåˆ é™¤çš„å…ƒç´ å¤§äºå·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹
                # åˆ™å…¶å€¼éœ€è¦ä¸å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹ä¸­è¾ƒå°çš„å€¼äº¤æ¢
                if (self.minheap[index] > self.minheap[left] or self.minheap[index] > self.minheap[right]):
                    if self.minheap[left] < self.minheap[right]:
                        self.minheap[left], self.minheap[index] = self.minheap[index], self.minheap[left]
                        index = left
                    else:
                        self.minheap[right], self.minheap[index] = self.minheap[index], self.minheap[right]
                        index = right
                else:
                    break
            return removeElement
    
    # è¿”å›å †ä¸­çš„å…ƒç´ æ•°é‡
    def size(self):
        return self.realSize
    
    def __str__(self):
        return str(self.minheap[1 : self.realSize + 1])
        

if __name__ == "__main__":
    # æµ‹è¯•ç”¨ä¾‹
    minHeap = MinHeap(5)
    minHeap.add(3)
    minHeap.add(1)
    minHeap.add(2)
    # è¾“å‡º [1,3,2]
    print(minHeap)
    # è¾“å‡º 1
    print(minHeap.peek())
    # è¾“å‡º 1
    print(minHeap.pop())
    # è¾“å‡º 2
    print(minHeap.pop())
    # è¾“å‡º 3
    print(minHeap.pop())
    minHeap.add(4)
    minHeap.add(5)
    # è¾“å‡º [4,5]
    print(minHeap)
```

### ä»£ç è§£é‡Š
- **ç±»åˆå§‹åŒ– (`__init__`)**ï¼šåˆå§‹åŒ–å †çš„å¤§å°ã€å­˜å‚¨å †å…ƒç´ çš„æ•°ç»„ä»¥åŠå®é™…å…ƒç´ æ•°é‡ã€‚
- **æ·»åŠ å…ƒç´  (`add`)**ï¼šå‘å †ä¸­æ·»åŠ å…ƒç´ ï¼Œå¹¶ç¡®ä¿å †çš„æ€§è´¨ä¸å˜ã€‚å¦‚æœæ·»åŠ çš„å…ƒç´ æ•°é‡è¶…è¿‡äº†å †çš„å®¹é‡ï¼Œä¼šç»™å‡ºè­¦å‘Šä¿¡æ¯ã€‚
- **è·å–å †é¡¶å…ƒç´  (`peek`)**ï¼šè¿”å›å †é¡¶å…ƒç´ ï¼ˆå³æœ€å°å…ƒç´ ï¼‰ã€‚
- **åˆ é™¤å †é¡¶å…ƒç´  (`pop`)**ï¼šåˆ é™¤å¹¶è¿”å›å †é¡¶å…ƒç´ ï¼Œç„¶åè°ƒæ•´å †ä»¥ç»´æŒæœ€å°å †æ€§è´¨ã€‚
- **è·å–å †ä¸­å…ƒç´ æ•°é‡ (`size`)**ï¼šè¿”å›å †ä¸­çš„å®é™…å…ƒç´ æ•°é‡ã€‚
- **å­—ç¬¦ä¸²è¡¨ç¤º (`__str__`)**ï¼šè¿”å›å †çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œä»…æ˜¾ç¤ºå®é™…å­˜åœ¨çš„å…ƒç´ ã€‚

### æµ‹è¯•ç”¨ä¾‹
é€šè¿‡å‡ ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå¯ä»¥éªŒè¯æœ€å°å †çš„åŠŸèƒ½æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æ·»åŠ å…ƒç´ ã€è·å–å †é¡¶å…ƒç´ ã€åˆ é™¤å †é¡¶å…ƒç´ ç­‰æ“ä½œã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªæœ€å¤§å †ï¼ˆMax Heapï¼‰çš„å®ç°ä»£ç ï¼Œå¹¶é™„æœ‰ä¸­æ–‡è§£é‡Šï¼š

```python
class MaxHeap:
    def __init__(self, heapSize):
        # åˆ›å»ºä¸€ä¸ªä½¿ç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘
        # ç„¶åä½¿ç”¨äºŒå‰æ ‘æ„å»ºä¸€ä¸ªå †
        self.heapSize = heapSize
        # åœ¨å®ä¾‹åŒ–æ•°ç»„æ—¶éœ€è¦è®°å½•å…ƒç´ æ•°é‡
        # heapSize è®°å½•æ•°ç»„çš„å¤§å°
        self.maxheap = [0] * (heapSize + 1)
        # realSize è®°å½•å †ä¸­å…ƒç´ çš„å®é™…æ•°é‡
        self.realSize = 0

    # æ·»åŠ å…ƒç´ çš„æ–¹æ³•
    def add(self, element):
        self.realSize += 1
        # å¦‚æœå †ä¸­çš„å…ƒç´ æ•°é‡è¶…è¿‡äº†é¢„è®¾çš„å †å¤§å°
        # æ‰“å°â€œæ·»åŠ äº†å¤ªå¤šå…ƒç´ â€å¹¶è¿”å›
        if self.realSize > self.heapSize:
            print("Added too many elements!")
            self.realSize -= 1
            return
        # å°†å…ƒç´ æ·»åŠ åˆ°æ•°ç»„ä¸­
        self.maxheap[self.realSize] = element
        # æ–°æ·»åŠ å…ƒç´ çš„ç´¢å¼•
        index = self.realSize
        # æ–°æ·»åŠ å…ƒç´ çš„çˆ¶èŠ‚ç‚¹
        # å¦‚æœæˆ‘ä»¬ç”¨æ•°ç»„è¡¨ç¤ºå®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶å°†æ ¹èŠ‚ç‚¹å­˜å‚¨åœ¨ç´¢å¼• 1 å¤„
        # ä»»ä½•èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• / 2]
        # å·¦å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• * 2]
        # å³å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º [èŠ‚ç‚¹ç´¢å¼• * 2 + 1]
        parent = index // 2
        
        # å¦‚æœæ–°æ·»åŠ çš„å…ƒç´ å¤§äºå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œ
        # åˆ™å…¶å€¼å°†ä¸çˆ¶èŠ‚ç‚¹çš„å€¼äº¤æ¢
        while (self.maxheap[index] > self.maxheap[parent] and index > 1):
            self.maxheap[parent], self.maxheap[index] = self.maxheap[index], self.maxheap[parent]
            index = parent
            parent = index // 2
            
    # è·å–å †é¡¶å…ƒç´ 
    def peek(self):
        return self.maxheap[1]
    
    # åˆ é™¤å †é¡¶å…ƒç´ 
    def pop(self):
        # å¦‚æœå½“å‰å †ä¸­çš„å…ƒç´ æ•°é‡ä¸º 0ï¼Œ
        # æ‰“å°â€œæ²¡æœ‰ä»»ä½•å…ƒç´ â€å¹¶è¿”å›é»˜è®¤å€¼
        if self.realSize < 1:
            print("Don't have any element!")
            return -sys.maxsize
        else:
            # å½“å †ä¸­è¿˜æœ‰å…ƒç´ æ—¶
            # self.realSize >= 1
            removeElement = self.maxheap[1]
            # å°†å †ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ æ”¾åˆ°å †é¡¶
            self.maxheap[1] = self.maxheap[self.realSize]
            self.realSize -= 1
            index = 1
            # å½“åˆ é™¤çš„å…ƒç´ ä¸æ˜¯å¶å­èŠ‚ç‚¹æ—¶
            while (index <= self.realSize // 2):
                # åˆ é™¤å…ƒç´ çš„å·¦å­èŠ‚ç‚¹
                left = index * 2
                # åˆ é™¤å…ƒç´ çš„å³å­èŠ‚ç‚¹
                right = (index * 2) + 1
                # å¦‚æœåˆ é™¤çš„å…ƒç´ å°äºå·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹
                # åˆ™å…¶å€¼éœ€è¦ä¸å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹ä¸­è¾ƒå¤§çš„å€¼äº¤æ¢
                if (self.maxheap[index] < self.maxheap[left] or self.maxheap[index] < self.maxheap[right]):
                    if self.maxheap[left] > self.maxheap[right]:
                        self.maxheap[left], self.maxheap[index] = self.maxheap[index], self.maxheap[left]
                        index = left
                    else:
                        self.maxheap[right], self.maxheap[index] = self.maxheap[index], self.maxheap[right]
                        index = right
                else:
                    break
            return removeElement
    
    # è¿”å›å †ä¸­çš„å…ƒç´ æ•°é‡
    def size(self):
        return self.realSize
    
    def __str__(self):
        return str(self.maxheap[1 : self.realSize + 1])
        

if __name__ == "__main__":
    # æµ‹è¯•ç”¨ä¾‹
    maxHeap = MaxHeap(5)
    maxHeap.add(1)
    maxHeap.add(2)
    maxHeap.add(3)
    # è¾“å‡º [3,1,2]
    print(maxHeap)
    # è¾“å‡º 3
    print(maxHeap.peek())
    # è¾“å‡º 3
    print(maxHeap.pop())
    # è¾“å‡º 2
    print(maxHeap.pop())
    # è¾“å‡º 1
    print(maxHeap.pop())
    maxHeap.add(4)
    maxHeap.add(5)
    # è¾“å‡º [5,4]
    print(maxHeap)
```

### ä»£ç è§£é‡Š
- **ç±»åˆå§‹åŒ– (`__init__`)**ï¼šåˆå§‹åŒ–å †çš„å¤§å°ã€å­˜å‚¨å †å…ƒç´ çš„æ•°ç»„ä»¥åŠå®é™…å…ƒç´ æ•°é‡ã€‚
- **æ·»åŠ å…ƒç´  (`add`)**ï¼šå‘å †ä¸­æ·»åŠ å…ƒç´ ï¼Œå¹¶ç¡®ä¿å †çš„æ€§è´¨ä¸å˜ã€‚å¦‚æœæ·»åŠ çš„å…ƒç´ æ•°é‡è¶…è¿‡äº†å †çš„å®¹é‡ï¼Œä¼šç»™å‡ºè­¦å‘Šä¿¡æ¯ã€‚
- **è·å–å †é¡¶å…ƒç´  (`peek`)**ï¼šè¿”å›å †é¡¶å…ƒç´ ï¼ˆå³æœ€å¤§å…ƒç´ ï¼‰ã€‚
- **åˆ é™¤å †é¡¶å…ƒç´  (`pop`)**ï¼šåˆ é™¤å¹¶è¿”å›å †é¡¶å…ƒç´ ï¼Œç„¶åè°ƒæ•´å †ä»¥ç»´æŒæœ€å¤§å †æ€§è´¨ã€‚
- **è·å–å †ä¸­å…ƒç´ æ•°é‡ (`size`)**ï¼šè¿”å›å †ä¸­çš„å®é™…å…ƒç´ æ•°é‡ã€‚
- **å­—ç¬¦ä¸²è¡¨ç¤º (`__str__`)**ï¼šè¿”å›å †çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œä»…æ˜¾ç¤ºå®é™…å­˜åœ¨çš„å…ƒç´ ã€‚

### æµ‹è¯•ç”¨ä¾‹
é€šè¿‡å‡ ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå¯ä»¥éªŒè¯æœ€å¤§å †çš„åŠŸèƒ½æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æ·»åŠ å…ƒç´ ã€è·å–å †é¡¶å…ƒç´ ã€åˆ é™¤å †é¡¶å…ƒç´ ç­‰æ“ä½œã€‚

ä½¿ç”¨ Python å†…ç½®çš„ `heapq` æ¨¡å—å¯ä»¥å¾ˆæ–¹ä¾¿åœ°æ„å»ºå’Œæ“ä½œæœ€å°å †ï¼ˆMin Heapï¼‰ã€‚ç”±äº Python çš„ `heapq` æ¨¡å—æ²¡æœ‰ç›´æ¥æ”¯æŒæœ€å¤§å †ï¼ˆMax Heapï¼‰çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹å…ƒç´ è¿›è¡Œå–åæ¥é—´æ¥å®ç°æœ€å¤§å †ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„ä»£ç è§£é‡Šå’Œç¤ºä¾‹ï¼š

### æ„å»ºä¸€ä¸ªç©ºçš„æœ€å°å †

```python
import heapq

# æ„å»ºä¸€ä¸ªç©ºçš„æœ€å°å †
minHeap = []
heapq.heapify(minHeap)
```

### æ„å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å †

ç”±äº Python æ²¡æœ‰ç›´æ¥æ”¯æŒæœ€å¤§å †çš„å†…éƒ¨å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹æ¯ä¸ªå…ƒç´ å–åæ¥é—´æ¥å®ç°æœ€å¤§å †ï¼š

```python
# æ„å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å †
# å› ä¸º Python æ²¡æœ‰ç›´æ¥æ”¯æŒæœ€å¤§å †çš„å†…éƒ¨å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ç›´æ¥æ„å»ºæœ€å¤§å †
```

### ä½¿ç”¨åˆå§‹å€¼æ„å»ºå †ï¼ˆHeapifyï¼‰

æˆ‘ä»¬å¯ä»¥é€šè¿‡ `heapify` å‡½æ•°å°†ä¸€ä¸ªåˆ—è¡¨è½¬æ¢ä¸ºä¸€ä¸ªæœ€å°å †ï¼š

```python
# ä½¿ç”¨åˆå§‹å€¼æ„å»ºå †ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸º "Heapify"
# è¿™ä¸ªå †æ˜¯ä¸€ä¸ªæœ€å°å †
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
```

### æ„å»ºä¸€ä¸ªæœ€å¤§å †çš„æŠ€å·§

ç”±äºæ²¡æœ‰ç›´æ¥æ„å»ºæœ€å¤§å †çš„å†…éƒ¨å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ¯ä¸ªå…ƒç´ ä¹˜ä»¥ -1ï¼Œç„¶åå¯¹è¿™äº›ä¿®æ”¹åçš„å…ƒç´ è¿›è¡Œ heapify æ“ä½œã€‚å †é¡¶å…ƒç´ å°†æ˜¯ä¿®æ”¹åçš„é›†åˆä¸­çš„æœ€å°å…ƒç´ ï¼Œä½†å¯ä»¥è½¬æ¢ä¸ºåŸå§‹æ•°æ®é›†ä¸­çš„æœ€å¤§å€¼ï¼š

```python
# æ„å»ºæœ€å¤§å †çš„æŠ€å·§
# ç”±äºæ²¡æœ‰ç›´æ¥æ„å»ºæœ€å¤§å †çš„å†…éƒ¨å‡½æ•°
# æˆ‘ä»¬å¯ä»¥å°†æ¯ä¸ªå…ƒç´ ä¹˜ä»¥ -1ï¼Œç„¶åå¯¹è¿™äº›ä¿®æ”¹åçš„å…ƒç´ è¿›è¡Œ heapify æ“ä½œ
# å †é¡¶å…ƒç´ å°†æ˜¯ä¿®æ”¹åçš„é›†åˆä¸­çš„æœ€å°å…ƒç´ ï¼Œä½†å¯ä»¥è½¬æ¢ä¸ºåŸå§‹æ•°æ®é›†ä¸­çš„æœ€å¤§å€¼

maxHeap = [1, 2, 3]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
# maxHeap çš„å †é¡¶å…ƒç´ æ˜¯ -3
# è½¬æ¢ -3 ä¸º 3ï¼Œè¿™æ˜¯åŸå§‹ maxHeap ä¸­çš„æœ€å¤§å€¼
```

### ä»£ç ç¤ºä¾‹

å®Œæ•´çš„ä»£ç ç¤ºä¾‹å¦‚ä¸‹ï¼š

```python
import heapq

# æ„å»ºä¸€ä¸ªç©ºçš„æœ€å°å †
minHeap = []
heapq.heapify(minHeap)

# ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å°å †
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("æœ€å°å †ï¼š", heapWithValues)  # è¾“å‡º: [1, 3, 2]

# æ„å»ºæœ€å¤§å †çš„æŠ€å·§
maxHeap = [1, 2, 3]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("æœ€å¤§å †ï¼ˆåè½¬åï¼‰ï¼š", maxHeap)  # è¾“å‡º: [-3, -2, -1]

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼Œå¹¶å°†å…¶è½¬æ¢å›æ­£æ•°
max_value = -heapq.heappop(maxHeap)
print("æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š", max_value)  # è¾“å‡º: 3
```

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Python çš„ `heapq` æ¨¡å—æœ‰æ•ˆåœ°å®ç°æœ€å°å †å’Œæœ€å¤§å †çš„æ“ä½œã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªè¯¦ç»†çš„ä¾‹å­ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨ Python çš„ `heapq` æ¨¡å—æ¥æ„å»ºå’Œæ“ä½œæœ€å°å †å’Œæœ€å¤§å †ã€‚

### æœ€å°å †

#### æ„å»ºä¸€ä¸ªç©ºçš„æœ€å°å †å¹¶æ·»åŠ å…ƒç´ 

```python
import heapq

# æ„å»ºä¸€ä¸ªç©ºçš„æœ€å°å †
minHeap = []
heapq.heapify(minHeap)

# å‘æœ€å°å †ä¸­æ·»åŠ å…ƒç´ 
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)

# è¾“å‡ºæœ€å°å †çš„å…ƒç´ 
print("æœ€å°å †ï¼š", minHeap)  # è¾“å‡º: [1, 3, 2]

# è·å–å¹¶ç§»é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
min_value = heapq.heappop(minHeap)
print("æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼š", min_value)  # è¾“å‡º: 1

# è¾“å‡ºæœ€å°å †å‰©ä½™çš„å…ƒç´ 
print("æœ€å°å †å‰©ä½™çš„å…ƒç´ ï¼š", minHeap)  # è¾“å‡º: [2, 3]
```

### æœ€å¤§å †

#### æ„å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å †å¹¶æ·»åŠ å…ƒç´ 

ç”±äº Python æ²¡æœ‰ç›´æ¥æ”¯æŒæœ€å¤§å †çš„å†…éƒ¨å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹æ¯ä¸ªå…ƒç´ å–åæ¥é—´æ¥å®ç°æœ€å¤§å †ï¼š

```python
# æ„å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å †
maxHeap = []
heapq.heapify(maxHeap)

# å‘æœ€å¤§å †ä¸­æ·»åŠ å…ƒç´ ï¼ˆå–ååæ·»åŠ ï¼‰
heapq.heappush(maxHeap, -3)
heapq.heappush(maxHeap, -1)
heapq.heappush(maxHeap, -2)

# è¾“å‡ºæœ€å¤§å †çš„å…ƒç´ ï¼ˆå–åå‰çš„å€¼ï¼‰
print("æœ€å¤§å †ï¼š", [-x for x in maxHeap])  # è¾“å‡º: [3, 1, 2]

# è·å–å¹¶ç§»é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼ˆå–ååï¼‰
max_value = -heapq.heappop(maxHeap)
print("æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š", max_value)  # è¾“å‡º: 3

# è¾“å‡ºæœ€å¤§å †å‰©ä½™çš„å…ƒç´ ï¼ˆå–åå‰çš„å€¼ï¼‰
print("æœ€å¤§å †å‰©ä½™çš„å…ƒç´ ï¼š", [-x for x in maxHeap])  # è¾“å‡º: [2, 1]
```

### ä½¿ç”¨åˆå§‹å€¼æ„å»ºå †ï¼ˆHeapifyï¼‰

#### ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å°å †

```python
# ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å°å †
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å°å †ï¼š", heapWithValues)  # è¾“å‡º: [1, 3, 2]
```

#### ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å¤§å †

```python
# ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å¤§å †
maxHeap = [3, 1, 2]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å¤§å †ï¼ˆåè½¬åï¼‰ï¼š", maxHeap)  # è¾“å‡º: [-3, -1, -2]

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼Œå¹¶å°†å…¶è½¬æ¢å›æ­£æ•°
max_value = -heapq.heappop(maxHeap)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š", max_value)  # è¾“å‡º: 3
```

### å®Œæ•´ä»£ç ç¤ºä¾‹

```python
import heapq

# æœ€å°å †ç¤ºä¾‹
minHeap = []
heapq.heapify(minHeap)
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)
print("æœ€å°å †ï¼š", minHeap)  # è¾“å‡º: [1, 3, 2]
min_value = heapq.heappop(minHeap)
print("æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼š", min_value)  # è¾“å‡º: 1
print("æœ€å°å †å‰©ä½™çš„å…ƒç´ ï¼š", minHeap)  # è¾“å‡º: [2, 3]

# æœ€å¤§å †ç¤ºä¾‹
maxHeap = []
heapq.heapify(maxHeap)
heapq.heappush(maxHeap, -3)
heapq.heappush(maxHeap, -1)
heapq.heappush(maxHeap, -2)
print("æœ€å¤§å †ï¼š", [-x for x in maxHeap])  # è¾“å‡º: [3, 1, 2]
max_value = -heapq.heappop(maxHeap)
print("æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š", max_value)  # è¾“å‡º: 3
print("æœ€å¤§å †å‰©ä½™çš„å…ƒç´ ï¼š", [-x for x in maxHeap])  # è¾“å‡º: [2, 1]

# ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å°å †
heapWithValues = [3, 1, 2]
heapq.heapify(heapWithValues)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å°å †ï¼š", heapWithValues)  # è¾“å‡º: [1, 3, 2]

# ä½¿ç”¨åˆå§‹å€¼æ„å»ºæœ€å¤§å †
maxHeap = [3, 1, 2]
maxHeap = [-x for x in maxHeap]
heapq.heapify(maxHeap)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å¤§å †ï¼ˆåè½¬åï¼‰ï¼š", maxHeap)  # è¾“å‡º: [-3, -1, -2]
max_value = -heapq.heappop(maxHeap)
print("ä½¿ç”¨åˆå§‹å€¼æ„å»ºçš„æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š", max_value)  # è¾“å‡º: 3
```

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Python çš„ `heapq` æ¨¡å—æœ‰æ•ˆåœ°å®ç°å’Œæ“ä½œæœ€å°å †å’Œæœ€å¤§å †ã€‚

åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­æ’å…¥å…ƒç´ æ—¶ï¼Œéƒ½éœ€è¦ç¡®ä¿å †çš„æ€§è´¨ä¿æŒä¸å˜ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­æ’å…¥å…ƒç´ çš„è¯¦ç»†æ­¥éª¤å’Œç¤ºä¾‹ä»£ç ã€‚

### åœ¨æœ€å°å †ä¸­æ’å…¥å…ƒç´ 

#### æ­¥éª¤ï¼š
1. å°†æ–°å…ƒç´ æ·»åŠ åˆ°å †çš„æœ«å°¾ã€‚
2. å°†æ–°å…ƒç´ ä¸å…¶çˆ¶èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ–°å…ƒç´ å°äºå…¶çˆ¶èŠ‚ç‚¹ï¼Œåˆ™äº¤æ¢å®ƒä»¬ã€‚
3. é‡å¤æ­¥éª¤2ï¼Œç›´åˆ°æ–°å…ƒç´ ä¸å†å°äºå…¶çˆ¶èŠ‚ç‚¹ï¼Œæˆ–è€…æ–°å…ƒç´ æˆä¸ºæ ¹èŠ‚ç‚¹ã€‚

### åœ¨æœ€å¤§å †ä¸­æ’å…¥å…ƒç´ 

ç”±äºPythonçš„ `heapq` æ¨¡å—é»˜è®¤åªæ”¯æŒæœ€å°å †ï¼Œæ’å…¥æœ€å¤§å †çš„å…ƒç´ éœ€è¦å°†å…ƒç´ å–åï¼Œç„¶åè¿›è¡Œæ’å…¥æ“ä½œã€‚

#### æ­¥éª¤ï¼š
1. å°†æ–°å…ƒç´ å–ååæ·»åŠ åˆ°å †çš„æœ«å°¾ã€‚
2. å°†æ–°å…ƒç´ ä¸å…¶çˆ¶èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ–°å…ƒç´ å¤§äºå…¶çˆ¶èŠ‚ç‚¹ï¼Œåˆ™äº¤æ¢å®ƒä»¬ã€‚
3. é‡å¤æ­¥éª¤2ï¼Œç›´åˆ°æ–°å…ƒç´ ä¸å†å¤§äºå…¶çˆ¶èŠ‚ç‚¹ï¼Œæˆ–è€…æ–°å…ƒç´ æˆä¸ºæ ¹èŠ‚ç‚¹ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq

# æœ€å°å †ç¤ºä¾‹
minHeap = []
heapq.heapify(minHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å°å †
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"æ’å…¥ {element} åçš„æœ€å°å †: {heap}")

# æ’å…¥æ“ä½œ
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# è·å–å¹¶ç§»é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
min_value = heapq.heappop(minHeap)
print(f"æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼š{min_value}")
print(f"ç§»é™¤å †é¡¶å…ƒç´ åçš„æœ€å°å †ï¼š{minHeap}")

# æœ€å¤§å †ç¤ºä¾‹
maxHeap = []
heapq.heapify(maxHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å¤§å †
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"æ’å…¥ {element} åçš„æœ€å¤§å †: {[-x for x in heap]}")

# æ’å…¥æ“ä½œ
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# è·å–å¹¶ç§»é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
max_value = -heapq.heappop(maxHeap)
print(f"æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š{max_value}")
print(f"ç§»é™¤å †é¡¶å…ƒç´ åçš„æœ€å¤§å †ï¼š{[-x for x in maxHeap]}")

```

### è§£é‡Š
1. **æœ€å°å †çš„æ’å…¥**ï¼š
   - ä½¿ç”¨ `heapq.heappush` å°†å…ƒç´ æ’å…¥åˆ°æœ€å°å †ä¸­ã€‚
   - æ¯æ¬¡æ’å…¥åï¼Œè¾“å‡ºå †çš„çŠ¶æ€ã€‚

2. **æœ€å¤§å †çš„æ’å…¥**ï¼š
   - ç”±äº `heapq` åªæ”¯æŒæœ€å°å †ï¼Œé¦–å…ˆå°†å…ƒç´ å–åï¼Œç„¶åæ’å…¥å †ä¸­ã€‚
   - æ¯æ¬¡æ’å…¥åï¼Œè¾“å‡ºå †çš„çŠ¶æ€ï¼ˆæ³¨æ„è¾“å‡ºæ—¶å°†å…ƒç´ å–åä»¥æ˜¾ç¤ºåŸå§‹å€¼ï¼‰ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­æ’å…¥å…ƒç´ ï¼Œå¹¶ç¡®ä¿å †çš„æ€§è´¨ä¿æŒä¸å˜ã€‚

# Get top element from the Min Heap
# i.e. the smallest element
minHeap[0]
# Get top element from the Max Heap
# i.e. the largest element
# When inserting an element, we multiplied it by -1
# Therefore, we need to multiply the element by -1 to revert it back
-1 * maxHeap[0]

è¦è·å–å †é¡¶å…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®å †çš„ç±»å‹æ¥å¤„ç†æœ€å°å †å’Œæœ€å¤§å †ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­è·å–å †é¡¶å…ƒç´ çš„è¯¦ç»†æ­¥éª¤å’Œç¤ºä¾‹ä»£ç ã€‚

### æœ€å°å †

åœ¨æœ€å°å †ä¸­ï¼Œå †é¡¶å…ƒç´ æ˜¯æœ€å°çš„å…ƒç´ ã€‚ä½¿ç”¨ Python çš„ `heapq` æ¨¡å—ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°è·å–å †é¡¶å…ƒç´ ã€‚

### æœ€å¤§å †

ç”±äºPythonçš„ `heapq` æ¨¡å—é»˜è®¤åªæ”¯æŒæœ€å°å †ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹å †é¡¶å…ƒç´ å–åæ¥è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq

# æœ€å°å †ç¤ºä¾‹
minHeap = []
heapq.heapify(minHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å°å †
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"æ’å…¥ {element} åçš„æœ€å°å †: {heap}")

# è·å–æœ€å°å †çš„å †é¡¶å…ƒç´ 
def get_min_heap_top(heap):
    if heap:
        return heap[0]
    return None

# æ’å…¥æ“ä½œ
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# è·å–æœ€å°å †çš„å †é¡¶å…ƒç´ 
min_top = get_min_heap_top(minHeap)
print(f"æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼š{min_top}")

# æœ€å¤§å †ç¤ºä¾‹
maxHeap = []
heapq.heapify(maxHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å¤§å †
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"æ’å…¥ {element} åçš„æœ€å¤§å †: {[-x for x in heap]}")

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
def get_max_heap_top(heap):
    if heap:
        return -heap[0]
    return None

# æ’å…¥æ“ä½œ
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
max_top = get_max_heap_top(maxHeap)
print(f"æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š{max_top}")
```

### è§£é‡Š
1. **æœ€å°å †çš„å †é¡¶å…ƒç´ **ï¼š
   - `get_min_heap_top` å‡½æ•°è¿”å›æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼ˆå³å †æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚
   - å¦‚æœå †ä¸ºç©ºï¼Œè¿”å› `None`ã€‚

2. **æœ€å¤§å †çš„å †é¡¶å…ƒç´ **ï¼š
   - `get_max_heap_top` å‡½æ•°é€šè¿‡å¯¹å †é¡¶å…ƒç´ å–åæ¥è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ ã€‚
   - å¦‚æœå †ä¸ºç©ºï¼Œè¿”å› `None`ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­è·å–å †é¡¶å…ƒç´ ï¼Œå¹¶ç¡®ä¿å †çš„æ€§è´¨ä¿æŒä¸å˜ã€‚

# Delete top element from the Min Heap
heapq.heappop(minHeap)

# Delete top element from the Max Heap
heapq.heappop(maxHeap)

# Length of the Min Heap
len(minHeap)

# Length of the Max Heap
len(maxHeap)

åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­åˆ é™¤å †é¡¶å…ƒç´ æ—¶ï¼Œéœ€è¦ç¡®ä¿åˆ é™¤å †é¡¶å…ƒç´ åå †çš„æ€§è´¨ä¿æŒä¸å˜ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­åˆ é™¤å †é¡¶å…ƒç´ çš„è¯¦ç»†æ­¥éª¤å’Œç¤ºä¾‹ä»£ç ã€‚

### åœ¨æœ€å°å †ä¸­åˆ é™¤å †é¡¶å…ƒç´ 

#### æ­¥éª¤ï¼š
1. å°†å †é¡¶å…ƒç´ ä¸å †çš„æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ã€‚
2. åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç°åœ¨æ˜¯å †é¡¶å…ƒç´ ï¼‰ã€‚
3. ä»å †é¡¶å¼€å§‹ï¼Œå¯¹å †è¿›è¡Œè°ƒæ•´ï¼Œä»¥é‡æ–°æ»¡è¶³æœ€å°å †çš„æ€§è´¨ã€‚

### åœ¨æœ€å¤§å †ä¸­åˆ é™¤å †é¡¶å…ƒç´ 

ç”±äºPythonçš„ `heapq` æ¨¡å—é»˜è®¤åªæ”¯æŒæœ€å°å †ï¼Œåˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ éœ€è¦å°†å †é¡¶å…ƒç´ å–åï¼Œç„¶åè¿›è¡Œåˆ é™¤æ“ä½œã€‚

#### æ­¥éª¤ï¼š
1. å°†å †é¡¶å…ƒç´ ä¸å †çš„æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ã€‚
2. åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç°åœ¨æ˜¯å †é¡¶å…ƒç´ ï¼‰ã€‚
3. ä»å †é¡¶å¼€å§‹ï¼Œå¯¹å †è¿›è¡Œè°ƒæ•´ï¼Œä»¥é‡æ–°æ»¡è¶³æœ€å¤§å †çš„æ€§è´¨ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq

# æœ€å°å †ç¤ºä¾‹
minHeap = []
heapq.heapify(minHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å°å †
def insert_min_heap(heap, element):
    heapq.heappush(heap, element)
    print(f"æ’å…¥ {element} åçš„æœ€å°å †: {heap}")

# åˆ é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
def delete_min_heap_top(heap):
    if heap:
        removed_element = heapq.heappop(heap)
        print(f"åˆ é™¤çš„æœ€å°å †å †é¡¶å…ƒç´ ï¼š{removed_element}")
    else:
        print("æœ€å°å †ä¸ºç©ºï¼Œæ— æ³•åˆ é™¤å †é¡¶å…ƒç´ ")

# æ’å…¥æ“ä½œ
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# åˆ é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
delete_min_heap_top(minHeap)
print(f"åˆ é™¤å †é¡¶å…ƒç´ åçš„æœ€å°å †ï¼š{minHeap}")

# æœ€å¤§å †ç¤ºä¾‹
maxHeap = []
heapq.heapify(maxHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å¤§å †
def insert_max_heap(heap, element):
    heapq.heappush(heap, -element)
    print(f"æ’å…¥ {element} åçš„æœ€å¤§å †: {[-x for x in heap]}")

# åˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
def delete_max_heap_top(heap):
    if heap:
        removed_element = -heapq.heappop(heap)
        print(f"åˆ é™¤çš„æœ€å¤§å †å †é¡¶å…ƒç´ ï¼š{removed_element}")
    else:
        print("æœ€å¤§å †ä¸ºç©ºï¼Œæ— æ³•åˆ é™¤å †é¡¶å…ƒç´ ")

# æ’å…¥æ“ä½œ
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# åˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
delete_max_heap_top(maxHeap)
print(f"åˆ é™¤å †é¡¶å…ƒç´ åçš„æœ€å¤§å †ï¼š{[-x for x in maxHeap]}")

```

### è§£é‡Š
1. **æœ€å°å †çš„å †é¡¶å…ƒç´ åˆ é™¤**ï¼š
   - `delete_min_heap_top` å‡½æ•°é€šè¿‡ `heapq.heappop` åˆ é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ ã€‚
   - åˆ é™¤åï¼Œè¾“å‡ºå †çš„çŠ¶æ€ã€‚

2. **æœ€å¤§å †çš„å †é¡¶å…ƒç´ åˆ é™¤**ï¼š
   - `delete_max_heap_top` å‡½æ•°é€šè¿‡å¯¹å †é¡¶å…ƒç´ å–ååä½¿ç”¨ `heapq.heappop` åˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ ã€‚
   - åˆ é™¤åï¼Œè¾“å‡ºå †çš„çŠ¶æ€ï¼ˆæ³¨æ„è¾“å‡ºæ—¶å°†å…ƒç´ å–åä»¥æ˜¾ç¤ºåŸå§‹å€¼ï¼‰ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ€å°å †å’Œæœ€å¤§å †ä¸­åˆ é™¤å †é¡¶å…ƒç´ ï¼Œå¹¶ç¡®ä¿å †çš„æ€§è´¨ä¿æŒä¸å˜ã€‚

# Code for Min Heap
import heapq

# Create an array
minHeap = []

# Heapify the array into a Min Heap
heapq.heapify(minHeap)

# Add 3ï¼Œ1ï¼Œ2 respectively to the Min Heap
heapq.heappush(minHeap, 3)
heapq.heappush(minHeap, 1)
heapq.heappush(minHeap, 2)

# Check all elements in the Min Heap, the result is [1, 3, 2]
print("minHeap: ", minHeap)

# Get the top element of the Min Heap
peekNum = minHeap[0]

# The result is 1
print("peek number: ", peekNum)

# Delete the top element in the Min Heap
popNum = heapq.heappop(minHeap)

# The result is 1
print("pop number: ", popNum)

# Check the top element after deleting 1, the result is 2
print("peek number: ", minHeap[0])

# Check all elements in the Min Heap, the result is [2,3]
print("minHeap: ", minHeap)

# Check the number of elements in the Min Heap
# Which is also the length of the Min Heap
size = len(minHeap)

# The result is 2
print("minHeap size: ", size)

# Code for Max Heap
import heapq

# Create an array
maxHeap = []

# Heapify the array into a Min Heap
# we need to negate each element to convert the Min Heap to a Max Heap
heapq.heapify(maxHeap)

# Add 1ï¼Œ3ï¼Œ2 respectively to the Max Heap
# Note we are actually adding -1, -3 and -2 after negating the elements
# The Min Heap is now converted to a Max Heap
heapq.heappush(maxHeap, -1 * 1)
heapq.heappush(maxHeap, -1 * 3)
heapq.heappush(maxHeap, -1 * 2)

# Check all elements in the Max Heap, the result is [-3, -1, -2]
print("maxHeap: ", maxHeap)

# Check the largest element in the Heap, which is min value in the -1 * Heap
peekNum = maxHeap[0]

# The result is 3
print("peek number: ", -1 * peekNum)

# Delete the largest element in the Max Heap
# Which is the smallest value in the current Heap
popNum = heapq.heappop(maxHeap)

# The result is 3
print("pop number: ", -1 *  popNum)

# Check the largest element after deleting 3, the result is 2
print("peek number: ", -1 * maxHeap[0])

# Check all elements in the Max Heap, the result is [-2,-1]
print("maxHeap: ", maxHeap)

# Check the number of elements in the Max Heap
# Which is also the length of the Min Heap
size = len(maxHeap)

# The result is 2
print("maxHeap size: ", size)

åœ¨å †æ“ä½œä¸­ï¼Œç†è§£ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦æ˜¯éå¸¸é‡è¦çš„ã€‚ä»¥ä¸‹æ˜¯å…³äºæœ€å°å †å’Œæœ€å¤§å †åœ¨æ’å…¥ã€è·å–å †é¡¶å…ƒç´ å’Œåˆ é™¤å †é¡¶å…ƒç´ æ“ä½œçš„ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦çš„è¯¦ç»†è§£é‡Šã€‚

### ç©ºé—´å¤æ‚åº¦

å¯¹äºæœ€å°å †å’Œæœ€å¤§å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºå­˜å‚¨å…ƒç´ æ‰€éœ€çš„ç©ºé—´ã€‚å‡è®¾å †ä¸­æœ‰ \( n \) ä¸ªå…ƒç´ ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)

### æ—¶é—´å¤æ‚åº¦

#### æ’å…¥å…ƒç´ ï¼ˆInsertï¼‰

åœ¨å †ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ éœ€è¦å°†æ–°å…ƒç´ æ·»åŠ åˆ°å †çš„æœ«å°¾ï¼Œç„¶åè°ƒæ•´å †ä»¥ä¿æŒå †çš„æ€§è´¨ã€‚

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(log n)
  - è°ƒæ•´å †çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½éœ€è¦æ²¿ç€æ ‘çš„é«˜åº¦å‘ä¸Šäº¤æ¢å…ƒç´ ã€‚å¯¹äºå®Œå…¨äºŒå‰æ ‘ï¼Œé«˜åº¦ä¸º \( O(log n) \)ã€‚

#### è·å–å †é¡¶å…ƒç´ ï¼ˆPeekï¼‰

è·å–å †é¡¶å…ƒç´ ä¸æ¶‰åŠä»»ä½•è°ƒæ•´æ“ä½œï¼Œåªæ˜¯ç®€å•åœ°è®¿é—®æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(1)

#### åˆ é™¤å †é¡¶å…ƒç´ ï¼ˆDeleteï¼‰

åˆ é™¤å †é¡¶å…ƒç´ éœ€è¦å°†å †çš„æœ€åä¸€ä¸ªå…ƒç´ ç§»åˆ°å †é¡¶ï¼Œç„¶åè°ƒæ•´å †ä»¥ä¿æŒå †çš„æ€§è´¨ã€‚

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(log n)
  - è°ƒæ•´å †çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½éœ€è¦æ²¿ç€æ ‘çš„é«˜åº¦å‘ä¸‹äº¤æ¢å…ƒç´ ã€‚å¯¹äºå®Œå…¨äºŒå‰æ ‘ï¼Œé«˜åº¦ä¸º \( O(log n) \)ã€‚

### ä»£ç ç¤ºä¾‹

ä»¥ä¸‹æ˜¯æ’å…¥ã€è·å–å †é¡¶å…ƒç´ å’Œåˆ é™¤å †é¡¶å…ƒç´ æ“ä½œçš„ä»£ç ç¤ºä¾‹ï¼ŒåŒ…æ‹¬æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦çš„æ³¨é‡Šã€‚

```python
import heapq

# æœ€å°å †ç¤ºä¾‹
minHeap = []
heapq.heapify(minHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å°å †
def insert_min_heap(heap, element):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
    heapq.heappush(heap, element)
    print(f"æ’å…¥ {element} åçš„æœ€å°å †: {heap}")

# è·å–æœ€å°å †çš„å †é¡¶å…ƒç´ 
def get_min_heap_top(heap):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(1)
    if heap:
        return heap[0]
    return None

# åˆ é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
def delete_min_heap_top(heap):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
    if heap:
        removed_element = heapq.heappop(heap)
        print(f"åˆ é™¤çš„æœ€å°å †å †é¡¶å…ƒç´ ï¼š{removed_element}")
    else:
        print("æœ€å°å †ä¸ºç©ºï¼Œæ— æ³•åˆ é™¤å †é¡¶å…ƒç´ ")

# æ’å…¥æ“ä½œ
insert_min_heap(minHeap, 3)
insert_min_heap(minHeap, 1)
insert_min_heap(minHeap, 2)

# è·å–æœ€å°å †çš„å †é¡¶å…ƒç´ 
min_top = get_min_heap_top(minHeap)
print(f"æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼š{min_top}")

# åˆ é™¤æœ€å°å †çš„å †é¡¶å…ƒç´ 
delete_min_heap_top(minHeap)
print(f"åˆ é™¤å †é¡¶å…ƒç´ åçš„æœ€å°å †ï¼š{minHeap}")

# æœ€å¤§å †ç¤ºä¾‹
maxHeap = []
heapq.heapify(maxHeap)

# æ’å…¥å…ƒç´ åˆ°æœ€å¤§å †
def insert_max_heap(heap, element):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
    heapq.heappush(heap, -element)
    print(f"æ’å…¥ {element} åçš„æœ€å¤§å †: {[-x for x in heap]}")

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
def get_max_heap_top(heap):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(1)
    if heap:
        return -heap[0]
    return None

# åˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
def delete_max_heap_top(heap):
    # æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
    if heap:
        removed_element = -heapq.heappop(heap)
        print(f"åˆ é™¤çš„æœ€å¤§å †å †é¡¶å…ƒç´ ï¼š{removed_element}")
    else:
        print("æœ€å¤§å †ä¸ºç©ºï¼Œæ— æ³•åˆ é™¤å †é¡¶å…ƒç´ ")

# æ’å…¥æ“ä½œ
insert_max_heap(maxHeap, 3)
insert_max_heap(maxHeap, 1)
insert_max_heap(maxHeap, 2)

# è·å–æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
max_top = get_max_heap_top(maxHeap)
print(f"æœ€å¤§å †çš„å †é¡¶å…ƒç´ ï¼š{max_top}")

# åˆ é™¤æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
delete_max_heap_top(maxHeap)
print(f"åˆ é™¤å †é¡¶å…ƒç´ åçš„æœ€å¤§å †ï¼š{[-x for x in maxHeap]}")

```

### æ€»ç»“

- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)ï¼Œå› ä¸ºå †éœ€è¦å­˜å‚¨æ‰€æœ‰å…ƒç´ ã€‚
- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥æ“ä½œï¼šO(log n)
  - è·å–å †é¡¶å…ƒç´ ï¼šO(1)
  - åˆ é™¤å †é¡¶å…ƒç´ ï¼šO(log n)

è¿™äº›å¤æ‚åº¦åæ˜ äº†å †åœ¨å¤„ç†å…ƒç´ æ—¶çš„æ•ˆç‡å’Œæ€§èƒ½ã€‚

### å †æ’åºçš„å®ç°å’Œè§£é‡Š

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå †æ’åºï¼ˆHeap Sortï¼‰çš„å®ç°ï¼Œä½¿ç”¨äº†æœ€å¤§å †çš„æ„å»ºå’Œè°ƒæ•´ã€‚å †æ’åºé€šè¿‡æ„å»ºä¸€ä¸ªæœ€å¤§å †ï¼Œç„¶åé€æ­¥å°†æœ€å¤§å…ƒç´ ç§»åˆ°æ•°ç»„æœ«å°¾æ¥å®ç°æ’åºã€‚è¿™é‡Œæ˜¯è¯¦ç»†çš„ä»£ç å’Œè§£é‡Šï¼š

```python
from typing import List

class Solution:
    def heap_sort(self, lst: List[int]) -> None:
        """
        Mutates elements in lst by utilizing the heap data structure
        """
        def max_heapify(heap_size, index):
            left, right = 2 * index + 1, 2 * index + 2
            largest = index
            if left < heap_size and lst[left] > lst[largest]:
                largest = left
            if right < heap_size and lst[right] > lst[largest]:
                largest = right
            if largest != index:
                lst[index], lst[largest] = lst[largest], lst[index]
                max_heapify(heap_size, largest)

        # æ„å»ºæœ€å¤§å †
        for i in range(len(lst) // 2 - 1, -1, -1):
            max_heapify(len(lst), i)

        # åˆ©ç”¨å †æ’åº
        for i in range(len(lst) - 1, 0, -1):
            # å°†æœ€åä¸€ä¸ªå…ƒç´ ä¸å †é¡¶å…ƒç´ äº¤æ¢
            lst[i], lst[0] = lst[0], lst[i]
            # æ¯æ¬¡è¿­ä»£å°†å †çš„å¤§å°å‡1
            max_heapify(i, 0)

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    lst = [3, 1, 5, 2, 4]
    solution.heap_sort(lst)
    print(lst)  # è¾“å‡º: [1, 2, 3, 4, 5]
```

### è§£é‡Š

1. **æœ€å¤§å †è°ƒæ•´ï¼ˆmax_heapifyï¼‰**ï¼š
   - `max_heapify` å‡½æ•°ç”¨äºè°ƒæ•´å †ï¼Œä½¿å…¶æ»¡è¶³æœ€å¤§å †çš„æ€§è´¨ã€‚å¯¹äºç»™å®šçš„ç´¢å¼• `index`ï¼Œå‡½æ•°ä¼šæ¯”è¾ƒè¯¥èŠ‚ç‚¹ä¸å…¶å·¦ã€å³å­èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœå­èŠ‚ç‚¹çš„å€¼è¾ƒå¤§ï¼Œåˆ™äº¤æ¢å®ƒä»¬ï¼Œå¹¶é€’å½’åœ°è°ƒæ•´å—å½±å“çš„å­èŠ‚ç‚¹ã€‚

2. **æ„å»ºæœ€å¤§å †**ï¼š
   - ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œè‡ªä¸‹è€Œä¸Šåœ°è°ƒç”¨ `max_heapify` æ¥æ„å»ºæœ€å¤§å †ã€‚å¯¹äºé•¿åº¦ä¸º `n` çš„åˆ—è¡¨ï¼Œä» `n//2 - 1` åˆ° `0` è¿›è¡Œæœ€å¤§å †è°ƒæ•´ã€‚

3. **å †æ’åº**ï¼š
   - é€šè¿‡äº¤æ¢å †é¡¶å…ƒç´ å’Œå½“å‰å †çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå°†æœ€å¤§å…ƒç´ ç§»åˆ°æ•°ç»„æœ«å°¾ã€‚
   - ç„¶åï¼Œå‡å°å †çš„å¤§å°ï¼Œå¹¶å¯¹å †é¡¶å…ƒç´ è¿›è¡Œæœ€å¤§å †è°ƒæ•´ï¼Œä»¥æ¢å¤æœ€å¤§å †æ€§è´¨ã€‚
   - é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°å †çš„å¤§å°ä¸º1ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ„å»ºæœ€å¤§å †ï¼šO(n)
  - æ¯æ¬¡è°ƒæ•´å †ï¼šO(log n)
  - æ€»æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†åŸåœ°æ’åºï¼Œæ²¡æœ‰ä½¿ç”¨é¢å¤–çš„ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

è¿™ç§å®ç°æ–¹å¼é«˜æ•ˆä¸”é€‚ç”¨äºéœ€è¦åŸåœ°æ’åºçš„åœºæ™¯ã€‚

è§£å†³ "Top K" é—®é¢˜çš„ä¸€ç§æœ‰æ•ˆæ–¹æ³•æ˜¯ä½¿ç”¨å †æ•°æ®ç»“æ„ã€‚å…·ä½“æ¥è¯´ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å½“å‰çš„å‰ K ä¸ªæœ€å¤§å…ƒç´ ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨æœ€å°å †æ¥è§£å†³ "Top K" é—®é¢˜ã€‚

### é—®é¢˜æè¿°

ç»™å®šä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ•´æ•° Kï¼Œæ‰¾å‡ºæ•°ç»„ä¸­å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

### è§£å†³æ–¹æ¡ˆ

1. æ„å»ºä¸€ä¸ªæœ€å°å †ï¼Œå¤§å°ä¸º Kã€‚
2. éå†æ•°ç»„ä¸­çš„å…ƒç´ ï¼š
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œå°†å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œæ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
3. éå†ç»“æŸåï¼Œå †ä¸­çš„å…ƒç´ å³ä¸ºæ•°ç»„ä¸­å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def top_k_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap ç°åœ¨åŒ…å«å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        return minHeap

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_elements(nums, k)
    print(result)  # è¾“å‡º: [4, 5, 6]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ
```

### è§£é‡Š

1. **åˆå§‹åŒ–æœ€å°å †**ï¼š
   - `minHeap = []`ï¼šä½¿ç”¨ Python çš„ `heapq` æ¨¡å—åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„æœ€å°å †ã€‚

2. **éå†æ•°ç»„ä¸­çš„å…ƒç´ **ï¼š
   - `if len(minHeap) < k`ï¼šå¦‚æœå †çš„å¤§å°å°äº Kï¼Œå°†å½“å‰å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - `else if num > minHeap[0]`ï¼šå¦‚æœå½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œä½¿ç”¨ `heapreplace` æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - `return minHeap`ï¼šå †ä¸­çš„å…ƒç´ å³ä¸ºå‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥å…ƒç´ å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - éå†æ‰€æœ‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„æœ€å°å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”é€‚ç”¨äºéœ€è¦æ‰¾å‡ºå‰ K ä¸ªæœ€å¤§çš„å…ƒç´ çš„é—®é¢˜ã€‚

ä½¿ç”¨å †æ•°æ®ç»“æ„æ¥è§£å†³ "Top K" é—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•æ˜¯æ„å»ºæœ€å¤§å †ä»¥è·å¾—å‰ K ä¸ªæœ€å°å…ƒç´ ï¼Œæˆ–æ„å»ºæœ€å°å †ä»¥è·å¾—å‰ K ä¸ªæœ€å¤§å…ƒç´ ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„æ­¥éª¤å’Œç¤ºä¾‹ä»£ç å±•ç¤ºå¦‚ä½•å®ç°è¿™ç§æ–¹æ³•ã€‚

### é—®é¢˜æè¿°

ç»™å®šä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ•´æ•° Kï¼Œæ‰¾å‡ºæ•°ç»„ä¸­å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ æˆ–æœ€å°çš„å…ƒç´ ã€‚

### è§£å†³æ–¹æ¡ˆ

ä½¿ç”¨å †æ•°æ®ç»“æ„ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ­¥éª¤å®ç°ï¼š

1. å¯¹äºæ‰¾å‡ºå‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œä½¿ç”¨æœ€å°å †ï¼š
   - æ„å»ºä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †ã€‚
   - éå†æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œæ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   
2. å¯¹äºæ‰¾å‡ºå‰ K ä¸ªæœ€å°çš„å…ƒç´ ï¼Œä½¿ç”¨æœ€å¤§å †ï¼š
   - æ„å»ºä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å¤§å †ã€‚
   - éå†æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå…ƒç´ å°äºå †é¡¶å…ƒç´ ï¼Œæ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def top_k_largest_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap ç°åœ¨åŒ…å«å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        return minHeap

    def top_k_smallest_elements(self, nums: List[int], k: int) -> List[int]:
        if k == 0:
            return []
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å¤§å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å°çš„å…ƒç´ 
        maxHeap = []
        
        for num in nums:
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, -num)
            else:
                if -num > maxHeap[0]:
                    heapq.heapreplace(maxHeap, -num)
        
        # maxHeap ç°åœ¨åŒ…å«å‰ K ä¸ªæœ€å°çš„å…ƒç´ ï¼ˆå–è´Ÿæ•°åï¼‰
        return [-x for x in maxHeap]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    # æ‰¾å‡ºå‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_largest_elements(nums, k)
    print(f"å‰ {k} ä¸ªæœ€å¤§çš„å…ƒç´ : {result}")  # è¾“å‡º: [4, 5, 6]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ

    # æ‰¾å‡ºå‰ K ä¸ªæœ€å°çš„å…ƒç´ 
    nums = [3, 2, 1, 5, 6, 4]
    k = 3
    result = solution.top_k_smallest_elements(nums, k)
    print(f"å‰ {k} ä¸ªæœ€å°çš„å…ƒç´ : {result}")  # è¾“å‡º: [1, 2, 3]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ
```

### è§£é‡Š

1. **æœ€å°å †ç”¨äºæ‰¾å‡ºå‰ K ä¸ªæœ€å¤§çš„å…ƒç´ **ï¼š
   - `top_k_largest_elements` æ–¹æ³•ä½¿ç”¨æœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   
2. **æœ€å¤§å †ç”¨äºæ‰¾å‡ºå‰ K ä¸ªæœ€å°çš„å…ƒç´ **ï¼š
   - `top_k_smallest_elements` æ–¹æ³•ä½¿ç”¨æœ€å¤§å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å°çš„å…ƒç´ ã€‚
   - æ³¨æ„ï¼Œç”±äº Python çš„ `heapq` æ¨¡å—åªæ”¯æŒæœ€å°å †ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å…ƒç´ å–åä»¥æ¨¡æ‹Ÿæœ€å¤§å †ã€‚
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†å…ƒç´ ï¼ˆå–ååï¼‰æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ ï¼ˆå–ååï¼‰å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥å…ƒç´ å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - éå†æ‰€æœ‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”é€‚ç”¨äºéœ€è¦æ‰¾å‡ºå‰ K ä¸ªæœ€å¤§æˆ–æœ€å°å…ƒç´ çš„é—®é¢˜ã€‚

ä½¿ç”¨å †æ•°æ®ç»“æ„æ¥è·å–ç¬¬ K å¤§æˆ–ç¬¬ K å°çš„å…ƒç´ æ˜¯ä¸€ç§é«˜æ•ˆçš„æ–¹æ³•ã€‚ä¸‹é¢æ˜¯è¯¦ç»†çš„æ­¥éª¤å’Œä»£ç ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨å †æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

### é—®é¢˜æè¿°

ç»™å®šä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ•´æ•° Kï¼Œæ‰¾å‡ºæ•°ç»„ä¸­ç¬¬ K å¤§æˆ–ç¬¬ K å°çš„å…ƒç´ ã€‚

### è§£å†³æ–¹æ¡ˆ

1. **æ‰¾å‡ºç¬¬ K å¤§çš„å…ƒç´ **ï¼š
   - ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚
   - éå†æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œæ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   - éå†ç»“æŸåï¼Œå †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å¤§çš„å…ƒç´ ã€‚

2. **æ‰¾å‡ºç¬¬ K å°çš„å…ƒç´ **ï¼š
   - ä½¿ç”¨ä¸€ä¸ªæœ€å¤§å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å°çš„å…ƒç´ ã€‚
   - éå†æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå…ƒç´ å°äºå †é¡¶å…ƒç´ ï¼Œæ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   - éå†ç»“æŸåï¼Œå †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å°çš„å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def kth_largest_element(self, nums: List[int], k: int) -> int:
        if k == 0:
            return None
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap çš„å †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å¤§çš„å…ƒç´ 
        return minHeap[0]

    def kth_smallest_element(self, nums: List[int], k: int) -> int:
        if k == 0:
            return None
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å¤§å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å°çš„å…ƒç´ 
        maxHeap = []
        
        for num in nums:
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, -num)
            else:
                if -num > maxHeap[0]:
                    heapq.heapreplace(maxHeap, -num)
        
        # maxHeap çš„å †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å°çš„å…ƒç´ ï¼ˆå–è´Ÿæ•°åï¼‰
        return -maxHeap[0]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    # æ‰¾å‡ºç¬¬ K å¤§çš„å…ƒç´ 
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.kth_largest_element(nums, k)
    print(f"ç¬¬ {k} å¤§çš„å…ƒç´ : {result}")  # è¾“å‡º: 5

    # æ‰¾å‡ºç¬¬ K å°çš„å…ƒç´ 
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.kth_smallest_element(nums, k)
    print(f"ç¬¬ {k} å°çš„å…ƒç´ : {result}")  # è¾“å‡º: 2
```

### è§£é‡Š

1. **æ‰¾å‡ºç¬¬ K å¤§çš„å…ƒç´ **ï¼š
   - `kth_largest_element` æ–¹æ³•ä½¿ç”¨æœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   - æœ€ç»ˆï¼Œå †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å¤§çš„å…ƒç´ ã€‚

2. **æ‰¾å‡ºç¬¬ K å°çš„å…ƒç´ **ï¼š
   - `kth_smallest_element` æ–¹æ³•ä½¿ç”¨æœ€å¤§å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å°çš„å…ƒç´ ã€‚
   - æ³¨æ„ï¼Œç”±äº Python çš„ `heapq` æ¨¡å—åªæ”¯æŒæœ€å°å †ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å…ƒç´ å–åä»¥æ¨¡æ‹Ÿæœ€å¤§å †ã€‚
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†å…ƒç´ ï¼ˆå–ååï¼‰æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ ï¼ˆå–ååï¼‰å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
   - æœ€ç»ˆï¼Œå †é¡¶å…ƒç´ ï¼ˆå–ååï¼‰å³ä¸ºç¬¬ K å°çš„å…ƒç´ ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥å…ƒç´ å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - éå†æ‰€æœ‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°æ‰¾å‡ºæ•°ç»„ä¸­çš„ç¬¬ K å¤§æˆ–ç¬¬ K å°çš„å…ƒç´ ã€‚

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_value = min(nums)
        max_value = max(nums)
        count = [0] * (max_value - min_value + 1)

        for num in nums:
            count[num - min_value] += 1
        
        remain = k
        for num in range(len(count) -1, -1, -1):
            remain -= count[num]
            if remain <= 0:
                return num + min_value

        return -1

å¯ä»¥é€šè¿‡ä½¿ç”¨æœ€å°å †æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä»¥é¿å…ç›´æ¥å¯¹æ•°ç»„è¿›è¡Œæ’åºã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªè¯¦ç»†çš„è§£å†³æ–¹æ¡ˆï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨æœ€å°å †æ¥æ‰¾å‡ºæ•°ç»„ä¸­çš„ç¬¬ K å¤§çš„å…ƒç´ ã€‚

### è§£å†³æ–¹æ¡ˆ

1. ä½¿ç”¨ä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †æ¥å­˜å‚¨å½“å‰æ‰¾åˆ°çš„æœ€å¤§çš„ K ä¸ªå…ƒç´ ã€‚
2. éå†æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼š
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œå°†å½“å‰å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦åˆ™ï¼Œå¦‚æœå½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚
3. éå†ç»“æŸåï¼Œå †é¡¶å…ƒç´ å³ä¸ºæ•°ç»„ä¸­ç¬¬ K å¤§çš„å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨å‰ K ä¸ªæœ€å¤§çš„å…ƒç´ 
        minHeap = []
        
        for num in nums:
            if len(minHeap) < k:
                heapq.heappush(minHeap, num)
            else:
                if num > minHeap[0]:
                    heapq.heapreplace(minHeap, num)
        
        # minHeap çš„å †é¡¶å…ƒç´ å³ä¸ºç¬¬ K å¤§çš„å…ƒç´ 
        return minHeap[0]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    nums = [3, 2, 1, 5, 6, 4]
    k = 2
    result = solution.findKthLargest(nums, k)
    print(f"æ•°ç»„ä¸­çš„ç¬¬ {k} å¤§çš„å…ƒç´ æ˜¯: {result}")  # è¾“å‡º: 5
```

### è§£é‡Š

1. **åˆå§‹åŒ–æœ€å°å †**ï¼š
   - ä½¿ç”¨ `heapq` æ¨¡å—åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„æœ€å°å † `minHeap`ã€‚

2. **éå†æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ **ï¼š
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†å…ƒç´ æ·»åŠ åˆ°å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™ä½¿ç”¨ `heapreplace` æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - éå†ç»“æŸåï¼Œå †é¡¶å…ƒç´ å³ä¸ºæ•°ç»„ä¸­ç¬¬ K å¤§çš„å…ƒç´ ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥å…ƒç´ å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - éå†æ‰€æœ‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„æœ€å°å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”é¿å…äº†å¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œæ’åºï¼Œé€šè¿‡ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †ï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿæ‰¾å‡ºæ•°ç»„ä¸­çš„ç¬¬ K å¤§çš„å…ƒç´ ã€‚

è¦æ‰¾åˆ°æ•°ç»„ä¸­å‡ºç°é¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ ï¼Œå¯ä»¥ä½¿ç”¨å †æ•°æ®ç»“æ„æ¥å®ç°ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. **ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„é¢‘ç‡**ï¼šä½¿ç”¨å“ˆå¸Œè¡¨ï¼ˆå­—å…¸ï¼‰æ¥ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡ã€‚
2. **ä½¿ç”¨æœ€å°å †æ¥ç»´æŠ¤é¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ **ï¼šé€šè¿‡å°†é¢‘ç‡ä½œä¸ºå…³é”®å­—æ„å»ºä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †ã€‚
3. **è¿”å›ç»“æœ**ï¼šéå†å®Œæ‰€æœ‰å…ƒç´ åï¼Œå †ä¸­çš„å…ƒç´ å³ä¸ºé¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List, Tuple
from collections import Counter

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„é¢‘ç‡
        frequency_map = Counter(nums)
        
        # ä½¿ç”¨ä¸€ä¸ªæœ€å°å †æ¥å­˜å‚¨é¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ 
        minHeap: List[Tuple[int, int]] = []
        
        for num, freq in frequency_map.items():
            if len(minHeap) < k:
                heapq.heappush(minHeap, (freq, num))
            else:
                if freq > minHeap[0][0]:
                    heapq.heapreplace(minHeap, (freq, num))
        
        # æå–å †ä¸­çš„å…ƒç´ 
        return [num for freq, num in minHeap]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    nums = [1, 1, 1, 2, 2, 3]
    k = 2
    result = solution.topKFrequent(nums, k)
    print(f"æ•°ç»„ä¸­å‡ºç°é¢‘ç‡æœ€é«˜çš„ {k} ä¸ªå…ƒç´ æ˜¯: {result}")  # è¾“å‡º: [1, 2]

    nums = [4, 1, -1, 2, -1, 2, 3]
    k = 2
    result = solution.topKFrequent(nums, k)
    print(f"æ•°ç»„ä¸­å‡ºç°é¢‘ç‡æœ€é«˜çš„ {k} ä¸ªå…ƒç´ æ˜¯: {result}")  # è¾“å‡º: [-1, 2]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ
```

### è§£é‡Š

1. **ç»Ÿè®¡é¢‘ç‡**ï¼š
   - ä½¿ç”¨ `collections.Counter` æ¥ç»Ÿè®¡æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡ï¼Œå¾—åˆ°ä¸€ä¸ªé¢‘ç‡å­—å…¸ `frequency_map`ã€‚

2. **ä½¿ç”¨æœ€å°å †ç»´æŠ¤é¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ **ï¼š
   - åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„æœ€å°å † `minHeap`ã€‚
   - éå†é¢‘ç‡å­—å…¸ä¸­çš„æ¯ä¸ªå…ƒç´ åŠå…¶é¢‘ç‡ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œåˆ™å°†å…ƒç´ åŠå…¶é¢‘ç‡æ¨å…¥å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰å…ƒç´ çš„é¢‘ç‡å¤§äºå †é¡¶å…ƒç´ çš„é¢‘ç‡ï¼Œåˆ™æ›¿æ¢å †é¡¶å…ƒç´ ï¼Œå¹¶è°ƒæ•´å †ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - éå†ç»“æŸåï¼Œå †ä¸­çš„å…ƒç´ å³ä¸ºé¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ ã€‚
   - é€šè¿‡åˆ—è¡¨æ¨å¯¼å¼æå–å †ä¸­çš„å…ƒç´ ï¼Œè¿”å›ç»“æœã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - ç»Ÿè®¡é¢‘ç‡çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚
  - æ’å…¥å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„æœ€å°å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚
  - ä½¿ç”¨äº†é¢‘ç‡å­—å…¸ï¼Œå…¶ç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼ˆåœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼‰ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°æ‰¾å‡ºæ•°ç»„ä¸­å‡ºç°é¢‘ç‡æœ€é«˜çš„ K ä¸ªå…ƒç´ ã€‚

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        
        while len(self.heap) > k:
            heapq.heappop(self.heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:

        def remove_largest():
            index_of_largest = stones.index(max(stones))
            # Remove largest stone
            return stones.pop(index_of_largest)

        while len(stones) > 1:
            stone_1 = remove_largest()
            stone_2 = remove_largest()
            if stone_1 != stone_2:
                stones.append(stone_1 - stone_2)

        return stones[0] if stones else 0

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨æœ€å¤§å †ï¼ˆMax Heapï¼‰ã€‚ä½†æ˜¯ï¼Œç”±äºPythonçš„`heapq`æ¨¡å—é»˜è®¤åªæ”¯æŒæœ€å°å †ï¼ˆMin Heapï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹å…ƒç´ å–åæ¥æ¨¡æ‹Ÿæœ€å¤§å †ã€‚

ä»¥ä¸‹æ˜¯è¯¦ç»†çš„æ­¥éª¤å’Œç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨å †æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

### è§£å†³æ–¹æ¡ˆ

1. **æ„å»ºæœ€å¤§å †**ï¼š
   - å°†æ‰€æœ‰çŸ³å¤´çš„é‡é‡å–ååæ”¾å…¥æœ€å°å †ä¸­ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨æœ€å°å †æ¥æ¨¡æ‹Ÿæœ€å¤§å †çš„è¡Œä¸ºã€‚

2. **æ¨¡æ‹ŸçŸ³å¤´ç¢°æ’**ï¼š
   - åå¤ä»å †ä¸­å–å‡ºä¸¤ä¸ªæœ€å¤§å…ƒç´ ï¼ˆå®é™…ä¸Šæ˜¯å–ååçš„æœ€å°å…ƒç´ ï¼‰ï¼Œæ¨¡æ‹ŸçŸ³å¤´ç¢°æ’ã€‚
   - æ ¹æ®ç¢°æ’ç»“æœæ›´æ–°çŸ³å¤´é‡é‡ï¼Œå¹¶å°†ç»“æœé‡æ–°æ”¾å…¥å †ä¸­ã€‚
   
3. **è¿”å›ç»“æœ**ï¼š
   - å½“å †ä¸­åªå‰©ä¸€ä¸ªæˆ–é›¶ä¸ªå…ƒç´ æ—¶ï¼Œè¿”å›æœ€åä¸€ä¸ªå…ƒç´ çš„é‡é‡ï¼ˆå–ååçš„å€¼ï¼‰ï¼Œå¦‚æœæ²¡æœ‰å‰©ä½™å…ƒç´ ï¼Œè¿”å›0ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        # åˆ›å»ºä¸€ä¸ªæœ€å¤§å †
        maxHeap = [-stone for stone in stones]
        heapq.heapify(maxHeap)

        # æ¨¡æ‹ŸçŸ³å¤´ç¢°æ’
        while len(maxHeap) > 1:
            # å–å‡ºä¸¤å—æœ€é‡çš„çŸ³å¤´
            first = -heapq.heappop(maxHeap)
            second = -heapq.heappop(maxHeap)
            
            if first != second:
                # å¦‚æœä¸¤å—çŸ³å¤´é‡é‡ä¸åŒï¼Œè®¡ç®—å‰©ä½™é‡é‡å¹¶æ”¾å›å †ä¸­
                heapq.heappush(maxHeap, -(first - second))
        
        # å¦‚æœå †ä¸­è¿˜æœ‰çŸ³å¤´ï¼Œè¿”å›å…¶é‡é‡ï¼›å¦åˆ™è¿”å›0
        return -maxHeap[0] if maxHeap else 0

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    stones = [2, 7, 4, 1, 8, 1]
    result = solution.lastStoneWeight(stones)
    print(f"æœ€åå‰©ä¸‹çš„çŸ³å¤´é‡é‡æ˜¯: {result}")  # è¾“å‡º: 1
```

### è§£é‡Š

1. **æ„å»ºæœ€å¤§å †**ï¼š
   - å°†æ‰€æœ‰çŸ³å¤´çš„é‡é‡å–ååæ”¾å…¥åˆ—è¡¨ `maxHeap` ä¸­ï¼Œç„¶åä½¿ç”¨ `heapq.heapify` å°†åˆ—è¡¨è½¬æ¢ä¸ºæœ€å°å †ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ¨¡æ‹Ÿæœ€å¤§å †çš„è¡Œä¸ºã€‚

2. **æ¨¡æ‹ŸçŸ³å¤´ç¢°æ’**ï¼š
   - ä½¿ç”¨ `heapq.heappop` ä»å †ä¸­å–å‡ºä¸¤ä¸ªæœ€é‡çš„çŸ³å¤´ï¼ˆå®é™…ä¸Šæ˜¯å–ååçš„æœ€å°å…ƒç´ ï¼‰ï¼Œç„¶åæ¨¡æ‹Ÿç¢°æ’ã€‚
   - å¦‚æœä¸¤å—çŸ³å¤´é‡é‡ç›¸åŒï¼Œåˆ™ä¸¤å—çŸ³å¤´éƒ½è¢«æ‘§æ¯ã€‚
   - å¦‚æœä¸¤å—çŸ³å¤´é‡é‡ä¸åŒï¼Œåˆ™è®¡ç®—å‰©ä½™é‡é‡å¹¶å°†å…¶é‡æ–°æ”¾å…¥å †ä¸­ï¼ˆå–ååï¼‰ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - å½“å †ä¸­åªå‰©ä¸€ä¸ªæˆ–é›¶ä¸ªå…ƒç´ æ—¶ï¼Œè¿”å›æœ€åä¸€ä¸ªå…ƒç´ çš„é‡é‡ï¼ˆå–ååçš„å€¼ï¼‰ï¼Œå¦‚æœæ²¡æœ‰å‰©ä½™å…ƒç´ ï¼Œè¿”å›0ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ„å»ºå †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯çŸ³å¤´çš„æ•°é‡ã€‚
  - æ¯æ¬¡ç¢°æ’æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(log N)ã€‚
  - æœ€åæƒ…å†µä¸‹éœ€è¦è¿›è¡Œ N-1 æ¬¡ç¢°æ’æ“ä½œï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log N)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†ä¸€ä¸ªå¤§å°ä¸º N çš„å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(N)ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¹¶æ‰¾å‡ºæœ€åå‰©ä¸‹çš„çŸ³å¤´é‡é‡ã€‚

è¦æ‰¾åˆ°çŸ©é˜µä¸­æœ€å¼±çš„ K è¡Œï¼Œå¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

1. **è®¡ç®—æ¯è¡Œçš„å£«å…µæ•°é‡**ï¼šå¯¹äºæ¯ä¸€è¡Œï¼Œè®¡ç®—å…¶ä¸­ `1` çš„æ•°é‡ï¼Œè¿™è¡¨ç¤ºå£«å…µçš„æ•°é‡ã€‚
2. **å°†è¡Œç´¢å¼•å’Œå£«å…µæ•°é‡ç»“åˆèµ·æ¥**ï¼šå°†æ¯ä¸€è¡Œçš„ç´¢å¼•å’Œå¯¹åº”çš„å£«å…µæ•°é‡å­˜å‚¨åœ¨ä¸€ä¸ªåˆ—è¡¨ä¸­ã€‚
3. **æ’åº**ï¼šé¦–å…ˆæŒ‰ç…§å£«å…µæ•°é‡æ’åºï¼Œå¦‚æœå£«å…µæ•°é‡ç›¸åŒåˆ™æŒ‰è¡Œç´¢å¼•æ’åºã€‚
4. **è¿”å›å‰ K ä¸ªæœ€å¼±çš„è¡Œç´¢å¼•**ï¼šä»æ’åºåçš„åˆ—è¡¨ä¸­æå–å‰ K ä¸ªæœ€å¼±çš„è¡Œçš„ç´¢å¼•ã€‚

### ç¤ºä¾‹ä»£ç 

```python
from typing import List

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # è®¡ç®—æ¯è¡Œçš„å£«å…µæ•°é‡å¹¶å­˜å‚¨ç´¢å¼•
        soldier_count = []
        for index, row in enumerate(mat):
            count = sum(row)
            soldier_count.append((count, index))
        
        # æ ¹æ®å£«å…µæ•°é‡å’Œè¡Œç´¢å¼•æ’åº
        soldier_count.sort(key=lambda x: (x[0], x[1]))
        
        # æå–å‰ k ä¸ªæœ€å¼±çš„è¡Œç´¢å¼•
        return [x[1] for x in soldier_count[:k]]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    mat = [
        [1, 1, 0, 0, 0],
        [1, 1, 1, 1, 0],
        [1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0],
        [1, 1, 1, 1, 1]
    ]
    k = 3
    result = solution.kWeakestRows(mat, k)
    print(f"çŸ©é˜µä¸­æœ€å¼±çš„ {k} è¡Œçš„ç´¢å¼•æ˜¯: {result}")  # è¾“å‡º: [2, 0, 3]
```

### è§£é‡Š

1. **è®¡ç®—æ¯è¡Œçš„å£«å…µæ•°é‡**ï¼š
   - éå†çŸ©é˜µä¸­çš„æ¯ä¸€è¡Œï¼Œè®¡ç®—è¯¥è¡Œä¸­ `1` çš„æ•°é‡ã€‚
   - å°†æ¯è¡Œçš„å£«å…µæ•°é‡å’Œè¡Œç´¢å¼•å­˜å‚¨åœ¨ä¸€ä¸ªå…ƒç»„åˆ—è¡¨ä¸­ï¼Œä¾‹å¦‚ `[(2, 0), (4, 1), (1, 2)]`ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å£«å…µæ•°é‡ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯è¡Œç´¢å¼•ã€‚

2. **æ’åº**ï¼š
   - ä½¿ç”¨ `sort` æ–¹æ³•å¯¹å…ƒç»„åˆ—è¡¨è¿›è¡Œæ’åºã€‚æ’åºçš„ä¸»é”®æ˜¯å£«å…µæ•°é‡ï¼Œå¦‚æœå£«å…µæ•°é‡ç›¸åŒï¼Œåˆ™æŒ‰è¡Œç´¢å¼•æ’åºã€‚

3. **æå–å‰ K ä¸ªæœ€å¼±çš„è¡Œç´¢å¼•**ï¼š
   - ä»æ’åºåçš„åˆ—è¡¨ä¸­æå–å‰ K ä¸ªæœ€å¼±çš„è¡Œçš„ç´¢å¼•ï¼Œè¿”å›è¿™äº›ç´¢å¼•ä½œä¸ºç»“æœã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - è®¡ç®—å£«å…µæ•°é‡çš„æ—¶é—´å¤æ‚åº¦ä¸º O(m * n)ï¼Œå…¶ä¸­ m æ˜¯çŸ©é˜µçš„è¡Œæ•°ï¼Œn æ˜¯åˆ—æ•°ã€‚
  - æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º O(m log m)ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(m * n + m log m)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†é¢å¤–çš„ç©ºé—´æ¥å­˜å‚¨å£«å…µæ•°é‡å’Œè¡Œç´¢å¼•ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(m)ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”æ˜“äºç†è§£ï¼Œå¯ä»¥ç”¨æ¥å¿«é€Ÿæ‰¾åˆ°çŸ©é˜µä¸­æœ€å¼±çš„ K è¡Œã€‚

è¦åœ¨ä¸€ä¸ªæŒ‰è¡Œå’Œåˆ—æ’åºçš„ n x n çŸ©é˜µä¸­æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•ï¼š

1. **ä½¿ç”¨æœ€å°å †**ï¼šå°†æ¯è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ”¾å…¥æœ€å°å †ä¸­ã€‚æ¯æ¬¡ä»å †ä¸­å–å‡ºæœ€å°å…ƒç´ ï¼Œç„¶åå°†è¯¥å…ƒç´ æ‰€åœ¨è¡Œçš„ä¸‹ä¸€ä¸ªå…ƒç´ åŠ å…¥å †ä¸­ã€‚é‡å¤è¿™ä¸€è¿‡ç¨‹ k æ¬¡ï¼Œå †é¡¶å…ƒç´ å³ä¸ºç¬¬ k å°çš„å…ƒç´ ã€‚

2. **äºŒåˆ†æŸ¥æ‰¾**ï¼šç”±äºçŸ©é˜µä¸­çš„æ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—éƒ½æ˜¯æ’åºçš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•æ¥å®šä½ç¬¬ k å°çš„å…ƒç´ ã€‚

### æ–¹æ³•ä¸€ï¼šä½¿ç”¨æœ€å°å †

#### è¯¦ç»†æ­¥éª¤ï¼š
1. åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º k çš„æœ€å°å †ã€‚
2. å°†æ¯è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°æœ€å°å †ä¸­ã€‚
3. é‡å¤ k æ¬¡ä»å †ä¸­å–å‡ºæœ€å°å…ƒç´ ï¼Œå¹¶å°†è¯¥å…ƒç´ æ‰€åœ¨è¡Œçš„ä¸‹ä¸€ä¸ªå…ƒç´ åŠ å…¥å †ä¸­ã€‚
4. ç¬¬ k æ¬¡å–å‡ºçš„å…ƒç´ å³ä¸ºç¬¬ k å°çš„å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        # æœ€å°å †ï¼Œå­˜å‚¨å…ƒç´ å’Œå…ƒç´ çš„ä½ç½®ï¼ˆrow, colï¼‰
        minHeap = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(minHeap)
        
        # è¿›è¡Œ k æ¬¡å–å †é¡¶å…ƒç´ çš„æ“ä½œ
        for _ in range(k - 1):
            element, row, col = heapq.heappop(minHeap)
            if col + 1 < n:
                heapq.heappush(minHeap, (matrix[row][col + 1], row, col + 1))
        
        # ç¬¬ k æ¬¡å–å‡ºçš„å †é¡¶å…ƒç´ å³ä¸ºç¬¬ k å°çš„å…ƒç´ 
        return heapq.heappop(minHeap)[0]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    matrix = [
        [1, 5, 9],
        [10, 11, 13],
        [12, 13, 15]
    ]
    k = 8
    result = solution.kthSmallest(matrix, k)
    print(f"çŸ©é˜µä¸­ç¬¬ {k} å°çš„å…ƒç´ æ˜¯: {result}")  # è¾“å‡º: 13
```

### æ–¹æ³•äºŒï¼šäºŒåˆ†æŸ¥æ‰¾

#### è¯¦ç»†æ­¥éª¤ï¼š
1. ä½¿ç”¨çŸ©é˜µçš„æœ€å°å€¼å’Œæœ€å¤§å€¼æ¥å®šä¹‰äºŒåˆ†æŸ¥æ‰¾çš„èŒƒå›´ã€‚
2. åœ¨èŒƒå›´å†…è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œæ¯æ¬¡çŒœä¸€ä¸ªä¸­é—´å€¼ midï¼Œç„¶åç»Ÿè®¡çŸ©é˜µä¸­å°äºç­‰äº mid çš„å…ƒç´ ä¸ªæ•°ã€‚
3. æ ¹æ®ç»Ÿè®¡ç»“æœè°ƒæ•´æŸ¥æ‰¾èŒƒå›´ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç 

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        
        def countLessEqual(mid):
            count = 0
            row, col = n - 1, 0
            while row >= 0 and col < n:
                if matrix[row][col] <= mid:
                    count += row + 1
                    col += 1
                else:
                    row -= 1
            return count
        
        left, right = matrix[0][0], matrix[n - 1][n - 1]
        while left < right:
            mid = (left + right) // 2
            if countLessEqual(mid) < k:
                left = mid + 1
            else:
                right = mid
        
        return left

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    matrix = [
        [1, 5, 9],
        [10, 11, 13],
        [12, 13, 15]
    ]
    k = 8
    result = solution.kthSmallest(matrix, k)
    print(f"çŸ©é˜µä¸­ç¬¬ {k} å°çš„å…ƒç´ æ˜¯: {result}")  # è¾“å‡º: 13
```

### è§£é‡Š

1. **ä½¿ç”¨æœ€å°å †çš„æ–¹æ³•**ï¼š
   - åˆå§‹æ—¶å°†æ¯è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ”¾å…¥æœ€å°å †ã€‚
   - æ¯æ¬¡ä»å †ä¸­å–å‡ºæœ€å°å…ƒç´ ï¼Œå°†è¯¥å…ƒç´ æ‰€åœ¨è¡Œçš„ä¸‹ä¸€ä¸ªå…ƒç´ åŠ å…¥å †ã€‚
   - é‡å¤è¿™ä¸€è¿‡ç¨‹ k æ¬¡ï¼Œç¬¬ k æ¬¡å–å‡ºçš„å…ƒç´ å³ä¸ºç¬¬ k å°çš„å…ƒç´ ã€‚

2. **ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•**ï¼š
   - åœ¨çŸ©é˜µçš„æœ€å°å€¼å’Œæœ€å¤§å€¼èŒƒå›´å†…è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ã€‚
   - æ¯æ¬¡çŒœä¸€ä¸ªä¸­é—´å€¼ midï¼Œç»Ÿè®¡çŸ©é˜µä¸­å°äºç­‰äº mid çš„å…ƒç´ ä¸ªæ•°ã€‚
   - æ ¹æ®ç»Ÿè®¡ç»“æœè°ƒæ•´æŸ¥æ‰¾èŒƒå›´ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

1. **æœ€å°å †æ–¹æ³•**ï¼š
   - æ—¶é—´å¤æ‚åº¦ï¼šO(k log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

2. **äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•**ï¼š
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log(max - min))
   - ç©ºé—´å¤æ‚åº¦ï¼šO(1)

è¿™ä¸¤ç§æ–¹æ³•éƒ½å¯ä»¥æœ‰æ•ˆåœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…¶ä¸­äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•çš„ç©ºé—´å¤æ‚åº¦æ›´ä¼˜ã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨åŸºäºæœ€å°å †çš„è´ªå¿ƒç®—æ³•ã€‚æ ¸å¿ƒæ€æƒ³æ˜¯ä¿æŒè·Ÿè¸ªæ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„ä¼šè®®ï¼Œå¹¶åœ¨éœ€è¦æ—¶åˆ†é…æ–°çš„ä¼šè®®å®¤ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. **å°†ä¼šè®®æ—¶é—´åŒºé—´æŒ‰å¼€å§‹æ—¶é—´æ’åº**ã€‚
2. **ä½¿ç”¨æœ€å°å †è¿½è¸ªå½“å‰ä¼šè®®çš„ç»“æŸæ—¶é—´**ã€‚
3. **éå†æ‰€æœ‰ä¼šè®®æ—¶é—´åŒºé—´**ï¼š
   - å¦‚æœæœ€å°å †ä¸­çš„æœ€æ—©ç»“æŸæ—¶é—´å°äºæˆ–ç­‰äºå½“å‰ä¼šè®®çš„å¼€å§‹æ—¶é—´ï¼Œè¯´æ˜å½“å‰ä¼šè®®å¯ä»¥å¤ç”¨è¯¥ä¼šè®®å®¤ï¼Œå› æ­¤å°†æœ€å°å †ä¸­çš„æœ€æ—©ç»“æŸæ—¶é—´å¼¹å‡ºã€‚
   - å°†å½“å‰ä¼šè®®çš„ç»“æŸæ—¶é—´åŠ å…¥æœ€å°å †ã€‚
4. **æœ€å°å †çš„å¤§å°å³ä¸ºæ‰€éœ€çš„æœ€å°‘ä¼šè®®å®¤æ•°é‡**ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        # æŒ‰ç…§ä¼šè®®çš„å¼€å§‹æ—¶é—´è¿›è¡Œæ’åº
        intervals.sort(key=lambda x: x[0])
        
        # åˆå§‹åŒ–ä¸€ä¸ªæœ€å°å †
        minHeap = []
        
        # å°†ç¬¬ä¸€ä¸ªä¼šè®®çš„ç»“æŸæ—¶é—´åŠ å…¥æœ€å°å †
        heapq.heappush(minHeap, intervals[0][1])
        
        # éå†å‰©ä½™çš„ä¼šè®®æ—¶é—´åŒºé—´
        for i in range(1, len(intervals)):
            # å¦‚æœæœ€æ—©çš„ç»“æŸæ—¶é—´å°äºæˆ–ç­‰äºå½“å‰ä¼šè®®çš„å¼€å§‹æ—¶é—´ï¼Œå¼¹å‡ºæœ€æ—©çš„ç»“æŸæ—¶é—´
            if minHeap[0] <= intervals[i][0]:
                heapq.heappop(minHeap)
            
            # å°†å½“å‰ä¼šè®®çš„ç»“æŸæ—¶é—´åŠ å…¥æœ€å°å †
            heapq.heappush(minHeap, intervals[i][1])
        
        # æœ€å°å †çš„å¤§å°å³ä¸ºæ‰€éœ€çš„ä¼šè®®å®¤æ•°é‡
        return len(minHeap)

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    intervals = [[0, 30], [5, 10], [15, 20]]
    result = solution.minMeetingRooms(intervals)
    print(f"æ‰€éœ€çš„æœ€å°‘ä¼šè®®å®¤æ•°é‡æ˜¯: {result}")  # è¾“å‡º: 2
    
    intervals = [[7, 10], [2, 4]]
    result = solution.minMeetingRooms(intervals)
    print(f"æ‰€éœ€çš„æœ€å°‘ä¼šè®®å®¤æ•°é‡æ˜¯: {result}")  # è¾“å‡º: 1
```

### è§£é‡Š

1. **æ’åºä¼šè®®æ—¶é—´åŒºé—´**ï¼š
   - ä½¿ç”¨ `sort` å‡½æ•°æŒ‰ä¼šè®®çš„å¼€å§‹æ—¶é—´å¯¹æ‰€æœ‰ä¼šè®®æ—¶é—´åŒºé—´è¿›è¡Œæ’åºã€‚

2. **ä½¿ç”¨æœ€å°å †è¿½è¸ªä¼šè®®ç»“æŸæ—¶é—´**ï¼š
   - åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„æœ€å°å †ã€‚
   - å°†ç¬¬ä¸€ä¸ªä¼šè®®çš„ç»“æŸæ—¶é—´åŠ å…¥æœ€å°å †ã€‚

3. **éå†æ‰€æœ‰ä¼šè®®æ—¶é—´åŒºé—´**ï¼š
   - å¯¹äºæ¯ä¸ªä¼šè®®ï¼Œå¦‚æœå½“å‰ä¼šè®®çš„å¼€å§‹æ—¶é—´å¤§äºæˆ–ç­‰äºæœ€å°å †ä¸­çš„æœ€æ—©ç»“æŸæ—¶é—´ï¼Œè¯´æ˜å½“å‰ä¼šè®®å¯ä»¥ä½¿ç”¨åŒä¸€ä¸ªä¼šè®®å®¤ã€‚å› æ­¤ï¼Œå°†æœ€å°å †ä¸­çš„æœ€æ—©ç»“æŸæ—¶é—´å¼¹å‡ºã€‚
   - å°†å½“å‰ä¼šè®®çš„ç»“æŸæ—¶é—´åŠ å…¥æœ€å°å †ã€‚

4. **è¿”å›æœ€å°å †çš„å¤§å°**ï¼š
   - æœ€å°å †çš„å¤§å°å³ä¸ºæ‰€éœ€çš„æœ€å°‘ä¼šè®®å®¤æ•°é‡ï¼Œå› ä¸ºå †ä¸­å­˜å‚¨äº†æ‰€æœ‰å½“å‰æ­£åœ¨è¿›è¡Œçš„ä¼šè®®çš„ç»“æŸæ—¶é—´ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’åºæ—¶é—´å¤æ‚åº¦ä¸º O(N log N)ï¼Œå…¶ä¸­ N æ˜¯ä¼šè®®æ—¶é—´åŒºé—´çš„æ•°é‡ã€‚
  - éå†æ‰€æœ‰ä¼šè®®æ—¶é—´åŒºé—´å¹¶ç»´æŠ¤æœ€å°å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N log N)ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log N)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - æœ€å°å †çš„ç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼Œå› ä¸ºåœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ‰€æœ‰ä¼šè®®éƒ½å¯èƒ½éœ€è¦ç‹¬ç«‹çš„ä¼šè®®å®¤ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”æ˜“äºå®ç°ï¼Œå¯ä»¥ç”¨æ¥è§£å†³éœ€è¦æ‰¾åˆ°æœ€å°‘ä¼šè®®å®¤æ•°é‡çš„é—®é¢˜ã€‚

è¦æ‰¾åˆ°è·ç¦»åŸç‚¹æœ€è¿‘çš„ K ä¸ªç‚¹ï¼Œå¯ä»¥ä½¿ç”¨æœ€å¤§å †ï¼ˆMax Heapï¼‰æ¥é«˜æ•ˆåœ°è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æ ¸å¿ƒæ€æƒ³æ˜¯ä½¿ç”¨ä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å¤§å †æ¥ç»´æŠ¤å½“å‰æ‰¾åˆ°çš„è·ç¦»åŸç‚¹æœ€è¿‘çš„ K ä¸ªç‚¹ã€‚

### è§£å†³æ–¹æ¡ˆ

1. **è®¡ç®—æ¯ä¸ªç‚¹åˆ°åŸç‚¹çš„è·ç¦»**ï¼š
   - ä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»ï¼Œä½†ç”±äºæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹è·ç¦»ï¼Œå¯ä»¥å¿½ç•¥å¹³æ–¹æ ¹ï¼Œç›´æ¥æ¯”è¾ƒå¹³æ–¹çš„è·ç¦»ã€‚

2. **ä½¿ç”¨æœ€å¤§å †ç»´æŠ¤ K ä¸ªæœ€è¿‘çš„ç‚¹**ï¼š
   - å¦‚æœå †çš„å¤§å°å°äº Kï¼Œå°†å½“å‰ç‚¹åŠ å…¥å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰ç‚¹è·ç¦»å°äºå †é¡¶ç‚¹çš„è·ç¦»ï¼Œåˆ™æ›¿æ¢å †é¡¶ç‚¹ï¼Œå¹¶è°ƒæ•´å †ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - å †ä¸­çš„ç‚¹å³ä¸ºè·ç¦»åŸç‚¹æœ€è¿‘çš„ K ä¸ªç‚¹ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List, Tuple

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        # å®šä¹‰ä¸€ä¸ªæœ€å¤§å †
        maxHeap: List[Tuple[int, int, int]] = []
        
        for (x, y) in points:
            dist = -(x * x + y * y)  # è®¡ç®—è·ç¦»çš„å¹³æ–¹å¹¶å–è´Ÿæ•°ï¼Œä»¥ä¾¿ä½¿ç”¨æœ€å°å †æ¨¡æ‹Ÿæœ€å¤§å †
            if len(maxHeap) < k:
                heapq.heappush(maxHeap, (dist, x, y))
            else:
                if dist > maxHeap[0][0]:
                    heapq.heappop(maxHeap)
                    heapq.heappush(maxHeap, (dist, x, y))
        
        # ä»å †ä¸­å–å‡º k ä¸ªæœ€è¿‘çš„ç‚¹
        return [(x, y) for (dist, x, y) in maxHeap]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    points = [[1, 3], [-2, 2], [5, 8], [0, 1]]
    k = 2
    result = solution.kClosest(points, k)
    print(f"è·ç¦»åŸç‚¹æœ€è¿‘çš„ {k} ä¸ªç‚¹æ˜¯: {result}")  # è¾“å‡º: [[-2, 2], [0, 1]]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ
    
    points = [[3, 3], [5, -1], [-2, 4]]
    k = 2
    result = solution.kClosest(points, k)
    print(f"è·ç¦»åŸç‚¹æœ€è¿‘çš„ {k} ä¸ªç‚¹æ˜¯: {result}")  # è¾“å‡º: [[3, 3], [-2, 4]]ï¼Œé¡ºåºå¯èƒ½ä¸åŒ
```

### è§£é‡Š

1. **è®¡ç®—æ¯ä¸ªç‚¹åˆ°åŸç‚¹çš„è·ç¦»**ï¼š
   - è®¡ç®—ç‚¹ (x, y) åˆ°åŸç‚¹çš„è·ç¦»å¹³æ–¹ `x*x + y*y`ã€‚ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨æœ€å°å †æ¥æ¨¡æ‹Ÿæœ€å¤§å †ï¼Œå–è´Ÿæ•°å­˜å‚¨è·ç¦»å¹³æ–¹ã€‚

2. **ä½¿ç”¨æœ€å¤§å †ç»´æŠ¤ K ä¸ªæœ€è¿‘çš„ç‚¹**ï¼š
   - åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„æœ€å¤§å † `maxHeap`ã€‚
   - éå†æ‰€æœ‰ç‚¹ï¼Œå¯¹äºæ¯ä¸ªç‚¹ï¼Œå¦‚æœå †çš„å¤§å°å°äº Kï¼Œç›´æ¥å°†ç‚¹åŠ å…¥å †ä¸­ã€‚
   - å¦‚æœå †çš„å¤§å°ç­‰äº Kï¼Œä¸”å½“å‰ç‚¹çš„è·ç¦»å°äºå †é¡¶ç‚¹çš„è·ç¦»ï¼Œåˆ™å¼¹å‡ºå †é¡¶ç‚¹ï¼Œå¹¶å°†å½“å‰ç‚¹åŠ å…¥å †ä¸­ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - å †ä¸­çš„ç‚¹å³ä¸ºè·ç¦»åŸç‚¹æœ€è¿‘çš„ K ä¸ªç‚¹ã€‚é€šè¿‡åˆ—è¡¨æ¨å¯¼å¼ä»å †ä¸­æå–ç‚¹å¹¶è¿”å›ç»“æœã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ’å…¥å’Œè°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log K)ã€‚
  - éå†æ‰€æœ‰ç‚¹çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯ç‚¹çš„æ•°é‡ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log K)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º K çš„æœ€å¤§å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(K)ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”é€‚ç”¨äºéœ€è¦æ‰¾åˆ°è·ç¦»åŸç‚¹æœ€è¿‘çš„ K ä¸ªç‚¹çš„é—®é¢˜ã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•å’Œæœ€å°å †ï¼ˆMin Heapï¼‰æ¥é«˜æ•ˆåœ°æ‰¾åˆ°æœ€å°çš„åˆå¹¶æˆæœ¬ã€‚æ¯æ¬¡æ€»æ˜¯é€‰æ‹©æœ€çŸ­çš„ä¸¤æ ¹æœ¨æ£è¿›è¡Œåˆå¹¶ï¼Œä»¥ç¡®ä¿æ¯æ¬¡åˆå¹¶çš„æˆæœ¬æœ€å°ã€‚

### è§£å†³æ–¹æ¡ˆ

1. **åˆå§‹åŒ–æœ€å°å †**ï¼šå°†æ‰€æœ‰æœ¨æ£çš„é•¿åº¦æ”¾å…¥æœ€å°å †ä¸­ã€‚
2. **åˆå¹¶æœ¨æ£**ï¼šé‡å¤ä»¥ä¸‹æ­¥éª¤ç›´åˆ°å †ä¸­åªå‰©ä¸€æ ¹æœ¨æ£ï¼š
   - ä»å †ä¸­å–å‡ºä¸¤æ ¹æœ€çŸ­çš„æœ¨æ£ã€‚
   - è®¡ç®—åˆå¹¶è¿™ä¸¤æ ¹æœ¨æ£çš„æˆæœ¬ï¼Œå¹¶å°†æˆæœ¬åŠ å…¥æ€»æˆæœ¬ä¸­ã€‚
   - å°†åˆå¹¶åçš„æ–°æœ¨æ£æ”¾å›å †ä¸­ã€‚
3. **è¿”å›æ€»æˆæœ¬**ï¼šå½“å †ä¸­åªå‰©ä¸€æ ¹æœ¨æ£æ—¶ï¼Œæ€»æˆæœ¬å³ä¸ºæœ€å°åˆå¹¶æˆæœ¬ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def connectSticks(self, sticks: List[int]) -> int:
        if len(sticks) == 1:
            return 0
        
        # åˆå§‹åŒ–æœ€å°å †
        heapq.heapify(sticks)
        
        total_cost = 0
        
        while len(sticks) > 1:
            # å–å‡ºä¸¤æ ¹æœ€çŸ­çš„æœ¨æ£
            first = heapq.heappop(sticks)
            second = heapq.heappop(sticks)
            
            # è®¡ç®—åˆå¹¶æˆæœ¬
            cost = first + second
            total_cost += cost
            
            # å°†åˆå¹¶åçš„æ–°æœ¨æ£æ”¾å›å †ä¸­
            heapq.heappush(sticks, cost)
        
        return total_cost

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    sticks = [2, 4, 3]
    result = solution.connectSticks(sticks)
    print(f"åˆå¹¶æ‰€æœ‰æœ¨æ£çš„æœ€å°æˆæœ¬æ˜¯: {result}")  # è¾“å‡º: 14
    
    sticks = [1, 8, 3, 5]
    result = solution.connectSticks(sticks)
    print(f"åˆå¹¶æ‰€æœ‰æœ¨æ£çš„æœ€å°æˆæœ¬æ˜¯: {result}")  # è¾“å‡º: 30
```

### è§£é‡Š

1. **åˆå§‹åŒ–æœ€å°å †**ï¼š
   - ä½¿ç”¨ `heapq.heapify` å°†æœ¨æ£æ•°ç»„è½¬æ¢ä¸ºæœ€å°å †ã€‚

2. **åˆå¹¶æœ¨æ£**ï¼š
   - ä½¿ç”¨ `heapq.heappop` ä»å †ä¸­å–å‡ºä¸¤æ ¹æœ€çŸ­çš„æœ¨æ£ã€‚
   - è®¡ç®—åˆå¹¶è¿™ä¸¤æ ¹æœ¨æ£çš„æˆæœ¬ï¼Œå¹¶å°†å…¶åŠ å…¥æ€»æˆæœ¬ã€‚
   - ä½¿ç”¨ `heapq.heappush` å°†åˆå¹¶åçš„æ–°æœ¨æ£æ”¾å›å †ä¸­ã€‚
   - é‡å¤ä»¥ä¸Šæ­¥éª¤ç›´åˆ°å †ä¸­åªå‰©ä¸€æ ¹æœ¨æ£ã€‚

3. **è¿”å›æ€»æˆæœ¬**ï¼š
   - å½“å †ä¸­åªå‰©ä¸€æ ¹æœ¨æ£æ—¶ï¼Œæ€»æˆæœ¬å³ä¸ºæœ€å°åˆå¹¶æˆæœ¬ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ„å»ºæœ€å°å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯æœ¨æ£çš„æ•°é‡ã€‚
  - æ¯æ¬¡åˆå¹¶æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(log N)ã€‚
  - æœ€å¤šéœ€è¦è¿›è¡Œ N-1 æ¬¡åˆå¹¶æ“ä½œï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log N)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - æœ€å°å †çš„ç©ºé—´å¤æ‚åº¦ä¸º O(N)ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°æ‰¾åˆ°åˆå¹¶æ‰€æœ‰æœ¨æ£çš„æœ€å°æˆæœ¬ã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ç»“åˆæœ€å°å †æ¥é«˜æ•ˆåœ°å†³å®šä½•æ—¶ä½¿ç”¨æ¢¯å­å’Œç –å—ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. **ä¼˜å…ˆä½¿ç”¨æ¢¯å­**ï¼šå¯¹äºæ¯æ¬¡é«˜åº¦çš„å¢åŠ ï¼Œä¼˜å…ˆä½¿ç”¨æ¢¯å­ã€‚è¿™æ ·å¯ä»¥åœ¨é«˜åº¦å¢åŠ è¾ƒå¤§çš„æ—¶å€™çµæ´»ä½¿ç”¨ç –å—ã€‚
2. **è®°å½•æ‰€æœ‰é«˜åº¦å¢åŠ å€¼**ï¼šä½¿ç”¨æœ€å°å †è®°å½•æ‰€æœ‰çš„é«˜åº¦å¢åŠ å€¼ã€‚
3. **å½“æ¢¯å­ç”¨å®Œæ—¶ï¼Œè€ƒè™‘ä½¿ç”¨ç –å—**ï¼šå¦‚æœæ¢¯å­ä¸å¤Ÿç”¨äº†ï¼Œåˆ™ç”¨æœ€å°çš„é«˜åº¦å¢åŠ å€¼æ¥æ›¿ä»£ä¸€ä¸ªæ¢¯å­ï¼Œç”¨ç –å—å¡«è¡¥è¿™ä¸ªé«˜åº¦å·®ã€‚
4. **åˆ¤æ–­æ˜¯å¦èƒ½ç»§ç»­å‰è¿›**ï¼šå¦‚æœç –å—ä¹Ÿä¸å¤Ÿç”¨äº†ï¼Œåˆ™è¿”å›å½“å‰èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•ã€‚

### ç¤ºä¾‹ä»£ç 

```python
import heapq
from typing import List

class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        # æœ€å°å †ï¼Œç”¨äºè®°å½•ä½¿ç”¨æ¢¯å­çš„é«˜åº¦å·®
        heap = []
        
        for i in range(len(heights) - 1):
            diff = heights[i + 1] - heights[i]
            
            # å¦‚æœå½“å‰å»ºç­‘çš„é«˜åº¦ä¸é«˜äºä¸‹ä¸€ä¸ªå»ºç­‘ï¼Œåˆ™ä¸éœ€è¦æ¢¯å­æˆ–ç –å—
            if diff > 0:
                heapq.heappush(heap, diff)
            
            # å¦‚æœæ¢¯å­ä¸å¤Ÿç”¨ï¼Œä½¿ç”¨ç –å—å¡«è¡¥æœ€å°çš„é«˜åº¦å·®
            if len(heap) > ladders:
                bricks -= heapq.heappop(heap)
            
            # å¦‚æœç –å—ä¹Ÿä¸å¤Ÿç”¨ï¼Œè¿”å›å½“å‰èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•
            if bricks < 0:
                return i
        
        # å¦‚æœç –å—è¶³å¤Ÿç”¨ï¼Œè¿”å›æœ€åä¸€ä¸ªå»ºç­‘ç´¢å¼•
        return len(heights) - 1

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    solution = Solution()
    
    heights = [4, 2, 7, 6, 9, 14, 12]
    bricks = 5
    ladders = 1
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•æ˜¯: {result}")  # è¾“å‡º: 4
    
    heights = [4, 12, 2, 7, 3, 18, 20, 3, 19]
    bricks = 10
    ladders = 2
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•æ˜¯: {result}")  # è¾“å‡º: 7
    
    heights = [14, 3, 19, 3]
    bricks = 17
    ladders = 0
    result = solution.furthestBuilding(heights, bricks, ladders)
    print(f"èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•æ˜¯: {result}")  # è¾“å‡º: 3
```

### è§£é‡Š

1. **ä¼˜å…ˆä½¿ç”¨æ¢¯å­**ï¼š
   - ä½¿ç”¨ `heapq.heappush(heap, diff)` å°†æ¯æ¬¡é«˜åº¦å¢åŠ å€¼åŠ å…¥æœ€å°å †ã€‚

2. **è€ƒè™‘ä½¿ç”¨ç –å—**ï¼š
   - å½“æ¢¯å­çš„æ•°é‡ä¸è¶³ä»¥è¦†ç›–æ‰€æœ‰é«˜åº¦å¢åŠ æ—¶ï¼Œä½¿ç”¨æœ€å°å †ä¸­çš„æœ€å°é«˜åº¦å·®å€¼ï¼Œç”¨ç –å—æ¥å¡«è¡¥è¿™ä¸ªå·®å€¼ã€‚
   - `bricks -= heapq.heappop(heap)` ä»æœ€å°å †ä¸­å–å‡ºæœ€å°çš„é«˜åº¦å·®å€¼å¹¶ç”¨ç –å—å¡«è¡¥ã€‚

3. **åˆ¤æ–­æ˜¯å¦èƒ½ç»§ç»­å‰è¿›**ï¼š
   - å¦‚æœç –å—æ•°é‡ä¸è¶³ä»¥å¡«è¡¥æœ€å°çš„é«˜åº¦å·®ï¼Œåˆ™è¿”å›å½“å‰èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•ã€‚
   - å¦‚æœç –å—è¶³å¤Ÿç”¨ï¼Œç»§ç»­å‰è¿›ï¼Œç›´åˆ°æœ€åä¸€ä¸ªå»ºç­‘ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - éå†å»ºç­‘çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N æ˜¯å»ºç­‘çš„æ•°é‡ã€‚
  - ç»´æŠ¤æœ€å°å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log L)ï¼Œå…¶ä¸­ L æ˜¯æ¢¯å­çš„æ•°é‡ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(N log L)ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä½¿ç”¨äº†å¤§å°ä¸º L çš„æœ€å°å †ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(L)ã€‚

é€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°å†³å®šä½•æ—¶ä½¿ç”¨æ¢¯å­å’Œç –å—ï¼Œå¹¶æ‰¾åˆ°èƒ½åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ç´¢å¼•ã€‚

è¦å®ç°ä¸€ä¸ªèƒ½å¤Ÿä»æ•°æ®æµä¸­æ‰¾åˆ°ä¸­ä½æ•°çš„ç±» `MedianFinder`ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªå †ï¼šä¸€ä¸ªæœ€å¤§å †å’Œä¸€ä¸ªæœ€å°å †ã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°ç»´æŠ¤æ•°æ®æµä¸­çš„ä¸­ä½æ•°ã€‚

å…·ä½“æ€è·¯æ˜¯ï¼š
- ä½¿ç”¨æœ€å¤§å †æ¥å­˜å‚¨è¾ƒå°çš„ä¸€åŠæ•°æ®ã€‚
- ä½¿ç”¨æœ€å°å †æ¥å­˜å‚¨è¾ƒå¤§çš„ä¸€åŠæ•°æ®ã€‚
- é€šè¿‡å¹³è¡¡ä¸¤ä¸ªå †çš„å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°æ‰¾åˆ°ä¸­ä½æ•°ã€‚

### å…·ä½“æ­¥éª¤ï¼š
1. **åˆå§‹åŒ–**ï¼šåˆ›å»ºä¸¤ä¸ªå †ï¼Œæœ€å¤§å †ç”¨äºå­˜å‚¨è¾ƒå°çš„ä¸€åŠæ•°æ®ï¼Œæœ€å°å †ç”¨äºå­˜å‚¨è¾ƒå¤§çš„ä¸€åŠæ•°æ®ã€‚
2. **æ·»åŠ æ•°æ®**ï¼š
   - å°†æ–°çš„æ•°å­—æ·»åŠ åˆ°æœ€å¤§å †ã€‚
   - å¦‚æœæœ€å¤§å †çš„æœ€å¤§å…ƒç´ å¤§äºæœ€å°å †çš„æœ€å°å…ƒç´ ï¼Œå°†æœ€å¤§å †çš„æœ€å¤§å…ƒç´ ç§»åŠ¨åˆ°æœ€å°å †ã€‚
   - å¦‚æœæœ€å¤§å †çš„å¤§å°è¶…è¿‡æœ€å°å †ï¼Œåˆ™å°†æœ€å¤§å †çš„æœ€å¤§å…ƒç´ ç§»åŠ¨åˆ°æœ€å°å †ï¼Œä»¥ä¿æŒå¹³è¡¡ã€‚
3. **æŸ¥æ‰¾ä¸­ä½æ•°**ï¼š
   - å¦‚æœä¸¤ä¸ªå †çš„å¤§å°ç›¸ç­‰ï¼Œä¸­ä½æ•°å°±æ˜¯ä¸¤ä¸ªå †é¡¶å…ƒç´ çš„å¹³å‡å€¼ã€‚
   - å¦‚æœæœ€å¤§å †çš„å¤§å°å¤§äºæœ€å°å †ï¼Œä¸­ä½æ•°å°±æ˜¯æœ€å¤§å †çš„å †é¡¶å…ƒç´ ã€‚

### ç¤ºä¾‹ä»£ç ï¼š

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.maxHeap = []  # æœ€å¤§å †ï¼Œå­˜å‚¨è¾ƒå°çš„ä¸€åŠæ•°æ®
        self.minHeap = []  # æœ€å°å †ï¼Œå­˜å‚¨è¾ƒå¤§çš„ä¸€åŠæ•°æ®

    def addNum(self, num: int) -> None:
        # å°†æ–°æ•°å­—æ·»åŠ åˆ°æœ€å¤§å †
        heapq.heappush(self.maxHeap, -num)
        
        # å¦‚æœæœ€å¤§å †çš„æœ€å¤§å…ƒç´ å¤§äºæœ€å°å †çš„æœ€å°å…ƒç´ ï¼Œåˆ™éœ€è¦è°ƒæ•´
        if self.maxHeap and self.minHeap and (-self.maxHeap[0] > self.minHeap[0]):
            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))
        
        # å¹³è¡¡ä¸¤ä¸ªå †çš„å¤§å°
        if len(self.maxHeap) > len(self.minHeap) + 1:
            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))
        elif len(self.minHeap) > len(self.maxHeap):
            heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))

    def findMedian(self) -> float:
        # å¦‚æœä¸¤ä¸ªå †çš„å¤§å°ç›¸ç­‰ï¼Œä¸­ä½æ•°æ˜¯ä¸¤ä¸ªå †é¡¶å…ƒç´ çš„å¹³å‡å€¼
        if len(self.maxHeap) == len(self.minHeap):
            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0
        # å¦‚æœæœ€å¤§å †çš„å¤§å°å¤§äºæœ€å°å †ï¼Œä¸­ä½æ•°æ˜¯æœ€å¤§å †çš„å †é¡¶å…ƒç´ 
        return -self.maxHeap[0]

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    medianFinder = MedianFinder()
    medianFinder.addNum(1)
    medianFinder.addNum(2)
    print(f"ä¸­ä½æ•°æ˜¯: {medianFinder.findMedian()}")  # è¾“å‡º: 1.5
    medianFinder.addNum(3)
    print(f"ä¸­ä½æ•°æ˜¯: {medianFinder.findMedian()}")  # è¾“å‡º: 2
```

### è§£é‡Š
1. **åˆå§‹åŒ–**ï¼šåˆ›å»ºä¸¤ä¸ªå †ï¼Œä¸€ä¸ªæœ€å¤§å † `maxHeap` ç”¨äºå­˜å‚¨è¾ƒå°çš„ä¸€åŠæ•°æ®ï¼Œä¸€ä¸ªæœ€å°å † `minHeap` ç”¨äºå­˜å‚¨è¾ƒå¤§çš„ä¸€åŠæ•°æ®ã€‚
2. **æ·»åŠ æ•°æ®**ï¼š
   - é¦–å…ˆå°†æ–°æ•°å­—æ·»åŠ åˆ°æœ€å¤§å †ã€‚
   - å¦‚æœæœ€å¤§å †çš„æœ€å¤§å…ƒç´ å¤§äºæœ€å°å †çš„æœ€å°å…ƒç´ ï¼Œè°ƒæ•´ä¸¤ä¸ªå †ä»¥ä¿æŒå¹³è¡¡ã€‚
   - å¦‚æœæœ€å¤§å †çš„å¤§å°è¶…è¿‡æœ€å°å †ä¸€ä¸ªä»¥ä¸Šï¼Œå°†æœ€å¤§å †çš„æœ€å¤§å…ƒç´ ç§»åŠ¨åˆ°æœ€å°å †ã€‚
3. **æŸ¥æ‰¾ä¸­ä½æ•°**ï¼š
   - å¦‚æœä¸¤ä¸ªå †çš„å¤§å°ç›¸ç­‰ï¼Œä¸­ä½æ•°æ˜¯ä¸¤ä¸ªå †é¡¶å…ƒç´ çš„å¹³å‡å€¼ã€‚
   - å¦‚æœæœ€å¤§å †çš„å¤§å°å¤§äºæœ€å°å †ï¼Œä¸­ä½æ•°æ˜¯æœ€å¤§å †çš„å †é¡¶å…ƒç´ ã€‚

### æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - æ·»åŠ æ•°æ®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log N)ã€‚
  - æŸ¥æ‰¾ä¸­ä½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼Œç”¨äºå­˜å‚¨æ•°æ®æµä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚

è¿™ç§æ–¹æ³•é«˜æ•ˆä¸”é€‚ç”¨äºå®æ—¶æ•°æ®æµä¸­æŸ¥æ‰¾ä¸­ä½æ•°çš„é—®é¢˜ã€‚

