https://www.hiredintech.com/algorithms/algorithm-design-canvas/

Canvas 包含 5 个主要区域：约束、想法、复杂性、代码和测试。总而言之，它们涵盖了您在算法设计问题方面需要担心的所有问题。在接下来的章节中，我们将介绍每个区域代表什么，以及填写它们的许多技巧和窍门。我们还将通过一些示例让您了解 Canvas 的实际作用。
领域 #1：约束
约束区域用于填写问题的所有约束。这包括输入数组的大小、输入字符串是否包含 Unicode 字符、机器人是否允许在迷宫中进行对角移动、图形是否具有负边等。
分析算法设计问题时，您的首要任务是找出所有相关约束，并将它们记录在此区域。在此处了解有关约束的更多信息。
领域 #2：创意
确定所有限制条件后，您便开始构思创意。通常在面试期间，您会讨论 1 到 3 个创意。通常，您会先提出一个创意，向面试官解释，然后再提出更好的创意。
您的下一个目标是填写您的想法的简洁描述：简短而有趣，以便任何面试官都能理解。从这里开始了解有关创意生成的更多信息。
领域#3：复杂性
每个想法都有两个对应的复杂性领域：时间和内存。对于您描述的每种算法，您都需要能够估计其时间和内存复杂性。在本课程的后面，我们将讨论时间与内存之间的权衡，以及为什么它是任何算法设计问题的关键。
在此了解如何分析算法复杂性。
领域#4：代码
在你确定了问题的限制、讨论了一些想法、分析了它们的复杂性并找到了你和面试官都认为值得实施的想法之后，你终于可以开始编写代码了。
在面试中编写代码与在 IDE 中编写代码有着根本的不同。要了解原因以及如何在面试中编写代码，请访问此处。
领域 #5：测试
最后，你开始编写测试用例并测试你的代码。许多人完全忽略了这一步。这根本不明智。
在此详细了解好测试与坏测试的区别。
就是这样。
通过在准备和面试期间认真遵循此流程，您将远远领先于大多数候选人。现在，您无需再茫然不知下一步该做什么，而是掌握了可以遵循的流程蓝图来解决任何问题。
现在继续打印一些画
任务约束
你永远不想解决一个定义不明确的问题。这就是为什么在算法设计问题上你首先要考虑的是问题的约束。
约束的重要性
开发一个对 50 个数字进行排序的算法与开发一个对 50 亿个字符串（每个字符串有 100 万个字符）进行排序的算法有着根本的不同。因此，如果我告诉你“设计一个对数组进行排序的算法”，你最好不要马上开始编写解决方案。除其他事项外，你还需要了解数组中的内容以及数组可以达到多大。
你可能知道面试问题有很多限制，这些限制会告诉你解决方案的效率。不太明显的是，面试官并不总是会给你所有需要的信息。他们希望你问一些澄清问题。如果问题陈述中没有把所有事情都说清楚，不要惊慌，这是你让问题变得清晰的机会。
如何找出正确的问题？
一般来说，考虑所有与解决方案相关的事情。例如，确保您知道语句中任何键值的最小和最大可能值。这些可能会直接影响解决方案的性能。如果有值数组，您还需要知道这些值的范围。它们可以是数字、字符、几何图形等。当您听到语句时，其中一些应该自然而然地浮现在您脑海中。如果它说有 N 个数字，而没有提到 N 的其他内容，请询问它可以有多大。当您开始设计解决方案时，可能会出现其他问题。如果给定值对于解决方案的复杂性很重要，请不要犹豫询问它。永远不要自己假设事情。
算法设计画布可帮助您在面试时收集所需的信息。它有一个部分，您需要在其中填写问题中的所有重要约束。如果您在练习时使用它，您将养成确保了解设计有效解决方案所需的一切的习惯。
填写约束框无非就是向面试官提出正确的问题。每个问题都不同，但为了帮助您入门，我们编制了一份相当详尽的清单，列出了您应该关注的常见事项。所有这些都包含在常见约束讲义中。请随意下载并打印出来：它会派上用场的！
获取常见约束讲义 (PDF)
上面的讲义将帮助您很好地了解大多数面试问题中什么是重要的。除此之外，您还必须练习实际问题以获得经验。为此，您将能够在课程中进一步使用我们推荐的问题。
例子
下面就是我们如何将这一切应用到我们的样本之字形问题中。
注意：在此视频中，大约 4:40，作者在画布中输入 2 元素子序列都是 ZigZag 序列。这并不总是正确的。第 4 个约束应该是“1 元素子序列是 ZigZag”。
创意生成
本课程的目标之一是教您如何解决新问题。这将是本节的主题。我们认为学习如何设计解决方案比试图涵盖所有现有的面试问题要好得多。原因有几个。
首先，新的面试问题层出不穷。几乎不可能记住所有问题。其次，即使你知道许多问题的答案，你也需要能够分析这些答案，讨论它们，并能够在面试官决定以某种方式修改问题时对其进行调整。
最后一个原因是，雇主正在寻找能够当场想出解决方案的人。这就是为什么学习如何成为这样的人非常有用。
那么，你如何才能实现这一点呢？在本节中，我们将讨论解决算法问题的几种策略。它们将为你提供一个解决问题并提出良好解决方案的小框架。
请记住，练习解决问题是真正保持良好状态的唯一方法。这些策略是您可以使用的一种工具，但只有投入足够的时间应用它，您才能熟练掌握它。实际上，随着时间的推移，您会注意到问题中的各种模式，破解它们会变得容易得多。
以下策略在参加编程竞赛的人中很受欢迎。由于算法面试问题与这些非常相似，我们认为它们在这里也非常相关。
简化任务
我们来看看下面的问题：
“给出一张街道地图，其形状为具有 N 列和 M 行的矩形网格。这些街道的交叉口处有人。他们都想在一个路口相遇。目标是选择这样一个路口，使所有人的总步行距离最小化。请记住，他们只能沿着街道行走（所谓的“曼哈顿距离”）。”
那么，我们该如何解决这个问题呢？
想象一下，我们只有一条街，人们在这条街上处于不同的位置。他们会在这条街上寻找一个最佳的会面地点。你能解决这个问题吗？事实证明，它比二维版本容易得多。你只需要找到街上所有人位置的中值，这就是最佳答案。我们留给你来证明这一点。
现在，如果我们回到最初的问题，我们会注意到找到交汇点的 X 和 Y 坐标是两个独立的任务。这是因为人们移动的方式——曼哈顿距离。这让我们得出最终结论，我们必须解决两个 1D 问题，这将给我们最终答案。由于我们已经知道如何解决 1D 情况，所以我们已经完成了。
这种策略可以让你开始思考问题的更简单版本，并得出一些关于如何解决原始问题的结论。
尝试几个例子
我们注意到，应聘者很少使用面试官给出的例子以外的示例进行测试。然而，有时这很有帮助。如果您尝试解决您创建的一些示例输入，您可能会开始注意到模式。您可以告诉面试官您想尝试写下几个例子以尝试找到一些模式。然后快速做，看看它会带您去哪里。
以下是一个示例问题：
“有 N+1 个停车位，编号从 0 到 N。有 N 辆车停在不同的停车位，编号从 1 到 N，其中有一个是空的。重新排列汽车，使 1 号车停在 1 号停车位，2 号车停在 2 号停车位，以此类推。0 号停车位将保持空置。唯一允许的操作是取走一辆车并将其移到空车位。”
这个问题并不难，但一开始看起来有点吓人。写下 5 个不同的示例，并尝试在一张纸上按汽车的顺序排列。看看你是否能注意到其中的规律。
思考合适的数据结构
对于某些问题，某种数据结构显然可以解决问题。如果您开始有这种感觉，请考虑您了解的数据结构并尝试应用它们，看看它们是否合适。例如，您可以考虑我们在算法主题部分中介绍的数据结构。
以下是一个示例问题：
“设计一个数据结构，它支持多种操作：用 O(logN) 插入一个数字，用 O(1) 返回中位数元素，用 O(logN) 删除中位数元素，其中 N 是数据结构中元素的数量。”
这里显然涉及到数据结构。我们可以使用什么来解决这个问题？哪种数据结构具有类似的特性？数组、堆栈和向量等东西远远达不到这些要求。也许某种二叉树可以做到，因为它们通常支持对数插入和删除操作。
堆可以做到这一点，但它们要么返回最小元素，要么返回最大元素，而不是中位数。嗯，但这非常接近，如果我们能得到中位数就好了。如果我们使用两个堆，一个存储一半最小的数字，另一个存储另一半最大的数字。那么中间的某个数字就是中位数。如上所述，其中一个堆可以保存最大值，另一个可以保存最小值。这应该足以在恒定时间内返回中位数。我们将把细节留给您去弄清楚。
总之，如果你觉得某个数据结构可能是你所给出的问题的解决方案，那么请仔细考虑一下你所知道的数据结构。你可能需要结合两个或更多数据结构才能得到正确的解决方案。
思考一下你知道的相关问题。
这是一个简单的想法，如果没有其他方法，它可能会有所帮助。由于你一直在努力练习面试，所以你肯定遇到过很多不同的问题。如果你看到一个问题，但想不出解决办法，试着回忆一下另一个类似的问题。如果有这样的问题，想想它的解决方案是否可以以某种方式调整以解决手头的问题。这有时会误导你，但许多问题都是相关的，所以它也可以让你摆脱困境。
仔细阅读这些策略并尝试将它们应用于您面临的问题。本课程中有许多推荐问题，您可以全部应用。算法设计画布将帮助您写下您想到的想法。
TopCoder 教程还提供了有关该主题的有用资源，您可能会觉得值得一读：如何找到解决方案。
如果您有其他解决面试问题的策略，我们将非常乐意听到。
例子 
复杂
对于面试时提出的每一个想法，评估其效率非常重要。效率是通过计算底层算法的时间和内存复杂度来衡量的。
为什么复杂性如此重要？
解决问题不仅仅是找到计算正确答案的方法。解决方案应该足够快，并且内存使用合理。否则，即使是最聪明的解决方案也是无用的。因此，你必须向面试官展示两件事：
1.您的解决方案在速度和内存方面足够好。
2.您能够评估各种算法解决方案的时间和内存复杂度。
通常，如果你未能评估解决方案的这些参数，这将降低你通过技术面试的机会。面试官需要知道，如果你被录用，你将能够明智地选择你实施的解决方案。
必读内容
如果您不确定自己对这个主题的了解程度，我们准备了一个单独的部分，其中包含一些解释。它被称为计算复杂性，紧接着本节。
您将在其中找到一些课程和非常有用的资源链接，它们将为您提供更多信息。在我们提供的课程中，您还将找到一些关于如何在技术面试中讨论复杂问题的指导。
我们还编制了《复杂性讲义》，其中包括许多最著名算法的复杂性。与所有讲义一样，您可以随意打印出来并参考。但是，请记住，仅仅记住这些内容毫无意义。相反，请阅读理论文章并确保您可以自己解决这些复杂性。
下载复杂性讲义（PDF）。
例子
我们将继续以 ZigZag 任务为例，介绍如何在面试中评估其复杂性。如果您不熟悉视频中的所有内容，您可能需要先浏览计算复杂性部分。
编写代码
此时，您已经确定了问题的约束条件，反复考虑了一些想法，评估了它们的复杂性，并最终选择了要实施的想法。这是一个很棒的状态！
我们看到许多人直接开始编码，忽略了所有前面的步骤。这在现实生活中很糟糕，在面试时这样做也不好。在与面试官考虑和讨论限制、想法和复杂性之前，永远不要直接开始编码。
现在我们已将其从系统中删除，让我们集中讨论您在面试时如何编码。
关于编码，除了太快开始之外，许多人都感到困惑的一件事是，在 IDE 中编码与在白板/共享文档/使用某些在线系统（简而言之：“在 IDE 之外”）上编码是不一样的。作为工程师，我们已经习惯了依赖 IDE（这并不坏），以至于当面对一张白纸时，我们就会不知所措。虽然这在日常工作中可能没问题，但在面试中却行不通。
这就是为什么你需要为“面试编码”做特别的准备。向画布上的“代码”大块问好，等待你填写源代码。一开始在纸上写代码可能有点乏味，但很快你就会习惯它，并且变得更有效率。好消息是，能够在纸上编码不仅会提高你的面试技巧，还会使你成为一名更优秀的工程师。
在 IDE 之外进行编码时需要牢记的一些关键事项：
编码前请三思。尤其是如果你在纸上编码（没有“撤消”），如果你不小心，一切都会很快变得非常混乱
在 IDE 之外进行编码并不意味着您可以放弃遵守良好的代码风格。请确保正确命名变量、正确缩进、编写干净的代码等。
更重要的是将代码分解成小的逻辑片段，而不是复制粘贴
在声称代码准备就绪之前，请多次阅读代码。您没有时间编译、查看是否编译、运行、查看是否运行，然后调试 4 个小时。您的代码需要立即运行。
如今，似乎越来越多的技术面试都是在线进行的，甚至所谓的“现场”面试也是如此。这通常意味着在某种共享编辑器中编码，但不一定是功能齐全的 IDE。这可能比在白板或纸上书写更容易，但本课中的许多要点都适用于这些情况。在 LeetCode 等网站上解决问题提供了类似的体验，例如默认情况下没有自动完成功能，但有语法突出显示和自动识别等帮助功能。通常，事先检查面试期间的代码将以何种方式编写是个好主意。一旦你知道了这一点，就试着找到一种方法来模拟这种环境并在其中编写解决方案。如果你不清楚面试的编码部分将如何进行，那么最好的选择可能是在纸上、白板或简单的编辑器上练习，以应对所有可能性。
就这样。现在，暂时告别你的 IDE，开始练习吧！
例子 
让我们将所学知识应用到 ZigZag 问题中。请记住 - 不要使用您的 IDE。
int longestZigZagSequence(int N, std::vector<int> a) {
  std::vector<int> up;
  std::vector<int> down;
  int bestLength = 1;

  up.push_back(1);
  down.push_back(1);

  for (int i = 1; i < N; i++) {
    up.push_back(1);
    down.push_back(1);

    for (int j = 0; j < i; j++) {
      if (a[i] > a[j]) {
        up[i] = max(down[j] + 1, up[i]);
      }
      if (a[i] < a[j]) {
        down[i] = max(up[j] + 1, down[i]);
      }
    }
    bestLength = max(bestLength, max(up[i], down[i]));
  }

  return bestLength;
}
测试代码
写完代码后，你不会只是拿起笔说“我准备好了”然后就走。下一步最好是用几个小测试用例来验证它。如果你能告诉面试官除了这些示例测试之外，你还将如何对代码进行广泛的单元测试，那就更好了。
为什么要写测试？
表现出你了解并关心测试是一个很大的优势。这表明你从根本上理解测试在软件开发过程中的重要作用。这让面试官有信心，一旦被录用，你就不会开始编写有缺陷的代码并将其交付生产，而是会编写单元测试、检查代码、完成示例场景等。
样本测试 vs 广泛测试
在讨论什么是好的测试案例之前，我们要先澄清一下面试时的测试。面试时可能会要求你做（或决定做）两种测试。
我们将第一种测试称为“样本”测试：这些是一些小例子，你可以将它们输入到代码中，逐行运行以确保代码有效。你可能希望在代码编写完成后执行此操作，或者面试官可能会要求你执行此操作。这里的关键词是“小”：而不是“简单”或“琐碎”。
或者，面试官可能会要求你进行更“广泛”的测试，要求你为你的解决方案提出一些好的测试用例。通常，你不会被要求一步一步地运行它们。这更像是一种心理测试设计练习，以证明你是否擅长对你的代码进行单元测试。
从根本上来说，它们是截然不同的。我们将分别讨论这两种情况。
广泛的测试
让我们从更大的话题开始：什么构成了一个好的测试用例。如果您要为您的解决方案编译一组广泛的测试，这些测试应该是什么？这里有一个很好的列表可以帮助您入门。
边缘情况：还记得我们填写的“约束”部分吗？它会非常有用。设计案例可确保在达到约束的最小值和/或最大值时代码能够正常工作。这包括负数、空数组、空字符串等。
没有解决方案的情况：确保代码做正确的事情（希望你知道它是什么）
非平凡功能测试：这些测试很大程度上取决于问题。它们将测试解决方案的内部逻辑，以确保算法正确运行。
随机测试：这可以确保您的代码在“平均”情况下运行良好，而不是仅在人工生成的测试（存在固有偏见）中运行良好。
负载测试：使用约束允许的尽可能多的数据测试您的代码。这些测试可防止您的代码运行缓慢、占用过多内存或导致堆栈溢出。
好的“测试集”是上述类型的均衡组合。它将包括涵盖大多数边缘情况的测试、一些非平凡的功能测试，然后是一系列随机测试。这些将确保代码可靠且功能正确。最后，一些负载测试可确保算法在最大和资源需求最高的测试中运行良好。
示例测试
样本测试是您在面试时运行代码以确保其可靠性的小型测试。现在我们已经介绍了您可能设计的主要测试类型，您应该使用哪些测试作为样本测试？
通常，出于显而易见的原因，我们在面试期间不会进行随机测试和负载测试。相反，我们喜欢选择小规模版本的非平凡功能测试，以确保代码正确运行。然后，我们查看代码对几种边缘情况的反应，最后考虑如果找不到解决方案，代码是否能正常工作。
这种组合（非平凡函数 + 优势 + 无解决方案）往往是最有效的。就设计测试并在纸上对代码运行测试所花费的时间而言，它为您的代码提供了最高的确定性。
如何准备
有三项很好的练习活动可以显著提高您的测试技能。
1.首先要确保你理解基本类型的算法测试（如上所述）。
2.第二步是关注给定问题的样本测试用例。算法问题通常有几个“开放”测试用例（问题陈述的一部分）。注意它们试图涵盖哪些情况。它们通常不足以涵盖所有有趣的情况，因此您可能需要想出自己的测试用例来涵盖更多边缘情况。
3.第三步是始终填写算法设计画布的“测试用例”部分。看看你能想出什么场景。
无论您如何准备，这里的关键信息是不要忽略测试您的解决方案。编写代码后阅读代码并使用精心选择的测试用例进行测试，将对发现从愚蠢的拼写错误到实际错误的所有问题产生巨大影响。仔细选择测试用例，这样就不会浪费大量时间。通过一些练习，您将学会做到这一点。
最后，如果你为你的解决方案提出了一些很好的测试用例，并检查它是否对他们有用，这应该会给面试官留下非常积极的印象。我们在面试过程中注意到的一件事是，很少有候选人记得测试他们的解决方案，哪怕只有一个测试。甚至更少的人会建议任何单元测试，他们会在生产环境中编写这些测试。在解决问题的基础上这样做很可能会让你脱颖而出。
例子
如何练习？
至此，您已经掌握了算法设计画布的理论基础。这是一项了不起的成就，您已经领先于大多数申请人。
下一个基本问题是如何最有效地利用你刚刚学到的知识，并开始将其应用于实践。你在哪里找到练习题，以及在准备面试时如何解决这些问题？
继续阅读。
与 HiredInTech 一起实践
在接下来的部分中，您将看到一些按主题排序的建议练习任务，以及每个主题的一些学习材料。您可以尝试使用 Canvas 等工具自行解决这些任务。
使用在线评判员
LeetCode等在线评委是您备考必备的工具。您可以阅读任意数量的书籍，也可以浏览数十道题目的解答，但没有什么比练习 100% 正确解答一道题目更棒的了。
在线评委通过一些相当严格的测试自动对您的解决方案进行评分（并支持大量编程语言）。它们还可以充当问题库、额外的学习资源、支持社区等。
这里还有一些可以练习解决算法任务的网站：
代码厨师
代码力量
始终遵循画布
许多人在练习时都忍不住跳过画布上的某些部分。有时他们这样做是因为他们认为这样可以节省时间，有时是因为他们过于自信，认为问题太简单了。
这不是一个好主意。Canvas 旨在培养你面试技巧的各个方面，因为你永远不知道面试官会关注什么。通过在练习期间系统地思考所有领域，当面试官真正开始面试时，你会更加自信，最终也会更加成功。
忘掉你的 IDE
正如我们在代码部分所讨论的那样，在 IDE 中编写代码与在 IDE 之外编写代码有着根本的不同。真正体会到这种差异并克服相关问题的唯一方法就是忘记你的 IDE。
这就是 Canvas 中“代码”部分存在的原因 - 只需在那里编写代码即可。或者，如果您正在使用在线评判员进行练习（强烈推荐），请在提供的编辑器中编写代码，或者如果您愿意，可以先在其他地方编写代码，然后复制/粘贴以提交。
通读你的代码
我们都知道，有些人的自然风格是编写一些代码，然后立即尝试运行它，看看它是否适用于某些测试用例。他们花大约 20% 的时间编写代码，然后可能花 80% 的时间调试它。虽然这在现实生活中可能很有效，但在面试中根本行不通。你没有调试器，也没有自动执行代码的东西。
相反，你应该仔细思考你写的代码，然后在写完之后花一些时间检查它。如果你使用在线评判器，在实际点击“编译”和“运行测试”之前，请确保你 100% 确信你的代码将在测试中编译和正确运行。这种仔细检查代码的做法在面试中非常有用。
概括
在本节中，您学习了几个提高练习效率和效果的重要技巧。请记住：
注册一个像 LeetCode 这样的自动在线评判系统。
始终遵循 Canvas，即使是较简单的问题。
不要使用你的 IDE，这样你就可以训练你的面试编码技能。
在 TopCoder 上编译和运行自动化测试之前，请阅读并检查您的代码。
下一步是什么？
记住这些提示，让我们开始学习一些算法理论和实践。在本课程的下一部分中，我们将介绍最重要的主题并建议您可以解决的练习任务。让我们开始练习吧！
此外，本节还有最后一课，建议再练习一种方式，我们称之为“闪电回合”。一旦你对自己的任务解决技能有信心，就可以看看这些。
计算复杂性
正如本课程前面提到的，我们将专门用一节来讨论计算复杂性，因为这是设计几乎任何软件解决方案时都需要考虑的关键因素 - 从小型程序到大型软件系统。让我们先从一些非正式的解释开始，了解一下它是什么，以及它为什么对你的科技面试如此重要。
想象一下，您被赋予一项任务，使用一组N拉丁字母生成所有回文。一个想到的强力解决方案是生成N字母的所有排列，并检查每个字母是否是回文。有些人可能会说这项任务很容易，因为这个解决方案很容易想出。但是，要生成字母的所有排列，N您需要生成N!单词。即使是很小的值，N这也成为一个解决方案，它不会在合理的时间内完成。因此，我们需要设计一种更好的方法，可以更快地计算答案。
在技​​术面试中，你经常需要计算并解释解决方案的时间和内存复杂度。这将向面试官表明，你可以根据问题要求评估解决方案是否可行。在现实生活中，这也是一项非常有用的技能。实际上，我们认为，对于优秀的软件工程师来说，这是一项必备技能。
我们的程序受限的两种资源是时间和内存。当然还有其他资源，但这两个通常是我们解决方案的主要制约因素。这就是为什么在本节中我们将重点关注时间和内存复杂性。我们将讨论为什么它们是你在技术面试中绝对应该能够理解和衡量的东西。当然，我们还将提供一些解释和示例来帮助你更好地理解它们。
时间复杂度
让我们看一些例子，以便更好地理解算法的时间复杂度。稍后我们还将研究内存复杂度，因为这是我们必须处理的另一个有限资源。
首先，时间复杂度将根据输入大小来衡量。正如您在上一课的回文示例中看到的，N是用于构建回文的拉丁字母的数量。我们说这些N字母的所有排列都是N!。因此，要生成它们，我们将执行与成比例的步骤数N!。当然，生成每个单独的排列需要多少步也很重要。可以用恒定数量的步骤来做到这一点。我们不会详细介绍如何做到这一点，但请相信我们。
这意味着生成每个下一个排列的步骤数与输入的大小无关。对于每个生成的排列，我们都需要检查它是否是回文。一种方法是比较第一个和最后一个字母，然后比较第二个和倒数第二个字母，依此类推。这将需要与字母数量成比例的步骤数 - N。因此，对于每个排列，我们将执行那么多步骤。
考虑到所有这些，我们将必须执行与成比例的步骤数才能N * N!执行我们的强力解决方案。这个数字将乘以某个常数，但是通常当这个常数不是太高时，我们不会考虑它。现在我们已经快速分析了所需的步骤数，我们可以清楚地看到，随着值的增加，步骤数将非常快速地增长N。例如，如果面试官告诉你，这个数字N可能高达 100，那么考虑这样的解决方案也是没有用的。100！是一个非常大的数字，具有这种时间复杂度的解决方案是不切实际的。当然，这是一个在面试中提到的可能的初始解决方案，但你需要承认你需要更好的解决方案，这只是一个起点。能够向面试官描述为什么这样的解决方案不可行也是一项有用的技能。
让我们看另一个例子。想象一个代码块，它对一个整数数组进行排序：
// An array `arr` with `len` integers in it is sorted.for (int i = 0; i < len - 1; i++) {  for (int j = i + 1; j < len; j++) {    if (arr[i] > arr[j]) {      int tmp = arr[i];      arr[i] = arr[j];      arr[j] = tmp;    }  }}
这个算法有两个嵌套循环。外层循环从左到右遍历数字，并找到每个位置必须有的数字。对于位置 0 的数字，它会找到所有数字中的最小值。然后，对于位置 1 的数字，它会找到所有剩余数字中的最小值，依此类推。我们在这里要回答的问题是：这个算法的时间复杂度是多少？
外循环将执行N-1迭代，其中N是要排序的数字的数量。这是我们的参数，表示输入的大小。对于外循环的每次迭代，内循环将执行不同数量的步骤。在第一次迭代中，它将执行N-1步骤，接下来它将执行N-2步骤，依此类推。
循环内部有一个比较，在某些情况下，将有三个操作用于交换两个值。无论如何，循环内部的这些操作都需要恒定的时间N。这就是为什么我们更感兴趣计算两个循环将执行的总迭代次数。要计算这个，我们只需要将内循环的迭代次数相加：(N-1) + (N-2) + ... + 2 + 1 = N * (N-1) / 2。这个数字与成比例，N^2因为如果我们展开它，我们将得到N^2 / 2 - N / 2。我们总是对次数最高的项感兴趣，这里就是N^2。它乘以一个常数- 1/2 -但这并不能改变总步数将与成比例的事实，N^2并且随着N线性增长，我们的算法速度将二次减慢。
另一件需要提及的重要事情是，您通常对找出算法中最慢的部分感兴趣。也许对于某些任务，您有一个解决方案，首先进行一些预处理，大约需要N*M步，其中N和M是一些标识输入大小的值。但是，如果您的核心算法执行N*M^2步来运行，那么您可以说这是您的实际时间复杂度，因为它的阶数高于N*M。
对于计算复杂度的定义，我们有几种正式定义，可根据具体情况使用。对于大多数技术面试和实时示例，您需要使用所谓的大 O 符号。下面我们提供了一些有用资源的链接，这些资源将使用或多或少正式的语言告诉您有关大 O 和其他符号的更多信息。
资源 
记忆复杂度
要测量解决方案的内存复杂度，您可以使用我们在本节中已经描述的很多东西。不同之处在于，您需要测量解决方案在某一时间点使用的最大内存量。为什么这很重要？主要是因为每次在给定机器上运行软件时，您都只有有限的内存量。超过这个数量，您就会有麻烦。最有可能的第一个影响是操作系统将开始将内存交换到硬盘，这将使执行速度慢得多，而且实际上毫无用处。
希望您同意内存使用量与算法的运行速度同样重要。您可以采用与测量时间复杂度类似的方法来测量它。例如，让我们再次看一下拉丁字母排列的示例。首先，要保存所有字母，您需要与N（字母数量）成比例的内存。然后，要生成所有排列，您可以使用相同的数组并在其中生成后续排列。检查字母序列是否为回文不需要额外的内存。我们可以说这种强力解决方案需要与成比例的内存N。就内存使用量而言，这个解决方案还不错。
让我们看另一个例子。考虑一个任务，您需要在其中存储有关某种网络的信息。网络具有连接它们的节点和边。我们将在涵盖图表的部分中查看更多类似的任务，但在本课中，我们只关注如何在内存中表示网络。
一种方法是存储一个大小M为 的方阵，N x N其中N是网络中节点的数量。在每个单元格中，我们将有 0 或 1 表示节点和M[i][j]之间是否有边。这种网络表示要求我们使用与 成比例的内存。ijN^2
另一种方法是为每个节点存储一个它所连接的节点列表。在这种情况下，我们可以分配与网络中边数成比例的内存。如果没有指定其他内容，边数可以从 0 到 不等N * (N-1)。这意味着在最坏的情况下，使用的内存也将与 成比例N^2，就像之前的表示一样。但是，如果例如我们知道网络非常稀疏并且没有很多边，则使用的内存将少于我们使用第一种方法所消耗的内存。我们甚至可以更进一步，根据节点数N和边数来定义内存使用M情况。假设列表存储在哈希图中，其中键是给定节点的某个标签，值是它有边的其他节点的列表。然后，这个哈希图将具有与它们相连的边的节点的键，并且对于网络中的每个边，将有一个条目，该条目位于作为值存储在哈希图中的列表中。这意味着内存复杂度与边数成比例M。
在技​​术面试中为问题设计解决方案时，您需要能够计算内存复杂度，以便您可以向面试官解释在输入约束的情况下解决方案的好坏。
在现实生活中如何使用它？
希望到现在为止，你已经很好地理解了计算复杂度的含义。你应该能够计算出在编程面试或工作中可能遇到的大多数算法解决方案的时间和内存复杂度。
如果现在还不太清楚，不要担心。为了更熟练地掌握算法，最好的办法就是练习。只需采用不同的算法问题及其解决方案，并尝试评估时间和内存复杂度。然后查看一些关于它们的解释，看看你是否做对了。这需要时间，但一旦你掌握了这项技能，它对你来说将非常宝贵。
计算复杂性还有一个方面，它如何帮助我们评估不同的软件解决方案。假设您可以确定解决方案的时间复杂性。您还知道预期的输入。您如何确定解决方案是否运行得足够快？
如果一个解决方案的时间复杂度是O(N^2)并且N可以和一样大10,000，那是不是很好呢？
首先，这取决于您面临的时间限制。其次，您需要考虑解决方案将运行的机器。随着时间的推移，您将开始更好地理解解决方案在给定时间复杂度和输入大小的情况下究竟能运行多快。这不会立即发生，需要练习，但可以肯定的是，随着您完成各种示例，您会在这方面做得更好。
然而，了解同一问题的不同解决方案的时间或内存复杂度也可以让您比较它们并决定哪一个更好，或者需要做出哪些权衡。
对于内存，评估起来可能稍微容易一些，但仍然取决于具体情况。例如，编程语言可能不允许您计算使用的确切内存。如果您用 C 实现内容，那么可能更容易知道确切将使用多少内存。如果您使用提供更高级别抽象的语言，如 C++（例如使用 STL）或 Ruby、Java、Python，您可能需要进行实验以查看消耗了多少内存。
而且如果你知道内存复杂度，你就能对内存使用有一个相当好的预期。这比什么都没有要好得多。
现在，凭借这些知识，您可以继续学习下一部分，其中涵盖特定的算法主题，但在此之前，我们还有最后一节与该主题相关的小课。
在技​​术面试中
现在您对时间和内存复杂性背后的理论有了更好的理解，让我们来讨论如何在面试中最好地应用您所学到的知识。
在技​​术面试中，计算和讨论解决方案的复杂性会经常出现。你应该能够相当快地确定解决方案的时间和内存复杂性。这不应该花你很长时间。答案应该几乎立即出现。请记住，这里不需要复杂的数学运算。例如，不要指望有人会要求你使用主定理。除了极少数例外，我们在这里讨论的是标准复杂性。
如果您现在感觉不够自信，请不要担心。在计算解决方案的复杂性时，训练是真正变得顺利的最佳方法。当您使用算法设计画布解决问题时，请务必填写您设计的每个解决方案的复杂性框。不要跳过这个重要的步骤。这样做会帮助您变得更好。
还有一件事：实践表明，时间复杂性通常被讨论得更多一些。但是，你必须记住，时间和内存之间经常存在权衡。可以调整解决方案以使用更多内存并变得更快，反之亦然。因此，两种复杂性都很重要。你甚至可能处于解决方案可以朝两个方向中的任何一个方向推进的情况。在这种情况下，明智的做法是问面试官哪种资源更有价值。答案有望让你决定如何塑造你的解决方案。
概括
在本节中你学习了：
为什么时间和内存复杂性如此重要以及它们在编码面试中处于什么位置。
给定一个算法，如何计算它的复杂性。
给定算法的复杂性，建立关于该复杂性是否“足够”的直觉：在算法的约束条件下，它是否能够足够快地运行并消耗合理数量的内存。
数据结构
数据结构在许多算法任务中发挥着重要作用。这对于编码面试也是如此，因为您经常需要能够使用一个或多个数据结构来构建正确且有效的解决方案。如果您有信心使用这些数据结构，这将对您的面试大有帮助。一些最常用的数据结构是：
数组（在某些语言中也表示为列表或向量）
链接列表
堆
队列
树
图形
放
地图
这不是所有数据结构的详尽列表，但我们认为它涵盖了您需要非常了解的最基本数据结构。我们将逐步添加内容以通过本节中的课程来涵盖它们。
列表
作为程序员，我们经常需要处理有序的项目序列。这可能涉及对序列进行许多不同的操作，如遍历、搜索、计算统计数据和修改。在本节中，我们将重点介绍练习任务，这将帮助您获得更多该领域的经验。技术面试很可能包括我们将要讨论的一些技术。
在编程语言中，项目序列通常用称为数组或列表的结构来表示。我们将在本节中使用这些作为练习任务的一部分。
每个练习任务都会有一个解决方案，因此请务必查看这些解决方案以进一步学习。
资源
来自 Educative 的关于如何找到两个链表交点的课程。有关列表主题的更多信息可在同一课程的付费课程中找到。
跳过数字
任务说明
您将获得一个非负整数列表，并从该列表最左边的整数开始。之后，您需要执行以下步骤：
假设您当前位置的数字为，P您需要P在列表中向右跳转位置。例如，如果您位于位置 6，并且位置 6 的数字值为 3，则您需要跳转到位置 6 + 3 = 9。重复此操作，直到超出列表的右侧边界。
您的程序必须返回按照此逻辑需要执行的跳跃次数。请注意，列表可能包含数字 0，这意味着您可能会永远卡在这个位置。在这种情况下，您必须返回数字 -1。
输入列表的长度N在 [1, 1000] 范围内。
样本输入
3 4 1 2 5 6 9 0 1 2 3 1
示例输出
4
注意：在示例中，您从位置 1 开始，其中数字为 3。然后您必须跳转到位置 4，其中数字为 2。之后，您跳转到位置 6，其中数字为 6。这将带您到达位置 12，这是列表中的最后一个数字，其值为 1。从那里您向右跳转 1 个位置并必须停止。总共需要跳转 4 次。
解决方案
这是一项简单的任务，涉及运行一个循环，按照输入数据指定的顺序迭代输入列表或数组的索引。
您必须从最左边的位置开始，在编程语言中通常是索引 0。然后，您可以进行循环，该循环通过根据当前索引中包含的值计算要访问的下一个索引来遍历数组。
下面您将找到几种编程语言的示例解决方案。
C++
def jump_over_numbers(list):
    pos = 0
    ans = 0
    while pos < len(list):
        if list[pos] == 0:
            return -1
        ans += 1
        pos += list[pos]

    return ans

数字和
任务说明
实现一个程序，给定一个整数n，计算其各位数字之和。
如果给出的是负数，则该函数应该像正数一样工作。
例如，如果 n 为1325132435356，则数字的和为 43。如果 n 为 -10，则和为 1 + 0 = 1。
在这个任务的测试用例中我们将会拥有它-2^63 < n < 2^63。
测试示例
输入	输出
10	1
2	2
-3456	18
1325132435356	43
解决方案
这是将数字分成几位的经典任务。通常的做法是依次对数字取模 10，返回最后一位数字。之后，将数字除以 10，只使用整数部分。这样我们就得到了没有最后一位数字的数字。
如果您这样做来获取所有数字并对其求和，您将获得此任务所需的答案。
以下是 C++ 中的示例解决方案：
int digit_sum(long long number) {
  int sum = 0;
  if (number < 0) {
    number *= -1;
  }

  while (number > 0) {
    sum += number % 10;
    number /= 10;
  }

  return sum;
}
数字回文
任务说明
回文是一个单词、短语或数字，当它反转时，其内容保持不变。
例如，以下序列是回文：“azobi4amma4iboza”或“anna”。
但这次，我们感兴趣的不是文字，而是数字。“数字回文”是指数字倒过来后保持不变。
例如数字 1、4224、9999、1221 都是回文数。
实现一个函数，给定一个整数，计算它是否是回文。
输入
一个整数n，其中0 < n <= 10,000,000,000。
输出
true如果 n 是回文，则函数必须返回布尔值，false否则返回布尔值。
测试示例
输入	输出
1	真的
四十二	错误的
100001	真的
999	真的
123	错误的
解决方案
至少有两种有效的解决方案可以解决此问题。这两种方法都在内存使用量和遍历输入数字的次数之间进行了权衡。当然，由于我们讨论的是不超过 11 位的数字，因此额外的内存或所花费的时间并不重要。但是，我们将研究两种可能的方法来解决这个问题，以说明在编程中，您必须根据特定情况下的限制在不同的解决方案之间进行选择的频率。
一种使用额外内存的解决方案是将数字的各个数字存储在一个数组中，然后按顺序比较数组中必须相同的数字（如果数字是回文）。为了将数字的各个数字提取到一个数组中，您可以按顺序将其除以 10，得到余数，然后继续对其余数字进行处理，直到得到所有数字。然后，在数组中比较第一位和最后一位数字、第二位和倒数第二位数字，依此类推。
第二种解决方案不使用额外的内存，但需要对数字进行两次传递。第一次传递时，您可以检查数字的长度。这将帮助您从数字的左侧提取数字。一旦您知道数字有L数字，就意味着您可以通过将输入数字除以来获得最左边的数字N。10 ^ (L-1)此除法结果的其余部分将为您提供最左边的数字。要获得最右边的数字，只需除以 10 并取余数。
这样，您就可以依次提取数字的最左边和最右边的数字并进行比较。然后去掉这两个数字并重复该过程。这样做直到您处于数字的中间。以下是这些想法的两种实现。
您可能想知道在面试时选择哪种解决方案更好。在这种情况下，我们建议的方法是询问您的面试官。简要描述这两种解决方案以及它们涉及的权衡。然后，面试官很可能会告诉您选择两种解决方案中的一种，或者会给您一些额外的限制，使其中一种解决方案更有利。
在具有额外内存的 Python 中 
def is_numeric_palindrome(n):
  arr = []
  while(n > 0):
    arr.append(n % 10)
    n = n // 10

  num_len = len(arr)
  for i in range(num_len / 2):
    if arr[i] != arr[num_len - i - 1]:
      return False

  return True
动态规划
动态规划是一种非常广泛使用的技术。你可能甚至在不知情的情况下就应用了它。它的应用范围从非常简单的情况到更复杂的情况。然而，许多人甚至怀疑他们在面试中是否需要它。我们的经验表明，你很可能会遇到一个需要你使用动态规划来设计解决方案的问题。总的来说，这对许多软件工程师来说是有用的知识。根据你的工作内容，它有时会非常有用。
如何处理此部分？
有很多文章和书籍非常详尽地介绍了该主题。如果您是动态规划的新手，我们建议您阅读这些概述课程，然后阅读一些在线提供的更深入的文章。我们将在本课结束时提供有用的链接。一旦您对动态规划的知识充满信心，您就应该继续练习任务。
关于动态规划
那么，什么是动态规划？简而言之，这是一种方法，它允许您通过将问题分解为较小的子问题来解决问题。使用动态规划，您将尝试找到一种方法来将问题较小版本的答案结合起来，以计算较大版本的答案。如果您发现这种循环依赖关系，您将能够从一些非常琐碎的案例开始，您知道这些案例的答案，然后计算越来越大版本的问题的答案，直到您达到您最初感兴趣的版本。
如果您存储较小版本问题的答案，并在计算较大版本问题时重复使用计算值，则上述方法效果很好。这种技术称为“记忆化”。
简单示例
让我们从一个非常简单的例子开始，以说明上述内容。想想斐波那契数。我们如何计算第 100 个这样的数字：取第 98 个和第 99 个的总和。这可以被认为是将任务分解为更小任务的一个非常简单的例子。为了得到大小为 的问题的答案，N我们需要解决大小为N-1和 的N-2问题。如果我们这样往下走，我们将得到大小为 1 和 2 的简单问题，我们知道它们的答案。它们来自斐波那契数的定义：F(1) = 1和F(2) = 1。在某些情况下，可以说前两个值是 0 和 1，这对我们的例子来说并不那么重要。
这意味着如果我们计算规模不断增加的问题的答案，我们最终将得到 的答案F(100)。
让我们看看记忆法是如何起作用的。斐波那契数列的定义如下：F(n) = F(n-1) + F(n-2)。如果我们编写一个程序，通过递归调用来获得较小任务的答案，我们可能很快就会陷入麻烦。这是因为每个新调用都会产生两个新调用。这意味着在递归的最顶层将有一个调用，在第二层将有两个调用，在第 3 层将有 4 个调用等等。在每个下一级，调用次数将是其上一级的两倍。当然，在某个级别，递归将达到其中一个简单情况（F(1)和F(2)），但对于足够高的索引，我们达到问题的简单版本的级别将离初始调用非常远。
这个解决方案的伪代码如下：
def fibonacci(N)  if N <= 2 return 1;  return fibonacci(N-1) + fibonacci(N-2)end
作为一项小作业，你可以尝试计算不同 值时递归函数调用的次数N。这将帮助你观察到随着 N 线性增加，这些调用呈指数增长。
因此，如果我们想要找到索引过高（例如 100）的斐波那契数，这种动态规划的实现效率就不够。为什么会这样？主要原因是同一个斐波那契数会被一遍又一遍地计算。这是因为除第一个斐波那契数之外的每个斐波那契数都用于计算另外两个数。这在需要动态规划的不同问题中非常常见 - 同一个子问题是计算多个更大子问题的基石。我们可以将值存储一次，并在需要时从内存中重用它，而不是每次需要时都重新计算它。这就是记忆化的意义所在。
对于斐波那契数，让我们从下往上开始计算答案。最初我们存储 F(1) 和 F(2)，然后继续计算 F(3)、F(4)、F(5) 等等。伪代码如下所示：
F(1) = 1F(2) = 1for i = 3 to N  F(i) = F(i-1) + F(i-2)end
这样，我们只需计算一次每个子问题的答案。当然，我们可以坚持从顶部开始向下的初始递归解决方案。但我们需要确保缓存计算值，而不是一遍又一遍地计算它们。以下是一些代码：
F(1) = 1F(2) = 1def fibonacci(N)  if F(N) is not stored    F(N) = fibonacci(N-1) + fibonacci(N-2)  end  return F(N)end
此解决方案将计算值存储在内存中，如果已计算，则重复使用它们。如果尚未计算某个值，我们会进行递归调用以获取较小子问题的答案。但是，由于没有值被计算超过一次，因此复杂性现在是线性的，而不是我们在未使用记忆的递归解决方案中观察到的生成任务的指数增长。
多个维度
到目前为止，我们阐述了动态规划的基本思想 - 可以使用较小子问题的答案来计算给定问题的答案。我们还表明，没有必要多次计算同一子问题的答案，并且我们可以存储计算出的答案并重复使用它。
斐波那契问题仅由一个维度定义 - 数字的索引。但是，动态规划可以应用于由多个参数定义的问题。可以使用动态规划解决的一个非常流行的问题是“0-1 背包问题”。
在这个问题中，我们有一组N物品，每个物品都有给定的重量和价值（W[i]和V[i]）。我们有一个最大容量为的背包C。我们的目标是选择将哪些物品放入背包，使得它们的总重量不超过C并且它们的总价值尽可能大。
为了解决这个任务，我们需要定义什么是问题，以及如何使用较小的子问题的答案来计算一个问题的答案。
假设我们以某种方式对物品进行排序，这样我们就有了物品 1、物品 2 等等。我们可以用两个参数来描述一个问题 - 允许的最大容量和要考虑的物品的最高索引。要解决的最终问题的这些值是N最高索引和C容量。现在的问题是：我们如何将其分解为更小的子问题？
对于由一些值描述的给定版本的问题N，C我们有两个选择：
1.将带有索引的物品N放入背包，并减少容量C - W[N]
2.不要将带有索引的物品N放入背包并保持容量C
在第一种情况下，我们将对参数为 的问题的答案感兴趣N-1。C - W[N]当考虑第一个N-1项目并将总重量限制为时，此答案将为我们提供最大可获得的值C - W[N]。我们可以将项目的值添加到此答案中，N因为我们决定将其放入背包中。
在第二种情况下，我们将对参数为 的问题的答案感兴趣N-1。C当考虑第一件N-1物品并将总重量限制为时，此答案将为我们提供最大可获得的值C。对于这个答案，我们不会增加任何值，因为我们已决定不将物品放入N背包。
由于我们需要在将物品添加N到背包中和不添加物品之间做出选择，因此我们应该在以下两个可能的答案中取最大值：
F(N, C) = max(F(N-1, C-W[N]) + V[N], F(N-1, C))
这是我们的递归依赖关系。当然，现在我们需要考虑基本情况。
基值将是全部F(1, *)和F(*, 0)。第一组是我们只允许取范围中任意容量的第一个项[0, C]。第二组是最大重量容量为 0 的子问题。
因为F(1, *)我们可以说，对于允许容量小于的这些子问题，答案是 0，而对于最大容量可以承受物品 1 的重量的其余情况，W[1]答案等于。V[1]
我们都F(*, 0)知道答案是 0，因为没有可用容量来容纳任何元素。
我们寻找的答案是F(N, C)。
对于斐波那契数，我们表明答案可以通过“自下而上”或“自上而下”的方式计算。第一种方式意味着我们从基本情况开始，然后继续解决最终问题。在这个任务中，这意味着首先计算，F(1, *)然后计算，依此类推，直到达到。对于这种方法，请注意，在计算时我们只需要来自的值。因此，我们不需要一直存储早期的值。这可以帮助我们节省大量内存。F(2, *)F(3, *)F(N, *)F(i, *)F(i-1, *)
第二种方法“自上而下”涉及一种递归方法，在这种方法中，我们存储并重复使用计算一次的值。这就是记忆技术。如果没有它，我们将多次计算相同的值，这将使我们的解决方案非常低效。

 


隐私政策
结论
这是动态规划的简要介绍。我们通过示例展示了将问题分解为子问题的含义。通常有不同的方法来实现计算。一种方法是“自下而上”，即从基本情况开始计算值，直到达到所需值。另一种方法是“自上而下”，即我们根据需要递归计算较小问题的答案，但尝试存储计算出的值，以免多次计算。这种技术通常称为“记忆化”。
有时，特别是对于“自下而上”的实现，可以一次只存储计算值的一部分，并在其他部分完成计算后释放内存。
最长递增子序列
任务说明
给定一个N整数列表，找到其中最长的递增子序列。
例子
如果列表是[16, 3, 5, 19, 10, 14, 12, 0, 15]一个可能的答案是子序列[3, 5, 10, 12, 15]，另一个是[3, 5, 10, 14, 15]。
如果列表只有一个整数，例如：[14]，则正确答案是[14]。
再举一个例子：[10, 8, 6, 4, 2, 0]，可能的正确答案是[8]。
测试用例
您的解决方案将根据多个测试用例进行评分。所有测试用例至少包含一个整数。其中一半的1,000输入序列不超过 个整数。另一半将包含最多10,000个整数的序列。
您可以设计一个解决方案，它运行速度足够快，N <= 1,000但对于较大的输入来说速度较慢。尝试看看您可以创建多好的解决方案。当然，目标是获得最高分！
这个问题至少有两种不同的解决方案，使用动态规划。我们将要讨论的第一个解决方案速度较慢，如果你将它用于此练习任务，你的解决方案很可能不会通过所有测试用例。

较慢的解决方案 - O(N^2)
对于第一个解决方案，我们的问题是找到以位置-的S数字结尾的序列的最长递增子序列。一旦我们得到所有可能的最后一个数字的答案，我们就可以得到最佳答案。但是，我们如何计算位置 处给定数字的答案呢？S[i]iF(i)i
如果我们想要计算，F(i)我们可以循环遍历左边的所有数字S[i]，并考虑比它小的数字。我们只对较小的数字感兴趣，因为我们将寻找可以附加的可能子序列S[i]。我们可以取最长的一个，并将它的长度加 1，以形成一个以位置结尾的新子序列i。这将是 的答案F[i]。我们可以从左到右迭代，计算 的值F[i]。这样，我们就可以确保F我们所在位置左边的所有 值都已计算。
基本情况是针对最左边的数字。我们知道，对于它，最佳答案是 1，即仅由这个数字组成的子序列。
对于位置中的每个数字，i一旦我们计算出来，F[i]我们就会存储序列中前一个数字的位置，以便可以在需要最终答案时恢复整个序列。
下面是展示这个想法的伪代码：
# S holds the numbers, it's length is L
# P holds the index of the previous number

F[1] = 1
P[1] = -1
best_index = 1

for i = 2 to L
  F[i] = 1
  P[i] = -1
  for j = 1 to i-1
    if S[j] < S[i] and F[j] + 1 > F[i]
      F[i] = F[j] + 1
      P[i] = j
      if F[best_index] < F[i]
        best_index = i
      end
    end
  end
end

answer = []
index = best_index
while index != -1
  answer.append(S[index])
  index = P[index]
end

print answer.reversed
如您所见，此解决方案在输入序列中元素的数量方面是二次的。考虑到在某些测试用例中可能存在多达 2,000,000 个数字，这样的时间复杂度可能不足以及时计算出答案。
在面试时，编写这个较慢的解决方案可能没问题，这取决于面试官的目标是什么。如果给定的约束足够低，您可能可以编写这个解决方案，但您可能首先需要与面试官确认这是否足够好。
更快的解决方案——O（NlogN）
如上所述，该问题还有另一种更快的解决方案，同样使用动态规划，但也利用一个有趣的观察。
S我们再次按从左到右的顺序处理数字—— S[1]，，S[2]等等。处理完每个元素后，算法将维护两个值数组：
M它保存了M[i]来自的最小数字的索引S，其中有一个长度以i数字结尾的递增子序列S[M[i]]。
P它保存的是最长递增子序列中以 结尾P[j]的数字的前身索引。S[j]S[j]
给定这两个数组，我们可以观察到引用的数字M将始终按递增顺序排列。对于S我们处理的每个新数字，我们应该检查是否有一个值M可以用新数字替换。这意味着我们找到了一个较小的数字作为给定长度的子序列中的最后一个数字。
例如，如果在给定时间点M引用数字，并且我们当前正在处理数字。这意味着到目前为止，我们已经发现结束长度为 1 的子序列的最小最后一个数字是。结束长度为 2 的子序列的最小数字是，依此类推。当前数字 5 介于 3 和 6 之间。这意味着如果我们将 5 附加到长度为 1 、以 3 结尾的子序列，我们将获得长度为 2 、以 5 结尾的子序列。这比我们目前拥有的 6 更好。因此，我们应该更新 M[2] 以指向这个新数字。[3, 6, 7, 10]536
现在是时候利用 的不断增加的排序了M。我们可以使用二分搜索来找到每个新数字的位置，而不必遍历 中的所有值M。这意味着对于我们处理的每个数字，我们只需要O(logN)几步就可以找到它的正确位置。这就是为什么整个算法的时间复杂度为O(NlogN)。
为了恢复最长的递增子序列，我们需要查看 M 中最右边的值，它将向我们显示可以结束具有最大可能长度的子序列的最小数字。由于我们还将存储前一个数字的索引P，因此可以返回并恢复整个序列。
最后，我们通过一个例子来看一下M和如何P变化，以说明该算法。输入序列是4, 2, 3, 12, 11。
步骤1：4
计算路径
任务说明
您将获得一个网格，网格大小N为M行 x 列。机器人位于左下角的单元格（行 x N-1，列 x 0）。它可以从一个单元格移动到另一个单元格，但只能向右和向上移动。有些单元格是空的，机器人可以穿过它们，但有些单元格不是空的，机器人不能进入这些单元格。机器人不能超出网格边界。
机器人的目标是到达右上单元格（行0，列M-1）。起始和结束单元格始终为空。您需要计算机器人从起点到终点可以走的不同路径的数量。仅计算访问空单元格并仅向右和向上移动的路径。
N并且M是 范围内的数字[1, 512]。
编写一个方法，接受网格作为参数并返回一个整数 - 机器人从起始单元到结束单元可以采取的不同路径的总数，MODULO 1,000,003。我们在这里使用模数运算的原因是实际结果可能是一个非常大的数字，我们不想让处理大数字使任务更加复杂。
输入网格将包含带有字符N的字符串M，每个字符串都是 -'0'或'1'，'0'表示空单元格，'1'表示已占用单元格。每个字符串都对应于网格中的一行。

解决方案
这是另一个经典任务，可以使用动态规划有效解决。机器人总是从左下角的单元格开始。我们需要找出子问题的参数。很明显，这可能是要到达的单元格的行和列。
一旦我们计算出顶行和最右列的答案，我们就能得到整个任务的答案。现在，让我们找出问题与其子问题之间的递归关系。
一旦机器人进入给定单元格(x, y)，就会出现两个其他单元格，机器人可能来自这两个单元格：(x-1, y)和(x, y-1)。这里我们假设行按从下到上的递增顺序编号，列按从左到右的递增顺序编号。当然，我们需要提到，对于某些单元格，机器人可能来自的单元格只有一个。而对于机器人的起始单元格，没有单元格可以让它来自那里。为简单起见，我们下面假设有两个单元格通向每个单元格。我们将不得不在实施中处理边缘情况。
上述含义意味着，对于每个单元格来说，(x, y)都会有两种类型的路径通向它：穿过的路径(x-1, y)和穿过的路径(x, y-1)。
这两组路径有一个空的交点。因此，我们可以很容易地说，(x, y)可以用以下方式计算答案：
F(x, y) = F(x-1, y) + F(x, y-1)
我们任务的基本情况是通向机器人起始单元的路径数量。显然，答案是 1。
还有一个细节需要提一下，对于那些F(x, y) = 0因为没有路径而被占用的单元格，是不可能到达这些单元格的。
正如本节中已经提到的，解决方案可以使用以下两种技术之一来计算答案：自下而上或自上而下。如果使用自下而上，则逐行计算答案将很容易，因为每个单元格只需要来自其下方行的一个值和来自同一行的一个值。如果需要，这将使我们能够节省内存。对于我们的特定任务，其中棋盘的最大尺寸为 512x512，将整个棋盘存储在内存中并不是什么大问题。
我们还可以实现自上而下的解决方案，它根据需要递归计算所需的值，并将每个单元的计算结果存储在内存中，以便可以重复使用。
所述解决方案的时间复杂度是O(N*M)因为对于每个单元我们只计算一次答案。
二分搜索
拥有已排序元素的一个非常重要的好处是能够快速搜索它们。如果您有一个已排序元素序列，则可以使用二分搜索来查找它是否包含给定元素，或者以时间复杂度找到已排序序列中新元素的正确位置O(logN)。对于足够大的序列，这比搜索整个序列直到找到答案的线性方法要好得多。
资源
def rec n, level, filename, files
  return if files.count == 1000 || filename > n
  files << filename if level > 0

  (0..9).each do |digit|
    next if digit == 0 && level == 0

    rec n, level+1, filename*10+digit, files
  end
end

files = []

# n is the total number of files
rec(n, 0, 0, files)

puts files.map { |number| "IMG#{number}.jpg" }
# n and t are the values from the task statement
# diffs contain the difficulties of tasks as provided in the input

diffs.sort!

sums = []

sums << 0
diffs.each do |diff|
  sums << sums[-1] + diff
end

ans = 0
last_right = 0

(0..n-1).each do |i|
  while last_right < n && diffs[last_right] - diffs[i] + sums[last_right+1] - sums[i] <= t
    last_right += 1
  end

  ans = [ans, last_right - i].max

  break if last_right == n
end

puts ans
int gcd(int a, int b) {
  while (b > 0) {
    int temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}
# n is the input integer for the task
limit = Math.sqrt(n).to_i

is_prime = [true] * limit

i = 2
ans = 1

while i <= limit
  if is_prime[i]
    cnt = 0
    while n % i == 0
      n /= i
      cnt += 1
    end

    ans *= (cnt + 1)

    j = i*i
    while j <= limit
      is_prime[j] = false
      j += i
    end
  end

  i += 1
end

ans *= 2 if n > 1

puts ans
# t - the input text
# w - the input search word
# n - the number of words around occurrences of `w` to search through

words = t.downcase.split.map { |word| word.gsub(/[^a-z0-9]/, '') }

hash = Hash.new(0)

last_covered = -1
words.each_with_index do |word, i|
  if word == w
    start = [last_covered+1, i-n, 0].max
    (start...i).each do |j|
      hash[words[j]] += 1 if words[j] != w
    end
    start = [last_covered+1, i+1].max
    stop = [i+n+1, words.count].min

    (start...stop).each do |j|
      hash[words[j]] += 1 if words[j] != w
    end

    last_covered = i+n
  end
end

ans = nil
ans_cnt = 0
hash.each do |k, v|
  if v > ans_cnt
    ans_cnt = v
    ans = k
  elsif v == ans_cnt && k < ans
    ans = k
  end
end

if ans
  puts ans
else
  puts 'N/A'
end
def matching_with_mistypes?(word1, word2)
  return false if word1.length != word2.length

  diffs = 0
  word1.length.times do |index|
    if word1[index] != word2[index]
      diffs += 1
      return false if diffs > 2
    end
  end

  true
end
def dfs(node)
  mark node as visited

  for next_node in neighbours(node)
    if not visited(next_node)
      dfs(next_node)
    end
  end
end
def bfs(node)
  queue.add(node)
  mark node as visited
  distance[node] = 0

  while not queue.empty
    top_node = queue.pop
    for next_node in neighbours(top_node)
      if not visited(next_node)
        queue.add(next_node)
        mark next_node as visited
        distance[node] = distance[top_node] + 1
      end
    end
  end
end
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int n, m, s;
vector<int> neighbours[513];
vector<bool> vis(513, false);

int main() {
  cin >> n >> m >> s;

  for (int i = 0; i < m; i++) {
    int from, to;
    cin >> from >> to;
    neighbours[from].push_back(to);
    neighbours[to].push_back(from);
  }

  queue<int> q;
  q.push(s);
  vis[s] = true;
  int result = 0;

  while (!q.empty()) {
    int node = q.front();
    q.pop();

    for (vector<int>::iterator it = neighbours[node].begin(); it != neighbours[node].end(); ++it) {
      if (!vis[*it]) {
        vis[*it] = true;
        q.push(*it);
        result++;
      }
    }
  }

  cout << result << endl;

  return 0;
}
闪电战
专题练习
大多数人花时间进行主题练习。他们选择一个主题（例如“字符串算法”或“图形问题”），然后开始解决与该主题相关的问题。
在某种程度上，这很有用。如果你知道你在某些主题上明显较弱，那么这尤其有用。
但在面试中，你根本不知道问题是图问题、数据结构问题还是动态规划问题。你需要训练你的直觉，快速辨别大量潜在想法并自己推断出主题。怎么做？
介绍：闪电战
在 HiredInTech，我们通过所谓的“闪电战”轮次来实现这一点。“闪电战”轮次是一段集中练习的时间（例如 2.5 小时），在此期间，您要解决一堆您一无所知的问题。您为每个问题设定一个固定的时间（例如 30 分钟），并尝试在这段时间内完成 Canvas 的所有区域。然后，您继续下一个问题。完成 3 或 5 个这样的问题后，您可以休息一下，打开一瓶啤酒或倒一些葡萄酒，然后给自己一个鼓励。
如果您使用在线评判门户，您可以挑选一些不同难度级别的问题，而无需检查它们来自哪个区域。然后将它们汇集在一起​​，您就构建了一个“闪电战会议”。如果您正在阅读一本书，那么对每个问题来自哪个主题感到“惊讶”会更困难一些，因为书籍倾向于按主题组织问题。这是我们强烈建议您在某个时候将您的练习切换到 HiredInTech 的练习任务或在线评判的另一个原因。
4 轮闪电战示例
为了帮助您入门，我们为您准备了两轮闪电战，每轮有五道 TopCoder 问题。您可以像在前面几节中一样使用 Arena 提交解决方案。
除此之外，还有两轮可选的快速答题，题目来自《破解编码面试：第五版》 。您可以使用Canvas的打印副本、一张纸或一块白板来解答。同样，每个问题的时间不要超过 30 分钟。
TopCoder Blitz 第一轮
问题 1 -陈述-解决方案
问题 2 -陈述-解决方案
问题 3 -陈述-解决方案
问题 4 -陈述-解决方案
问题 5 -陈述-解决方案
TopCoder Blitz 第二轮
问题 1 -陈述-解决方案
问题 2 -陈述-解决方案
问题 3 -陈述-解决方案
问题 4 -陈述-解决方案
问题 5 -陈述-解决方案
“破解编码面试”闪电战第一轮
问题：4.3、5.2、17.8、17.12、18.7
“破解编码面试”闪电战第二轮
问题：4.7、7.6、1.6、17.6、18.12
概括
在本节中，我们重点介绍了第二种练习的重要性，我们称之为“快速练习”。快速练习包括挑选一组 3 到 5 个问题，为每个问题设置时间限制（20 到 30 分钟），并按顺序填写每个问题的画布的所有区域。结合我们所谓的“主题”练习，快速练习可以增强您的信心，教您更好地管理时间，并让您在解决问题时更快、更流畅。
